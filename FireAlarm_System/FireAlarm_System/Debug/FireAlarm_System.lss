
FireAlarm_System.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002ca2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e6  00800060  00002ca2  00002d36  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004fc  00800146  00800146  00002e1c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002e1c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002e4c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000580  00000000  00000000  00002e88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006655  00000000  00000000  00003408  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001859  00000000  00000000  00009a5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000389e  00000000  00000000  0000b2b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000e94  00000000  00000000  0000eb54  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002155  00000000  00000000  0000f9e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000539f  00000000  00000000  00011b3d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e0  00000000  00000000  00016edc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       8:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      10:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      14:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      18:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      24:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      28:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      2c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      30:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      34:	0c 94 ef 12 	jmp	0x25de	; 0x25de <__vector_13>
      38:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      3c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      40:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      44:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      48:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      4c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      50:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      54:	08 00       	.word	0x0008	; ????
      56:	00 00       	nop
      58:	be 92       	st	-X, r11
      5a:	24 49       	sbci	r18, 0x94	; 148
      5c:	12 3e       	cpi	r17, 0xE2	; 226
      5e:	ab aa       	std	Y+51, r10	; 0x33
      60:	aa 2a       	or	r10, r26
      62:	be cd       	rjmp	.-1156   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
      64:	cc cc       	rjmp	.-1640   	; 0xfffff9fe <__eeprom_end+0xff7ef9fe>
      66:	4c 3e       	cpi	r20, 0xEC	; 236
      68:	00 00       	nop
      6a:	00 80       	ld	r0, Z
      6c:	be ab       	std	Y+54, r27	; 0x36
      6e:	aa aa       	std	Y+50, r10	; 0x32
      70:	aa 3e       	cpi	r26, 0xEA	; 234
      72:	00 00       	nop
      74:	00 00       	nop
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	00 00       	nop
      7e:	00 00       	nop
      80:	00 08       	sbc	r0, r0
      82:	41 78       	andi	r20, 0x81	; 129
      84:	d3 bb       	out	0x13, r29	; 19
      86:	43 87       	std	Z+11, r20	; 0x0b
      88:	d1 13       	cpse	r29, r17
      8a:	3d 19       	sub	r19, r13
      8c:	0e 3c       	cpi	r16, 0xCE	; 206
      8e:	c3 bd       	out	0x23, r28	; 35
      90:	42 82       	std	Z+2, r4	; 0x02
      92:	ad 2b       	or	r26, r29
      94:	3e 68       	ori	r19, 0x8E	; 142
      96:	ec 82       	std	Y+4, r14	; 0x04
      98:	76 be       	out	0x36, r7	; 54
      9a:	d9 8f       	std	Y+25, r29	; 0x19
      9c:	e1 a9       	ldd	r30, Z+49	; 0x31
      9e:	3e 4c       	sbci	r19, 0xCE	; 206
      a0:	80 ef       	ldi	r24, 0xF0	; 240
      a2:	ff be       	out	0x3f, r15	; 63
      a4:	01 c4       	rjmp	.+2050   	; 0x8a8 <prvUnlockQueue+0x44>
      a6:	ff 7f       	andi	r31, 0xFF	; 255
      a8:	3f 00       	.word	0x003f	; ????
      aa:	00 00       	nop
	...

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf e5       	ldi	r28, 0x5F	; 95
      b4:	d8 e0       	ldi	r29, 0x08	; 8
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_copy_data>:
      ba:	11 e0       	ldi	r17, 0x01	; 1
      bc:	a0 e6       	ldi	r26, 0x60	; 96
      be:	b0 e0       	ldi	r27, 0x00	; 0
      c0:	e2 ea       	ldi	r30, 0xA2	; 162
      c2:	fc e2       	ldi	r31, 0x2C	; 44
      c4:	02 c0       	rjmp	.+4      	; 0xca <__do_copy_data+0x10>
      c6:	05 90       	lpm	r0, Z+
      c8:	0d 92       	st	X+, r0
      ca:	a6 34       	cpi	r26, 0x46	; 70
      cc:	b1 07       	cpc	r27, r17
      ce:	d9 f7       	brne	.-10     	; 0xc6 <__do_copy_data+0xc>

000000d0 <__do_clear_bss>:
      d0:	26 e0       	ldi	r18, 0x06	; 6
      d2:	a6 e4       	ldi	r26, 0x46	; 70
      d4:	b1 e0       	ldi	r27, 0x01	; 1
      d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
      d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
      da:	a2 34       	cpi	r26, 0x42	; 66
      dc:	b2 07       	cpc	r27, r18
      de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>
      e0:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <main>
      e4:	0c 94 4f 16 	jmp	0x2c9e	; 0x2c9e <_exit>

000000e8 <__bad_interrupt>:
      e8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ec <prvTestWaitCondition>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
      ec:	41 11       	cpse	r20, r1
      ee:	06 c0       	rjmp	.+12     	; 0xfc <prvTestWaitCondition+0x10>
      f0:	68 23       	and	r22, r24
      f2:	79 23       	and	r23, r25
      f4:	67 2b       	or	r22, r23
      f6:	49 f4       	brne	.+18     	; 0x10a <prvTestWaitCondition+0x1e>
      f8:	80 e0       	ldi	r24, 0x00	; 0
      fa:	08 95       	ret
      fc:	86 23       	and	r24, r22
      fe:	97 23       	and	r25, r23
     100:	68 17       	cp	r22, r24
     102:	79 07       	cpc	r23, r25
     104:	21 f0       	breq	.+8      	; 0x10e <prvTestWaitCondition+0x22>
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	08 95       	ret
     10e:	81 e0       	ldi	r24, 0x01	; 1
     110:	08 95       	ret

00000112 <xEventGroupCreate>:
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	8b e0       	ldi	r24, 0x0B	; 11
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     11e:	ec 01       	movw	r28, r24
     120:	00 97       	sbiw	r24, 0x00	; 0
     122:	31 f0       	breq	.+12     	; 0x130 <xEventGroupCreate+0x1e>
     124:	fc 01       	movw	r30, r24
     126:	11 92       	st	Z+, r1
     128:	11 92       	st	Z+, r1
     12a:	cf 01       	movw	r24, r30
     12c:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     130:	ce 01       	movw	r24, r28
     132:	df 91       	pop	r29
     134:	cf 91       	pop	r28
     136:	08 95       	ret

00000138 <xEventGroupWaitBits>:
     138:	af 92       	push	r10
     13a:	bf 92       	push	r11
     13c:	cf 92       	push	r12
     13e:	df 92       	push	r13
     140:	ef 92       	push	r14
     142:	ff 92       	push	r15
     144:	0f 93       	push	r16
     146:	1f 93       	push	r17
     148:	cf 93       	push	r28
     14a:	df 93       	push	r29
     14c:	7c 01       	movw	r14, r24
     14e:	5b 01       	movw	r10, r22
     150:	c4 2e       	mov	r12, r20
     152:	d2 2e       	mov	r13, r18
     154:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
     158:	f7 01       	movw	r30, r14
     15a:	c0 81       	ld	r28, Z
     15c:	d1 81       	ldd	r29, Z+1	; 0x01
     15e:	4d 2d       	mov	r20, r13
     160:	b5 01       	movw	r22, r10
     162:	ce 01       	movw	r24, r28
     164:	0e 94 76 00 	call	0xec	; 0xec <prvTestWaitCondition>
     168:	88 23       	and	r24, r24
     16a:	69 f0       	breq	.+26     	; 0x186 <xEventGroupWaitBits+0x4e>
     16c:	cc 20       	and	r12, r12
     16e:	09 f1       	breq	.+66     	; 0x1b2 <xEventGroupWaitBits+0x7a>
     170:	c5 01       	movw	r24, r10
     172:	80 95       	com	r24
     174:	90 95       	com	r25
     176:	8c 23       	and	r24, r28
     178:	9d 23       	and	r25, r29
     17a:	f7 01       	movw	r30, r14
     17c:	91 83       	std	Z+1, r25	; 0x01
     17e:	80 83       	st	Z, r24
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	10 e0       	ldi	r17, 0x00	; 0
     184:	18 c0       	rjmp	.+48     	; 0x1b6 <xEventGroupWaitBits+0x7e>
     186:	01 15       	cp	r16, r1
     188:	11 05       	cpc	r17, r1
     18a:	a9 f0       	breq	.+42     	; 0x1b6 <xEventGroupWaitBits+0x7e>
     18c:	c1 10       	cpse	r12, r1
     18e:	03 c0       	rjmp	.+6      	; 0x196 <xEventGroupWaitBits+0x5e>
     190:	60 e0       	ldi	r22, 0x00	; 0
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	02 c0       	rjmp	.+4      	; 0x19a <xEventGroupWaitBits+0x62>
     196:	60 e0       	ldi	r22, 0x00	; 0
     198:	71 e0       	ldi	r23, 0x01	; 1
     19a:	d1 10       	cpse	r13, r1
     19c:	74 60       	ori	r23, 0x04	; 4
     19e:	6a 29       	or	r22, r10
     1a0:	7b 29       	or	r23, r11
     1a2:	a8 01       	movw	r20, r16
     1a4:	c7 01       	movw	r24, r14
     1a6:	02 96       	adiw	r24, 0x02	; 2
     1a8:	0e 94 2f 0a 	call	0x145e	; 0x145e <vTaskPlaceOnUnorderedEventList>
     1ac:	c0 e0       	ldi	r28, 0x00	; 0
     1ae:	d0 e0       	ldi	r29, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <xEventGroupWaitBits+0x7e>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
     1b6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     1ba:	01 2b       	or	r16, r17
     1bc:	19 f1       	breq	.+70     	; 0x204 <xEventGroupWaitBits+0xcc>
     1be:	81 11       	cpse	r24, r1
     1c0:	02 c0       	rjmp	.+4      	; 0x1c6 <xEventGroupWaitBits+0x8e>
     1c2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     1c6:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxTaskResetEventItemValue>
     1ca:	ec 01       	movw	r28, r24
     1cc:	91 fd       	sbrc	r25, 1
     1ce:	19 c0       	rjmp	.+50     	; 0x202 <xEventGroupWaitBits+0xca>
     1d0:	0f b6       	in	r0, 0x3f	; 63
     1d2:	f8 94       	cli
     1d4:	0f 92       	push	r0
     1d6:	f7 01       	movw	r30, r14
     1d8:	c0 81       	ld	r28, Z
     1da:	d1 81       	ldd	r29, Z+1	; 0x01
     1dc:	4d 2d       	mov	r20, r13
     1de:	b5 01       	movw	r22, r10
     1e0:	ce 01       	movw	r24, r28
     1e2:	0e 94 76 00 	call	0xec	; 0xec <prvTestWaitCondition>
     1e6:	88 23       	and	r24, r24
     1e8:	51 f0       	breq	.+20     	; 0x1fe <xEventGroupWaitBits+0xc6>
     1ea:	cc 20       	and	r12, r12
     1ec:	41 f0       	breq	.+16     	; 0x1fe <xEventGroupWaitBits+0xc6>
     1ee:	b5 01       	movw	r22, r10
     1f0:	60 95       	com	r22
     1f2:	70 95       	com	r23
     1f4:	6c 23       	and	r22, r28
     1f6:	7d 23       	and	r23, r29
     1f8:	f7 01       	movw	r30, r14
     1fa:	71 83       	std	Z+1, r23	; 0x01
     1fc:	60 83       	st	Z, r22
     1fe:	0f 90       	pop	r0
     200:	0f be       	out	0x3f, r0	; 63
     202:	dd 27       	eor	r29, r29
     204:	ce 01       	movw	r24, r28
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	1f 91       	pop	r17
     20c:	0f 91       	pop	r16
     20e:	ff 90       	pop	r15
     210:	ef 90       	pop	r14
     212:	df 90       	pop	r13
     214:	cf 90       	pop	r12
     216:	bf 90       	pop	r11
     218:	af 90       	pop	r10
     21a:	08 95       	ret

0000021c <xEventGroupClearBits>:
     21c:	fc 01       	movw	r30, r24
     21e:	0f b6       	in	r0, 0x3f	; 63
     220:	f8 94       	cli
     222:	0f 92       	push	r0
     224:	80 81       	ld	r24, Z
     226:	91 81       	ldd	r25, Z+1	; 0x01
     228:	60 95       	com	r22
     22a:	70 95       	com	r23
     22c:	68 23       	and	r22, r24
     22e:	79 23       	and	r23, r25
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	0f 90       	pop	r0
     236:	0f be       	out	0x3f, r0	; 63
     238:	08 95       	ret

0000023a <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     23a:	cf 92       	push	r12
     23c:	df 92       	push	r13
     23e:	ef 92       	push	r14
     240:	ff 92       	push	r15
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	cf 93       	push	r28
     248:	df 93       	push	r29
     24a:	7c 01       	movw	r14, r24
     24c:	8b 01       	movw	r16, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     24e:	ec 01       	movw	r28, r24
     250:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     252:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     256:	d7 01       	movw	r26, r14
     258:	17 96       	adiw	r26, 0x07	; 7
     25a:	ed 91       	ld	r30, X+
     25c:	fc 91       	ld	r31, X
     25e:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     260:	8d 91       	ld	r24, X+
     262:	9c 91       	ld	r25, X
     264:	11 97       	sbiw	r26, 0x01	; 1
     266:	08 2b       	or	r16, r24
     268:	19 2b       	or	r17, r25
     26a:	0d 93       	st	X+, r16
     26c:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     272:	2d c0       	rjmp	.+90     	; 0x2ce <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     274:	c2 80       	ldd	r12, Z+2	; 0x02
     276:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     278:	80 81       	ld	r24, Z
     27a:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     27c:	9c 01       	movw	r18, r24
     27e:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     280:	92 fd       	sbrc	r25, 2
     282:	09 c0       	rjmp	.+18     	; 0x296 <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     284:	d7 01       	movw	r26, r14
     286:	4d 91       	ld	r20, X+
     288:	5c 91       	ld	r21, X
     28a:	42 23       	and	r20, r18
     28c:	53 23       	and	r21, r19
     28e:	45 2b       	or	r20, r21
     290:	61 f4       	brne	.+24     	; 0x2aa <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     292:	40 e0       	ldi	r20, 0x00	; 0
     294:	0d c0       	rjmp	.+26     	; 0x2b0 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     296:	d7 01       	movw	r26, r14
     298:	4d 91       	ld	r20, X+
     29a:	5c 91       	ld	r21, X
     29c:	42 23       	and	r20, r18
     29e:	53 23       	and	r21, r19
     2a0:	24 17       	cp	r18, r20
     2a2:	35 07       	cpc	r19, r21
     2a4:	21 f0       	breq	.+8      	; 0x2ae <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     2a6:	40 e0       	ldi	r20, 0x00	; 0
     2a8:	03 c0       	rjmp	.+6      	; 0x2b0 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     2aa:	41 e0       	ldi	r20, 0x01	; 1
     2ac:	01 c0       	rjmp	.+2      	; 0x2b0 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     2ae:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     2b0:	44 23       	and	r20, r20
     2b2:	59 f0       	breq	.+22     	; 0x2ca <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     2b4:	90 ff       	sbrs	r25, 0
     2b6:	02 c0       	rjmp	.+4      	; 0x2bc <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     2b8:	02 2b       	or	r16, r18
     2ba:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     2bc:	d7 01       	movw	r26, r14
     2be:	6d 91       	ld	r22, X+
     2c0:	7c 91       	ld	r23, X
     2c2:	72 60       	ori	r23, 0x02	; 2
     2c4:	cf 01       	movw	r24, r30
     2c6:	0e 94 9b 0a 	call	0x1536	; 0x1536 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     2ca:	ec 2d       	mov	r30, r12
     2cc:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     2ce:	ec 17       	cp	r30, r28
     2d0:	fd 07       	cpc	r31, r29
     2d2:	81 f6       	brne	.-96     	; 0x274 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     2d4:	00 95       	com	r16
     2d6:	10 95       	com	r17
     2d8:	f7 01       	movw	r30, r14
     2da:	80 81       	ld	r24, Z
     2dc:	91 81       	ldd	r25, Z+1	; 0x01
     2de:	08 23       	and	r16, r24
     2e0:	19 23       	and	r17, r25
     2e2:	11 83       	std	Z+1, r17	; 0x01
     2e4:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     2e6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     2ea:	d7 01       	movw	r26, r14
     2ec:	8d 91       	ld	r24, X+
     2ee:	9c 91       	ld	r25, X
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	1f 91       	pop	r17
     2f6:	0f 91       	pop	r16
     2f8:	ff 90       	pop	r15
     2fa:	ef 90       	pop	r14
     2fc:	df 90       	pop	r13
     2fe:	cf 90       	pop	r12
     300:	08 95       	ret

00000302 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     308:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     30c:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <__data_end>
     310:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <__data_end+0x1>
     314:	89 2b       	or	r24, r25
     316:	31 f4       	brne	.+12     	; 0x324 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     318:	8b e4       	ldi	r24, 0x4B	; 75
     31a:	91 e0       	ldi	r25, 0x01	; 1
     31c:	90 93 47 01 	sts	0x0147, r25	; 0x800147 <__data_end+0x1>
     320:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     324:	20 91 48 01 	lds	r18, 0x0148	; 0x800148 <xNextFreeByte>
     328:	30 91 49 01 	lds	r19, 0x0149	; 0x800149 <xNextFreeByte+0x1>
     32c:	c9 01       	movw	r24, r18
     32e:	8c 0f       	add	r24, r28
     330:	9d 1f       	adc	r25, r29
     332:	8d 37       	cpi	r24, 0x7D	; 125
     334:	44 e0       	ldi	r20, 0x04	; 4
     336:	94 07       	cpc	r25, r20
     338:	70 f4       	brcc	.+28     	; 0x356 <pvPortMalloc+0x54>
     33a:	28 17       	cp	r18, r24
     33c:	39 07       	cpc	r19, r25
     33e:	70 f4       	brcc	.+28     	; 0x35c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     340:	c0 91 46 01 	lds	r28, 0x0146	; 0x800146 <__data_end>
     344:	d0 91 47 01 	lds	r29, 0x0147	; 0x800147 <__data_end+0x1>
     348:	c2 0f       	add	r28, r18
     34a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     34c:	90 93 49 01 	sts	0x0149, r25	; 0x800149 <xNextFreeByte+0x1>
     350:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <xNextFreeByte>
     354:	05 c0       	rjmp	.+10     	; 0x360 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     356:	c0 e0       	ldi	r28, 0x00	; 0
     358:	d0 e0       	ldi	r29, 0x00	; 0
     35a:	02 c0       	rjmp	.+4      	; 0x360 <pvPortMalloc+0x5e>
     35c:	c0 e0       	ldi	r28, 0x00	; 0
     35e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     360:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     364:	ce 01       	movw	r24, r28
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     36c:	08 95       	ret

0000036e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     36e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     370:	03 96       	adiw	r24, 0x03	; 3
     372:	92 83       	std	Z+2, r25	; 0x02
     374:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     376:	2f ef       	ldi	r18, 0xFF	; 255
     378:	3f ef       	ldi	r19, 0xFF	; 255
     37a:	34 83       	std	Z+4, r19	; 0x04
     37c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     37e:	96 83       	std	Z+6, r25	; 0x06
     380:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     382:	90 87       	std	Z+8, r25	; 0x08
     384:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     386:	10 82       	st	Z, r1
     388:	08 95       	ret

0000038a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     38a:	fc 01       	movw	r30, r24
     38c:	11 86       	std	Z+9, r1	; 0x09
     38e:	10 86       	std	Z+8, r1	; 0x08
     390:	08 95       	ret

00000392 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	9c 01       	movw	r18, r24
     398:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     39a:	dc 01       	movw	r26, r24
     39c:	11 96       	adiw	r26, 0x01	; 1
     39e:	cd 91       	ld	r28, X+
     3a0:	dc 91       	ld	r29, X
     3a2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3a4:	d3 83       	std	Z+3, r29	; 0x03
     3a6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3a8:	8c 81       	ldd	r24, Y+4	; 0x04
     3aa:	9d 81       	ldd	r25, Y+5	; 0x05
     3ac:	95 83       	std	Z+5, r25	; 0x05
     3ae:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3b0:	8c 81       	ldd	r24, Y+4	; 0x04
     3b2:	9d 81       	ldd	r25, Y+5	; 0x05
     3b4:	dc 01       	movw	r26, r24
     3b6:	13 96       	adiw	r26, 0x03	; 3
     3b8:	7c 93       	st	X, r23
     3ba:	6e 93       	st	-X, r22
     3bc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3be:	7d 83       	std	Y+5, r23	; 0x05
     3c0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3c2:	31 87       	std	Z+9, r19	; 0x09
     3c4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3c6:	f9 01       	movw	r30, r18
     3c8:	80 81       	ld	r24, Z
     3ca:	8f 5f       	subi	r24, 0xFF	; 255
     3cc:	80 83       	st	Z, r24
}
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	08 95       	ret

000003d4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3d4:	cf 93       	push	r28
     3d6:	df 93       	push	r29
     3d8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3da:	48 81       	ld	r20, Y
     3dc:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3de:	4f 3f       	cpi	r20, 0xFF	; 255
     3e0:	2f ef       	ldi	r18, 0xFF	; 255
     3e2:	52 07       	cpc	r21, r18
     3e4:	21 f4       	brne	.+8      	; 0x3ee <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3e6:	fc 01       	movw	r30, r24
     3e8:	a7 81       	ldd	r26, Z+7	; 0x07
     3ea:	b0 85       	ldd	r27, Z+8	; 0x08
     3ec:	0d c0       	rjmp	.+26     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3ee:	dc 01       	movw	r26, r24
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <vListInsert+0x22>
     3f4:	df 01       	movw	r26, r30
     3f6:	12 96       	adiw	r26, 0x02	; 2
     3f8:	ed 91       	ld	r30, X+
     3fa:	fc 91       	ld	r31, X
     3fc:	13 97       	sbiw	r26, 0x03	; 3
     3fe:	20 81       	ld	r18, Z
     400:	31 81       	ldd	r19, Z+1	; 0x01
     402:	42 17       	cp	r20, r18
     404:	53 07       	cpc	r21, r19
     406:	b0 f7       	brcc	.-20     	; 0x3f4 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     408:	12 96       	adiw	r26, 0x02	; 2
     40a:	ed 91       	ld	r30, X+
     40c:	fc 91       	ld	r31, X
     40e:	13 97       	sbiw	r26, 0x03	; 3
     410:	fb 83       	std	Y+3, r31	; 0x03
     412:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     414:	d5 83       	std	Z+5, r29	; 0x05
     416:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     418:	bd 83       	std	Y+5, r27	; 0x05
     41a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     41c:	13 96       	adiw	r26, 0x03	; 3
     41e:	dc 93       	st	X, r29
     420:	ce 93       	st	-X, r28
     422:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     424:	99 87       	std	Y+9, r25	; 0x09
     426:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     428:	fc 01       	movw	r30, r24
     42a:	20 81       	ld	r18, Z
     42c:	2f 5f       	subi	r18, 0xFF	; 255
     42e:	20 83       	st	Z, r18
}
     430:	df 91       	pop	r29
     432:	cf 91       	pop	r28
     434:	08 95       	ret

00000436 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     43c:	a0 85       	ldd	r26, Z+8	; 0x08
     43e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     440:	c2 81       	ldd	r28, Z+2	; 0x02
     442:	d3 81       	ldd	r29, Z+3	; 0x03
     444:	84 81       	ldd	r24, Z+4	; 0x04
     446:	95 81       	ldd	r25, Z+5	; 0x05
     448:	9d 83       	std	Y+5, r25	; 0x05
     44a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     44c:	c4 81       	ldd	r28, Z+4	; 0x04
     44e:	d5 81       	ldd	r29, Z+5	; 0x05
     450:	82 81       	ldd	r24, Z+2	; 0x02
     452:	93 81       	ldd	r25, Z+3	; 0x03
     454:	9b 83       	std	Y+3, r25	; 0x03
     456:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     458:	11 96       	adiw	r26, 0x01	; 1
     45a:	8d 91       	ld	r24, X+
     45c:	9c 91       	ld	r25, X
     45e:	12 97       	sbiw	r26, 0x02	; 2
     460:	e8 17       	cp	r30, r24
     462:	f9 07       	cpc	r31, r25
     464:	31 f4       	brne	.+12     	; 0x472 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     466:	84 81       	ldd	r24, Z+4	; 0x04
     468:	95 81       	ldd	r25, Z+5	; 0x05
     46a:	12 96       	adiw	r26, 0x02	; 2
     46c:	9c 93       	st	X, r25
     46e:	8e 93       	st	-X, r24
     470:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     472:	11 86       	std	Z+9, r1	; 0x09
     474:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     476:	8c 91       	ld	r24, X
     478:	81 50       	subi	r24, 0x01	; 1
     47a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     482:	1b bc       	out	0x2b, r1	; 43
     484:	8c e7       	ldi	r24, 0x7C	; 124
     486:	8a bd       	out	0x2a, r24	; 42
     488:	8b e0       	ldi	r24, 0x0B	; 11
     48a:	8e bd       	out	0x2e, r24	; 46
     48c:	89 b7       	in	r24, 0x39	; 57
     48e:	80 61       	ori	r24, 0x10	; 16
     490:	89 bf       	out	0x39, r24	; 57
     492:	08 95       	ret

00000494 <pxPortInitialiseStack>:
     494:	31 e1       	ldi	r19, 0x11	; 17
     496:	fc 01       	movw	r30, r24
     498:	30 83       	st	Z, r19
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	22 e2       	ldi	r18, 0x22	; 34
     49e:	20 83       	st	Z, r18
     4a0:	31 97       	sbiw	r30, 0x01	; 1
     4a2:	a3 e3       	ldi	r26, 0x33	; 51
     4a4:	a0 83       	st	Z, r26
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	60 83       	st	Z, r22
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	70 83       	st	Z, r23
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	10 82       	st	Z, r1
     4b2:	31 97       	sbiw	r30, 0x01	; 1
     4b4:	60 e8       	ldi	r22, 0x80	; 128
     4b6:	60 83       	st	Z, r22
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	10 82       	st	Z, r1
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	62 e0       	ldi	r22, 0x02	; 2
     4c0:	60 83       	st	Z, r22
     4c2:	31 97       	sbiw	r30, 0x01	; 1
     4c4:	63 e0       	ldi	r22, 0x03	; 3
     4c6:	60 83       	st	Z, r22
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	64 e0       	ldi	r22, 0x04	; 4
     4cc:	60 83       	st	Z, r22
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	65 e0       	ldi	r22, 0x05	; 5
     4d2:	60 83       	st	Z, r22
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	66 e0       	ldi	r22, 0x06	; 6
     4d8:	60 83       	st	Z, r22
     4da:	31 97       	sbiw	r30, 0x01	; 1
     4dc:	67 e0       	ldi	r22, 0x07	; 7
     4de:	60 83       	st	Z, r22
     4e0:	31 97       	sbiw	r30, 0x01	; 1
     4e2:	68 e0       	ldi	r22, 0x08	; 8
     4e4:	60 83       	st	Z, r22
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	69 e0       	ldi	r22, 0x09	; 9
     4ea:	60 83       	st	Z, r22
     4ec:	31 97       	sbiw	r30, 0x01	; 1
     4ee:	60 e1       	ldi	r22, 0x10	; 16
     4f0:	60 83       	st	Z, r22
     4f2:	31 97       	sbiw	r30, 0x01	; 1
     4f4:	30 83       	st	Z, r19
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	32 e1       	ldi	r19, 0x12	; 18
     4fa:	30 83       	st	Z, r19
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	33 e1       	ldi	r19, 0x13	; 19
     500:	30 83       	st	Z, r19
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	34 e1       	ldi	r19, 0x14	; 20
     506:	30 83       	st	Z, r19
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	35 e1       	ldi	r19, 0x15	; 21
     50c:	30 83       	st	Z, r19
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	36 e1       	ldi	r19, 0x16	; 22
     512:	30 83       	st	Z, r19
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	37 e1       	ldi	r19, 0x17	; 23
     518:	30 83       	st	Z, r19
     51a:	31 97       	sbiw	r30, 0x01	; 1
     51c:	38 e1       	ldi	r19, 0x18	; 24
     51e:	30 83       	st	Z, r19
     520:	31 97       	sbiw	r30, 0x01	; 1
     522:	39 e1       	ldi	r19, 0x19	; 25
     524:	30 83       	st	Z, r19
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	30 e2       	ldi	r19, 0x20	; 32
     52a:	30 83       	st	Z, r19
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	31 e2       	ldi	r19, 0x21	; 33
     530:	30 83       	st	Z, r19
     532:	31 97       	sbiw	r30, 0x01	; 1
     534:	20 83       	st	Z, r18
     536:	31 97       	sbiw	r30, 0x01	; 1
     538:	23 e2       	ldi	r18, 0x23	; 35
     53a:	20 83       	st	Z, r18
     53c:	31 97       	sbiw	r30, 0x01	; 1
     53e:	40 83       	st	Z, r20
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	50 83       	st	Z, r21
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	26 e2       	ldi	r18, 0x26	; 38
     548:	20 83       	st	Z, r18
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	27 e2       	ldi	r18, 0x27	; 39
     54e:	20 83       	st	Z, r18
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	28 e2       	ldi	r18, 0x28	; 40
     554:	20 83       	st	Z, r18
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	29 e2       	ldi	r18, 0x29	; 41
     55a:	20 83       	st	Z, r18
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	20 e3       	ldi	r18, 0x30	; 48
     560:	20 83       	st	Z, r18
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	21 e3       	ldi	r18, 0x31	; 49
     566:	20 83       	st	Z, r18
     568:	86 97       	sbiw	r24, 0x26	; 38
     56a:	08 95       	ret

0000056c <xPortStartScheduler>:
     56c:	0e 94 41 02 	call	0x482	; 0x482 <prvSetupTimerInterrupt>
     570:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
     574:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     578:	cd 91       	ld	r28, X+
     57a:	cd bf       	out	0x3d, r28	; 61
     57c:	dd 91       	ld	r29, X+
     57e:	de bf       	out	0x3e, r29	; 62
     580:	ff 91       	pop	r31
     582:	ef 91       	pop	r30
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	bf 91       	pop	r27
     58a:	af 91       	pop	r26
     58c:	9f 91       	pop	r25
     58e:	8f 91       	pop	r24
     590:	7f 91       	pop	r23
     592:	6f 91       	pop	r22
     594:	5f 91       	pop	r21
     596:	4f 91       	pop	r20
     598:	3f 91       	pop	r19
     59a:	2f 91       	pop	r18
     59c:	1f 91       	pop	r17
     59e:	0f 91       	pop	r16
     5a0:	ff 90       	pop	r15
     5a2:	ef 90       	pop	r14
     5a4:	df 90       	pop	r13
     5a6:	cf 90       	pop	r12
     5a8:	bf 90       	pop	r11
     5aa:	af 90       	pop	r10
     5ac:	9f 90       	pop	r9
     5ae:	8f 90       	pop	r8
     5b0:	7f 90       	pop	r7
     5b2:	6f 90       	pop	r6
     5b4:	5f 90       	pop	r5
     5b6:	4f 90       	pop	r4
     5b8:	3f 90       	pop	r3
     5ba:	2f 90       	pop	r2
     5bc:	1f 90       	pop	r1
     5be:	0f 90       	pop	r0
     5c0:	0f be       	out	0x3f, r0	; 63
     5c2:	0f 90       	pop	r0
     5c4:	08 95       	ret
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	08 95       	ret

000005ca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5ca:	0f 92       	push	r0
     5cc:	0f b6       	in	r0, 0x3f	; 63
     5ce:	f8 94       	cli
     5d0:	0f 92       	push	r0
     5d2:	1f 92       	push	r1
     5d4:	11 24       	eor	r1, r1
     5d6:	2f 92       	push	r2
     5d8:	3f 92       	push	r3
     5da:	4f 92       	push	r4
     5dc:	5f 92       	push	r5
     5de:	6f 92       	push	r6
     5e0:	7f 92       	push	r7
     5e2:	8f 92       	push	r8
     5e4:	9f 92       	push	r9
     5e6:	af 92       	push	r10
     5e8:	bf 92       	push	r11
     5ea:	cf 92       	push	r12
     5ec:	df 92       	push	r13
     5ee:	ef 92       	push	r14
     5f0:	ff 92       	push	r15
     5f2:	0f 93       	push	r16
     5f4:	1f 93       	push	r17
     5f6:	2f 93       	push	r18
     5f8:	3f 93       	push	r19
     5fa:	4f 93       	push	r20
     5fc:	5f 93       	push	r21
     5fe:	6f 93       	push	r22
     600:	7f 93       	push	r23
     602:	8f 93       	push	r24
     604:	9f 93       	push	r25
     606:	af 93       	push	r26
     608:	bf 93       	push	r27
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	ef 93       	push	r30
     610:	ff 93       	push	r31
     612:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
     616:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     61a:	0d b6       	in	r0, 0x3d	; 61
     61c:	0d 92       	st	X+, r0
     61e:	0e b6       	in	r0, 0x3e	; 62
     620:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     622:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     626:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
     62a:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     67c:	0f 92       	push	r0
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	0f 92       	push	r0
     684:	1f 92       	push	r1
     686:	11 24       	eor	r1, r1
     688:	2f 92       	push	r2
     68a:	3f 92       	push	r3
     68c:	4f 92       	push	r4
     68e:	5f 92       	push	r5
     690:	6f 92       	push	r6
     692:	7f 92       	push	r7
     694:	8f 92       	push	r8
     696:	9f 92       	push	r9
     698:	af 92       	push	r10
     69a:	bf 92       	push	r11
     69c:	cf 92       	push	r12
     69e:	df 92       	push	r13
     6a0:	ef 92       	push	r14
     6a2:	ff 92       	push	r15
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	2f 93       	push	r18
     6aa:	3f 93       	push	r19
     6ac:	4f 93       	push	r20
     6ae:	5f 93       	push	r21
     6b0:	6f 93       	push	r22
     6b2:	7f 93       	push	r23
     6b4:	8f 93       	push	r24
     6b6:	9f 93       	push	r25
     6b8:	af 93       	push	r26
     6ba:	bf 93       	push	r27
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	ef 93       	push	r30
     6c2:	ff 93       	push	r31
     6c4:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
     6c8:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     6cc:	0d b6       	in	r0, 0x3d	; 61
     6ce:	0d 92       	st	X+, r0
     6d0:	0e b6       	in	r0, 0x3e	; 62
     6d2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6d4:	0e 94 30 08 	call	0x1060	; 0x1060 <xTaskIncrementTick>
     6d8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6da:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6de:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
     6e2:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     6e6:	cd 91       	ld	r28, X+
     6e8:	cd bf       	out	0x3d, r28	; 61
     6ea:	dd 91       	ld	r29, X+
     6ec:	de bf       	out	0x3e, r29	; 62
     6ee:	ff 91       	pop	r31
     6f0:	ef 91       	pop	r30
     6f2:	df 91       	pop	r29
     6f4:	cf 91       	pop	r28
     6f6:	bf 91       	pop	r27
     6f8:	af 91       	pop	r26
     6fa:	9f 91       	pop	r25
     6fc:	8f 91       	pop	r24
     6fe:	7f 91       	pop	r23
     700:	6f 91       	pop	r22
     702:	5f 91       	pop	r21
     704:	4f 91       	pop	r20
     706:	3f 91       	pop	r19
     708:	2f 91       	pop	r18
     70a:	1f 91       	pop	r17
     70c:	0f 91       	pop	r16
     70e:	ff 90       	pop	r15
     710:	ef 90       	pop	r14
     712:	df 90       	pop	r13
     714:	cf 90       	pop	r12
     716:	bf 90       	pop	r11
     718:	af 90       	pop	r10
     71a:	9f 90       	pop	r9
     71c:	8f 90       	pop	r8
     71e:	7f 90       	pop	r7
     720:	6f 90       	pop	r6
     722:	5f 90       	pop	r5
     724:	4f 90       	pop	r4
     726:	3f 90       	pop	r3
     728:	2f 90       	pop	r2
     72a:	1f 90       	pop	r1
     72c:	0f 90       	pop	r0
     72e:	0f be       	out	0x3f, r0	; 63
     730:	0f 90       	pop	r0

	asm volatile ( "ret" );
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     73a:	0f b6       	in	r0, 0x3f	; 63
     73c:	f8 94       	cli
     73e:	0f 92       	push	r0
     740:	fc 01       	movw	r30, r24
     742:	82 8d       	ldd	r24, Z+26	; 0x1a
     744:	81 11       	cpse	r24, r1
     746:	02 c0       	rjmp	.+4      	; 0x74c <prvIsQueueEmpty+0x12>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	01 c0       	rjmp	.+2      	; 0x74e <prvIsQueueEmpty+0x14>
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	0f 90       	pop	r0
     750:	0f be       	out	0x3f, r0	; 63
     752:	08 95       	ret

00000754 <prvIsQueueFull>:
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	f8 94       	cli
     758:	0f 92       	push	r0
     75a:	fc 01       	movw	r30, r24
     75c:	22 8d       	ldd	r18, Z+26	; 0x1a
     75e:	83 8d       	ldd	r24, Z+27	; 0x1b
     760:	28 13       	cpse	r18, r24
     762:	02 c0       	rjmp	.+4      	; 0x768 <prvIsQueueFull+0x14>
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	01 c0       	rjmp	.+2      	; 0x76a <prvIsQueueFull+0x16>
     768:	80 e0       	ldi	r24, 0x00	; 0
     76a:	0f 90       	pop	r0
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	08 95       	ret

00000770 <prvCopyDataToQueue>:
     770:	1f 93       	push	r17
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	ec 01       	movw	r28, r24
     778:	14 2f       	mov	r17, r20
     77a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     77c:	41 11       	cpse	r20, r1
     77e:	0c c0       	rjmp	.+24     	; 0x798 <prvCopyDataToQueue+0x28>
     780:	88 81       	ld	r24, Y
     782:	99 81       	ldd	r25, Y+1	; 0x01
     784:	89 2b       	or	r24, r25
     786:	09 f0       	breq	.+2      	; 0x78a <prvCopyDataToQueue+0x1a>
     788:	45 c0       	rjmp	.+138    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     78a:	8a 81       	ldd	r24, Y+2	; 0x02
     78c:	9b 81       	ldd	r25, Y+3	; 0x03
     78e:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <xTaskPriorityDisinherit>
     792:	1b 82       	std	Y+3, r1	; 0x03
     794:	1a 82       	std	Y+2, r1	; 0x02
     796:	45 c0       	rjmp	.+138    	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     798:	11 11       	cpse	r17, r1
     79a:	17 c0       	rjmp	.+46     	; 0x7ca <prvCopyDataToQueue+0x5a>
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	8c 81       	ldd	r24, Y+4	; 0x04
     7a0:	9d 81       	ldd	r25, Y+5	; 0x05
     7a2:	0e 94 11 16 	call	0x2c22	; 0x2c22 <memcpy>
     7a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7a8:	8c 81       	ldd	r24, Y+4	; 0x04
     7aa:	9d 81       	ldd	r25, Y+5	; 0x05
     7ac:	82 0f       	add	r24, r18
     7ae:	91 1d       	adc	r25, r1
     7b0:	9d 83       	std	Y+5, r25	; 0x05
     7b2:	8c 83       	std	Y+4, r24	; 0x04
     7b4:	2a 81       	ldd	r18, Y+2	; 0x02
     7b6:	3b 81       	ldd	r19, Y+3	; 0x03
     7b8:	82 17       	cp	r24, r18
     7ba:	93 07       	cpc	r25, r19
     7bc:	68 f1       	brcs	.+90     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
     7be:	88 81       	ld	r24, Y
     7c0:	99 81       	ldd	r25, Y+1	; 0x01
     7c2:	9d 83       	std	Y+5, r25	; 0x05
     7c4:	8c 83       	std	Y+4, r24	; 0x04
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	2c c0       	rjmp	.+88     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	8e 81       	ldd	r24, Y+6	; 0x06
     7ce:	9f 81       	ldd	r25, Y+7	; 0x07
     7d0:	0e 94 11 16 	call	0x2c22	; 0x2c22 <memcpy>
     7d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	91 95       	neg	r25
     7da:	81 95       	neg	r24
     7dc:	91 09       	sbc	r25, r1
     7de:	2e 81       	ldd	r18, Y+6	; 0x06
     7e0:	3f 81       	ldd	r19, Y+7	; 0x07
     7e2:	28 0f       	add	r18, r24
     7e4:	39 1f       	adc	r19, r25
     7e6:	3f 83       	std	Y+7, r19	; 0x07
     7e8:	2e 83       	std	Y+6, r18	; 0x06
     7ea:	48 81       	ld	r20, Y
     7ec:	59 81       	ldd	r21, Y+1	; 0x01
     7ee:	24 17       	cp	r18, r20
     7f0:	35 07       	cpc	r19, r21
     7f2:	30 f4       	brcc	.+12     	; 0x800 <__DATA_REGION_LENGTH__>
     7f4:	2a 81       	ldd	r18, Y+2	; 0x02
     7f6:	3b 81       	ldd	r19, Y+3	; 0x03
     7f8:	82 0f       	add	r24, r18
     7fa:	93 1f       	adc	r25, r19
     7fc:	9f 83       	std	Y+7, r25	; 0x07
     7fe:	8e 83       	std	Y+6, r24	; 0x06
     800:	12 30       	cpi	r17, 0x02	; 2
     802:	61 f4       	brne	.+24     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     804:	8a 8d       	ldd	r24, Y+26	; 0x1a
     806:	88 23       	and	r24, r24
     808:	59 f0       	breq	.+22     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     80a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     80c:	81 50       	subi	r24, 0x01	; 1
     80e:	8a 8f       	std	Y+26, r24	; 0x1a
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	07 c0       	rjmp	.+14     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	05 c0       	rjmp	.+10     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	03 c0       	rjmp	.+6      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	01 c0       	rjmp	.+2      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     820:	80 e0       	ldi	r24, 0x00	; 0
     822:	9a 8d       	ldd	r25, Y+26	; 0x1a
     824:	9f 5f       	subi	r25, 0xFF	; 255
     826:	9a 8f       	std	Y+26, r25	; 0x1a
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	1f 91       	pop	r17
     82e:	08 95       	ret

00000830 <prvCopyDataFromQueue>:
     830:	fc 01       	movw	r30, r24
     832:	44 8d       	ldd	r20, Z+28	; 0x1c
     834:	44 23       	and	r20, r20
     836:	a9 f0       	breq	.+42     	; 0x862 <__stack+0x3>
     838:	50 e0       	ldi	r21, 0x00	; 0
     83a:	26 81       	ldd	r18, Z+6	; 0x06
     83c:	37 81       	ldd	r19, Z+7	; 0x07
     83e:	24 0f       	add	r18, r20
     840:	35 1f       	adc	r19, r21
     842:	37 83       	std	Z+7, r19	; 0x07
     844:	26 83       	std	Z+6, r18	; 0x06
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	28 17       	cp	r18, r24
     84c:	39 07       	cpc	r19, r25
     84e:	20 f0       	brcs	.+8      	; 0x858 <prvCopyDataFromQueue+0x28>
     850:	80 81       	ld	r24, Z
     852:	91 81       	ldd	r25, Z+1	; 0x01
     854:	97 83       	std	Z+7, r25	; 0x07
     856:	86 83       	std	Z+6, r24	; 0x06
     858:	cb 01       	movw	r24, r22
     85a:	66 81       	ldd	r22, Z+6	; 0x06
     85c:	77 81       	ldd	r23, Z+7	; 0x07
     85e:	0e 94 11 16 	call	0x2c22	; 0x2c22 <memcpy>
     862:	08 95       	ret

00000864 <prvUnlockQueue>:
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	ec 01       	movw	r28, r24
     86a:	0f b6       	in	r0, 0x3f	; 63
     86c:	f8 94       	cli
     86e:	0f 92       	push	r0
     870:	0d c0       	rjmp	.+26     	; 0x88c <prvUnlockQueue+0x28>
     872:	89 89       	ldd	r24, Y+17	; 0x11
     874:	88 23       	and	r24, r24
     876:	69 f0       	breq	.+26     	; 0x892 <prvUnlockQueue+0x2e>
     878:	ce 01       	movw	r24, r28
     87a:	41 96       	adiw	r24, 0x11	; 17
     87c:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     880:	81 11       	cpse	r24, r1
     882:	0e 94 12 0b 	call	0x1624	; 0x1624 <vTaskMissedYield>
     886:	8e 8d       	ldd	r24, Y+30	; 0x1e
     888:	81 50       	subi	r24, 0x01	; 1
     88a:	8e 8f       	std	Y+30, r24	; 0x1e
     88c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     88e:	18 16       	cp	r1, r24
     890:	84 f3       	brlt	.-32     	; 0x872 <prvUnlockQueue+0xe>
     892:	8f ef       	ldi	r24, 0xFF	; 255
     894:	8e 8f       	std	Y+30, r24	; 0x1e
     896:	0f 90       	pop	r0
     898:	0f be       	out	0x3f, r0	; 63
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	0f 92       	push	r0
     8a0:	0d c0       	rjmp	.+26     	; 0x8bc <prvUnlockQueue+0x58>
     8a2:	88 85       	ldd	r24, Y+8	; 0x08
     8a4:	88 23       	and	r24, r24
     8a6:	69 f0       	breq	.+26     	; 0x8c2 <prvUnlockQueue+0x5e>
     8a8:	ce 01       	movw	r24, r28
     8aa:	08 96       	adiw	r24, 0x08	; 8
     8ac:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     8b0:	81 11       	cpse	r24, r1
     8b2:	0e 94 12 0b 	call	0x1624	; 0x1624 <vTaskMissedYield>
     8b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8b8:	81 50       	subi	r24, 0x01	; 1
     8ba:	8d 8f       	std	Y+29, r24	; 0x1d
     8bc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8be:	18 16       	cp	r1, r24
     8c0:	84 f3       	brlt	.-32     	; 0x8a2 <prvUnlockQueue+0x3e>
     8c2:	8f ef       	ldi	r24, 0xFF	; 255
     8c4:	8d 8f       	std	Y+29, r24	; 0x1d
     8c6:	0f 90       	pop	r0
     8c8:	0f be       	out	0x3f, r0	; 63
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <xQueueGenericReset>:
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	ec 01       	movw	r28, r24
     8d6:	0f b6       	in	r0, 0x3f	; 63
     8d8:	f8 94       	cli
     8da:	0f 92       	push	r0
     8dc:	e8 81       	ld	r30, Y
     8de:	f9 81       	ldd	r31, Y+1	; 0x01
     8e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	82 9f       	mul	r24, r18
     8ea:	a0 01       	movw	r20, r0
     8ec:	83 9f       	mul	r24, r19
     8ee:	50 0d       	add	r21, r0
     8f0:	92 9f       	mul	r25, r18
     8f2:	50 0d       	add	r21, r0
     8f4:	11 24       	eor	r1, r1
     8f6:	4e 0f       	add	r20, r30
     8f8:	5f 1f       	adc	r21, r31
     8fa:	5b 83       	std	Y+3, r21	; 0x03
     8fc:	4a 83       	std	Y+2, r20	; 0x02
     8fe:	1a 8e       	std	Y+26, r1	; 0x1a
     900:	fd 83       	std	Y+5, r31	; 0x05
     902:	ec 83       	std	Y+4, r30	; 0x04
     904:	01 97       	sbiw	r24, 0x01	; 1
     906:	28 9f       	mul	r18, r24
     908:	a0 01       	movw	r20, r0
     90a:	29 9f       	mul	r18, r25
     90c:	50 0d       	add	r21, r0
     90e:	38 9f       	mul	r19, r24
     910:	50 0d       	add	r21, r0
     912:	11 24       	eor	r1, r1
     914:	cf 01       	movw	r24, r30
     916:	84 0f       	add	r24, r20
     918:	95 1f       	adc	r25, r21
     91a:	9f 83       	std	Y+7, r25	; 0x07
     91c:	8e 83       	std	Y+6, r24	; 0x06
     91e:	8f ef       	ldi	r24, 0xFF	; 255
     920:	8d 8f       	std	Y+29, r24	; 0x1d
     922:	8e 8f       	std	Y+30, r24	; 0x1e
     924:	61 11       	cpse	r22, r1
     926:	0c c0       	rjmp	.+24     	; 0x940 <xQueueGenericReset+0x70>
     928:	88 85       	ldd	r24, Y+8	; 0x08
     92a:	88 23       	and	r24, r24
     92c:	89 f0       	breq	.+34     	; 0x950 <xQueueGenericReset+0x80>
     92e:	ce 01       	movw	r24, r28
     930:	08 96       	adiw	r24, 0x08	; 8
     932:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     936:	81 30       	cpi	r24, 0x01	; 1
     938:	59 f4       	brne	.+22     	; 0x950 <xQueueGenericReset+0x80>
     93a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     93e:	08 c0       	rjmp	.+16     	; 0x950 <xQueueGenericReset+0x80>
     940:	ce 01       	movw	r24, r28
     942:	08 96       	adiw	r24, 0x08	; 8
     944:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     948:	ce 01       	movw	r24, r28
     94a:	41 96       	adiw	r24, 0x11	; 17
     94c:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     950:	0f 90       	pop	r0
     952:	0f be       	out	0x3f, r0	; 63
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	08 95       	ret

0000095c <xQueueGenericCreate>:
     95c:	0f 93       	push	r16
     95e:	1f 93       	push	r17
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	88 23       	and	r24, r24
     966:	01 f1       	breq	.+64     	; 0x9a8 <xQueueGenericCreate+0x4c>
     968:	06 2f       	mov	r16, r22
     96a:	18 2f       	mov	r17, r24
     96c:	8f e1       	ldi	r24, 0x1F	; 31
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     974:	ec 01       	movw	r28, r24
     976:	89 2b       	or	r24, r25
     978:	c9 f0       	breq	.+50     	; 0x9ac <xQueueGenericCreate+0x50>
     97a:	10 9f       	mul	r17, r16
     97c:	c0 01       	movw	r24, r0
     97e:	11 24       	eor	r1, r1
     980:	01 96       	adiw	r24, 0x01	; 1
     982:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     986:	99 83       	std	Y+1, r25	; 0x01
     988:	88 83       	st	Y, r24
     98a:	89 2b       	or	r24, r25
     98c:	39 f0       	breq	.+14     	; 0x99c <xQueueGenericCreate+0x40>
     98e:	1b 8f       	std	Y+27, r17	; 0x1b
     990:	0c 8f       	std	Y+28, r16	; 0x1c
     992:	61 e0       	ldi	r22, 0x01	; 1
     994:	ce 01       	movw	r24, r28
     996:	0e 94 68 04 	call	0x8d0	; 0x8d0 <xQueueGenericReset>
     99a:	08 c0       	rjmp	.+16     	; 0x9ac <xQueueGenericCreate+0x50>
     99c:	ce 01       	movw	r24, r28
     99e:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     9a2:	c0 e0       	ldi	r28, 0x00	; 0
     9a4:	d0 e0       	ldi	r29, 0x00	; 0
     9a6:	02 c0       	rjmp	.+4      	; 0x9ac <xQueueGenericCreate+0x50>
     9a8:	c0 e0       	ldi	r28, 0x00	; 0
     9aa:	d0 e0       	ldi	r29, 0x00	; 0
     9ac:	ce 01       	movw	r24, r28
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	1f 91       	pop	r17
     9b4:	0f 91       	pop	r16
     9b6:	08 95       	ret

000009b8 <xQueueGenericSend>:
     9b8:	cf 92       	push	r12
     9ba:	df 92       	push	r13
     9bc:	ef 92       	push	r14
     9be:	ff 92       	push	r15
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	00 d0       	rcall	.+0      	; 0x9ca <xQueueGenericSend+0x12>
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <xQueueGenericSend+0x14>
     9cc:	1f 92       	push	r1
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
     9d2:	8c 01       	movw	r16, r24
     9d4:	7b 01       	movw	r14, r22
     9d6:	5d 83       	std	Y+5, r21	; 0x05
     9d8:	4c 83       	std	Y+4, r20	; 0x04
     9da:	c2 2e       	mov	r12, r18
     9dc:	d1 2c       	mov	r13, r1
     9de:	0f b6       	in	r0, 0x3f	; 63
     9e0:	f8 94       	cli
     9e2:	0f 92       	push	r0
     9e4:	f8 01       	movw	r30, r16
     9e6:	92 8d       	ldd	r25, Z+26	; 0x1a
     9e8:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ea:	98 17       	cp	r25, r24
     9ec:	18 f0       	brcs	.+6      	; 0x9f4 <xQueueGenericSend+0x3c>
     9ee:	f2 e0       	ldi	r31, 0x02	; 2
     9f0:	cf 12       	cpse	r12, r31
     9f2:	19 c0       	rjmp	.+50     	; 0xa26 <xQueueGenericSend+0x6e>
     9f4:	4c 2d       	mov	r20, r12
     9f6:	b7 01       	movw	r22, r14
     9f8:	c8 01       	movw	r24, r16
     9fa:	0e 94 b8 03 	call	0x770	; 0x770 <prvCopyDataToQueue>
     9fe:	f8 01       	movw	r30, r16
     a00:	91 89       	ldd	r25, Z+17	; 0x11
     a02:	99 23       	and	r25, r25
     a04:	49 f0       	breq	.+18     	; 0xa18 <xQueueGenericSend+0x60>
     a06:	c8 01       	movw	r24, r16
     a08:	41 96       	adiw	r24, 0x11	; 17
     a0a:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     a0e:	81 30       	cpi	r24, 0x01	; 1
     a10:	31 f4       	brne	.+12     	; 0xa1e <xQueueGenericSend+0x66>
     a12:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     a16:	03 c0       	rjmp	.+6      	; 0xa1e <xQueueGenericSend+0x66>
     a18:	81 11       	cpse	r24, r1
     a1a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     a1e:	0f 90       	pop	r0
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	4d c0       	rjmp	.+154    	; 0xac0 <xQueueGenericSend+0x108>
     a26:	8c 81       	ldd	r24, Y+4	; 0x04
     a28:	9d 81       	ldd	r25, Y+5	; 0x05
     a2a:	89 2b       	or	r24, r25
     a2c:	21 f4       	brne	.+8      	; 0xa36 <xQueueGenericSend+0x7e>
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	45 c0       	rjmp	.+138    	; 0xac0 <xQueueGenericSend+0x108>
     a36:	d1 10       	cpse	r13, r1
     a38:	06 c0       	rjmp	.+12     	; 0xa46 <xQueueGenericSend+0x8e>
     a3a:	ce 01       	movw	r24, r28
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
     a42:	dd 24       	eor	r13, r13
     a44:	d3 94       	inc	r13
     a46:	0f 90       	pop	r0
     a48:	0f be       	out	0x3f, r0	; 63
     a4a:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
     a4e:	0f b6       	in	r0, 0x3f	; 63
     a50:	f8 94       	cli
     a52:	0f 92       	push	r0
     a54:	f8 01       	movw	r30, r16
     a56:	85 8d       	ldd	r24, Z+29	; 0x1d
     a58:	8f 3f       	cpi	r24, 0xFF	; 255
     a5a:	09 f4       	brne	.+2      	; 0xa5e <xQueueGenericSend+0xa6>
     a5c:	15 8e       	std	Z+29, r1	; 0x1d
     a5e:	f8 01       	movw	r30, r16
     a60:	86 8d       	ldd	r24, Z+30	; 0x1e
     a62:	8f 3f       	cpi	r24, 0xFF	; 255
     a64:	09 f4       	brne	.+2      	; 0xa68 <xQueueGenericSend+0xb0>
     a66:	16 8e       	std	Z+30, r1	; 0x1e
     a68:	0f 90       	pop	r0
     a6a:	0f be       	out	0x3f, r0	; 63
     a6c:	be 01       	movw	r22, r28
     a6e:	6c 5f       	subi	r22, 0xFC	; 252
     a70:	7f 4f       	sbci	r23, 0xFF	; 255
     a72:	ce 01       	movw	r24, r28
     a74:	01 96       	adiw	r24, 0x01	; 1
     a76:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskCheckForTimeOut>
     a7a:	81 11       	cpse	r24, r1
     a7c:	1b c0       	rjmp	.+54     	; 0xab4 <xQueueGenericSend+0xfc>
     a7e:	c8 01       	movw	r24, r16
     a80:	0e 94 aa 03 	call	0x754	; 0x754 <prvIsQueueFull>
     a84:	88 23       	and	r24, r24
     a86:	81 f0       	breq	.+32     	; 0xaa8 <xQueueGenericSend+0xf0>
     a88:	6c 81       	ldd	r22, Y+4	; 0x04
     a8a:	7d 81       	ldd	r23, Y+5	; 0x05
     a8c:	c8 01       	movw	r24, r16
     a8e:	08 96       	adiw	r24, 0x08	; 8
     a90:	0e 94 12 0a 	call	0x1424	; 0x1424 <vTaskPlaceOnEventList>
     a94:	c8 01       	movw	r24, r16
     a96:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     a9a:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     a9e:	81 11       	cpse	r24, r1
     aa0:	9e cf       	rjmp	.-196    	; 0x9de <xQueueGenericSend+0x26>
     aa2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     aa6:	9b cf       	rjmp	.-202    	; 0x9de <xQueueGenericSend+0x26>
     aa8:	c8 01       	movw	r24, r16
     aaa:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     aae:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     ab2:	95 cf       	rjmp	.-214    	; 0x9de <xQueueGenericSend+0x26>
     ab4:	c8 01       	movw	r24, r16
     ab6:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     aba:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     abe:	80 e0       	ldi	r24, 0x00	; 0
     ac0:	0f 90       	pop	r0
     ac2:	0f 90       	pop	r0
     ac4:	0f 90       	pop	r0
     ac6:	0f 90       	pop	r0
     ac8:	0f 90       	pop	r0
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	ff 90       	pop	r15
     ad4:	ef 90       	pop	r14
     ad6:	df 90       	pop	r13
     ad8:	cf 90       	pop	r12
     ada:	08 95       	ret

00000adc <xQueueCreateMutex>:
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29
     ae0:	8f e1       	ldi	r24, 0x1F	; 31
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     ae8:	ec 01       	movw	r28, r24
     aea:	89 2b       	or	r24, r25
     aec:	f9 f0       	breq	.+62     	; 0xb2c <xQueueCreateMutex+0x50>
     aee:	1b 82       	std	Y+3, r1	; 0x03
     af0:	1a 82       	std	Y+2, r1	; 0x02
     af2:	19 82       	std	Y+1, r1	; 0x01
     af4:	18 82       	st	Y, r1
     af6:	1d 82       	std	Y+5, r1	; 0x05
     af8:	1c 82       	std	Y+4, r1	; 0x04
     afa:	1f 82       	std	Y+7, r1	; 0x07
     afc:	1e 82       	std	Y+6, r1	; 0x06
     afe:	1a 8e       	std	Y+26, r1	; 0x1a
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	8b 8f       	std	Y+27, r24	; 0x1b
     b04:	1c 8e       	std	Y+28, r1	; 0x1c
     b06:	8f ef       	ldi	r24, 0xFF	; 255
     b08:	8d 8f       	std	Y+29, r24	; 0x1d
     b0a:	8e 8f       	std	Y+30, r24	; 0x1e
     b0c:	ce 01       	movw	r24, r28
     b0e:	08 96       	adiw	r24, 0x08	; 8
     b10:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     b14:	ce 01       	movw	r24, r28
     b16:	41 96       	adiw	r24, 0x11	; 17
     b18:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     b1c:	20 e0       	ldi	r18, 0x00	; 0
     b1e:	40 e0       	ldi	r20, 0x00	; 0
     b20:	50 e0       	ldi	r21, 0x00	; 0
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	70 e0       	ldi	r23, 0x00	; 0
     b26:	ce 01       	movw	r24, r28
     b28:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
     b2c:	ce 01       	movw	r24, r28
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	08 95       	ret

00000b34 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     b34:	af 92       	push	r10
     b36:	bf 92       	push	r11
     b38:	cf 92       	push	r12
     b3a:	df 92       	push	r13
     b3c:	ef 92       	push	r14
     b3e:	ff 92       	push	r15
     b40:	0f 93       	push	r16
     b42:	1f 93       	push	r17
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <xQueueGenericReceive+0x16>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <xQueueGenericReceive+0x18>
     b4c:	1f 92       	push	r1
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
     b52:	8c 01       	movw	r16, r24
     b54:	6b 01       	movw	r12, r22
     b56:	5d 83       	std	Y+5, r21	; 0x05
     b58:	4c 83       	std	Y+4, r20	; 0x04
     b5a:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     b5c:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     b64:	f8 01       	movw	r30, r16
     b66:	82 8d       	ldd	r24, Z+26	; 0x1a
     b68:	88 23       	and	r24, r24
     b6a:	99 f1       	breq	.+102    	; 0xbd2 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     b6c:	a6 80       	ldd	r10, Z+6	; 0x06
     b6e:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     b70:	b6 01       	movw	r22, r12
     b72:	c8 01       	movw	r24, r16
     b74:	0e 94 18 04 	call	0x830	; 0x830 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     b78:	e1 10       	cpse	r14, r1
     b7a:	1a c0       	rjmp	.+52     	; 0xbb0 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     b7c:	f8 01       	movw	r30, r16
     b7e:	82 8d       	ldd	r24, Z+26	; 0x1a
     b80:	81 50       	subi	r24, 0x01	; 1
     b82:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b84:	80 81       	ld	r24, Z
     b86:	91 81       	ldd	r25, Z+1	; 0x01
     b88:	89 2b       	or	r24, r25
     b8a:	29 f4       	brne	.+10     	; 0xb96 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     b8c:	0e 94 cf 0b 	call	0x179e	; 0x179e <pvTaskIncrementMutexHeldCount>
     b90:	f8 01       	movw	r30, r16
     b92:	93 83       	std	Z+3, r25	; 0x03
     b94:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b96:	f8 01       	movw	r30, r16
     b98:	80 85       	ldd	r24, Z+8	; 0x08
     b9a:	88 23       	and	r24, r24
     b9c:	b1 f0       	breq	.+44     	; 0xbca <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     b9e:	c8 01       	movw	r24, r16
     ba0:	08 96       	adiw	r24, 0x08	; 8
     ba2:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     ba6:	81 30       	cpi	r24, 0x01	; 1
     ba8:	81 f4       	brne	.+32     	; 0xbca <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     baa:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     bae:	0d c0       	rjmp	.+26     	; 0xbca <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     bb0:	f8 01       	movw	r30, r16
     bb2:	b7 82       	std	Z+7, r11	; 0x07
     bb4:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bb6:	81 89       	ldd	r24, Z+17	; 0x11
     bb8:	88 23       	and	r24, r24
     bba:	39 f0       	breq	.+14     	; 0xbca <xQueueGenericReceive+0x96>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bbc:	c8 01       	movw	r24, r16
     bbe:	41 96       	adiw	r24, 0x11	; 17
     bc0:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     bc4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     bc6:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	5b c0       	rjmp	.+182    	; 0xc88 <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     bd2:	8c 81       	ldd	r24, Y+4	; 0x04
     bd4:	9d 81       	ldd	r25, Y+5	; 0x05
     bd6:	89 2b       	or	r24, r25
     bd8:	21 f4       	brne	.+8      	; 0xbe2 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     bda:	0f 90       	pop	r0
     bdc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	53 c0       	rjmp	.+166    	; 0xc88 <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
     be2:	f1 10       	cpse	r15, r1
     be4:	06 c0       	rjmp	.+12     	; 0xbf2 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     bee:	ff 24       	eor	r15, r15
     bf0:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     bf2:	0f 90       	pop	r0
     bf4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     bf6:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	0f 92       	push	r0
     c00:	f8 01       	movw	r30, r16
     c02:	85 8d       	ldd	r24, Z+29	; 0x1d
     c04:	8f 3f       	cpi	r24, 0xFF	; 255
     c06:	09 f4       	brne	.+2      	; 0xc0a <xQueueGenericReceive+0xd6>
     c08:	15 8e       	std	Z+29, r1	; 0x1d
     c0a:	f8 01       	movw	r30, r16
     c0c:	86 8d       	ldd	r24, Z+30	; 0x1e
     c0e:	8f 3f       	cpi	r24, 0xFF	; 255
     c10:	09 f4       	brne	.+2      	; 0xc14 <xQueueGenericReceive+0xe0>
     c12:	16 8e       	std	Z+30, r1	; 0x1e
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c18:	be 01       	movw	r22, r28
     c1a:	6c 5f       	subi	r22, 0xFC	; 252
     c1c:	7f 4f       	sbci	r23, 0xFF	; 255
     c1e:	ce 01       	movw	r24, r28
     c20:	01 96       	adiw	r24, 0x01	; 1
     c22:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskCheckForTimeOut>
     c26:	81 11       	cpse	r24, r1
     c28:	29 c0       	rjmp	.+82     	; 0xc7c <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 9d 03 	call	0x73a	; 0x73a <prvIsQueueEmpty>
     c30:	88 23       	and	r24, r24
     c32:	f1 f0       	breq	.+60     	; 0xc70 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c34:	f8 01       	movw	r30, r16
     c36:	80 81       	ld	r24, Z
     c38:	91 81       	ldd	r25, Z+1	; 0x01
     c3a:	89 2b       	or	r24, r25
     c3c:	49 f4       	brne	.+18     	; 0xc50 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     c3e:	0f b6       	in	r0, 0x3f	; 63
     c40:	f8 94       	cli
     c42:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     c44:	82 81       	ldd	r24, Z+2	; 0x02
     c46:	93 81       	ldd	r25, Z+3	; 0x03
     c48:	0e 94 16 0b 	call	0x162c	; 0x162c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     c4c:	0f 90       	pop	r0
     c4e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c50:	6c 81       	ldd	r22, Y+4	; 0x04
     c52:	7d 81       	ldd	r23, Y+5	; 0x05
     c54:	c8 01       	movw	r24, r16
     c56:	41 96       	adiw	r24, 0x11	; 17
     c58:	0e 94 12 0a 	call	0x1424	; 0x1424 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     c5c:	c8 01       	movw	r24, r16
     c5e:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     c62:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     c66:	81 11       	cpse	r24, r1
     c68:	7a cf       	rjmp	.-268    	; 0xb5e <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     c6a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     c6e:	77 cf       	rjmp	.-274    	; 0xb5e <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c70:	c8 01       	movw	r24, r16
     c72:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c76:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     c7a:	71 cf       	rjmp	.-286    	; 0xb5e <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c82:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     c86:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     c88:	0f 90       	pop	r0
     c8a:	0f 90       	pop	r0
     c8c:	0f 90       	pop	r0
     c8e:	0f 90       	pop	r0
     c90:	0f 90       	pop	r0
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	ff 90       	pop	r15
     c9c:	ef 90       	pop	r14
     c9e:	df 90       	pop	r13
     ca0:	cf 90       	pop	r12
     ca2:	bf 90       	pop	r11
     ca4:	af 90       	pop	r10
     ca6:	08 95       	ret

00000ca8 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
     ca8:	e0 91 e7 05 	lds	r30, 0x05E7	; 0x8005e7 <pxDelayedTaskList>
     cac:	f0 91 e8 05 	lds	r31, 0x05E8	; 0x8005e8 <pxDelayedTaskList+0x1>
     cb0:	80 81       	ld	r24, Z
     cb2:	81 11       	cpse	r24, r1
     cb4:	07 c0       	rjmp	.+14     	; 0xcc4 <prvResetNextTaskUnblockTime+0x1c>
     cb6:	8f ef       	ldi	r24, 0xFF	; 255
     cb8:	9f ef       	ldi	r25, 0xFF	; 255
     cba:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     cbe:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     cc2:	08 95       	ret
     cc4:	e0 91 e7 05 	lds	r30, 0x05E7	; 0x8005e7 <pxDelayedTaskList>
     cc8:	f0 91 e8 05 	lds	r31, 0x05E8	; 0x8005e8 <pxDelayedTaskList+0x1>
     ccc:	05 80       	ldd	r0, Z+5	; 0x05
     cce:	f6 81       	ldd	r31, Z+6	; 0x06
     cd0:	e0 2d       	mov	r30, r0
     cd2:	06 80       	ldd	r0, Z+6	; 0x06
     cd4:	f7 81       	ldd	r31, Z+7	; 0x07
     cd6:	e0 2d       	mov	r30, r0
     cd8:	82 81       	ldd	r24, Z+2	; 0x02
     cda:	93 81       	ldd	r25, Z+3	; 0x03
     cdc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     ce0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     ce4:	08 95       	ret

00000ce6 <prvAllocateTCBAndStack>:
     ce6:	ef 92       	push	r14
     ce8:	ff 92       	push	r15
     cea:	0f 93       	push	r16
     cec:	1f 93       	push	r17
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	7c 01       	movw	r14, r24
     cf4:	eb 01       	movw	r28, r22
     cf6:	84 e3       	ldi	r24, 0x34	; 52
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     cfe:	8c 01       	movw	r16, r24
     d00:	89 2b       	or	r24, r25
     d02:	89 f0       	breq	.+34     	; 0xd26 <prvAllocateTCBAndStack+0x40>
     d04:	20 97       	sbiw	r28, 0x00	; 0
     d06:	21 f4       	brne	.+8      	; 0xd10 <prvAllocateTCBAndStack+0x2a>
     d08:	c7 01       	movw	r24, r14
     d0a:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     d0e:	01 c0       	rjmp	.+2      	; 0xd12 <prvAllocateTCBAndStack+0x2c>
     d10:	ce 01       	movw	r24, r28
     d12:	f8 01       	movw	r30, r16
     d14:	90 8f       	std	Z+24, r25	; 0x18
     d16:	87 8b       	std	Z+23, r24	; 0x17
     d18:	89 2b       	or	r24, r25
     d1a:	29 f4       	brne	.+10     	; 0xd26 <prvAllocateTCBAndStack+0x40>
     d1c:	c8 01       	movw	r24, r16
     d1e:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d22:	00 e0       	ldi	r16, 0x00	; 0
     d24:	10 e0       	ldi	r17, 0x00	; 0
     d26:	c8 01       	movw	r24, r16
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	08 95       	ret

00000d36 <prvDeleteTCB>:
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	ec 01       	movw	r28, r24
     d3c:	8f 89       	ldd	r24, Y+23	; 0x17
     d3e:	98 8d       	ldd	r25, Y+24	; 0x18
     d40:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d44:	ce 01       	movw	r24, r28
     d46:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d4a:	df 91       	pop	r29
     d4c:	cf 91       	pop	r28
     d4e:	08 95       	ret

00000d50 <prvInitialiseTCBVariables>:
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	ec 01       	movw	r28, r24
     d58:	14 2f       	mov	r17, r20
     d5a:	20 e0       	ldi	r18, 0x00	; 0
     d5c:	0f c0       	rjmp	.+30     	; 0xd7c <prvInitialiseTCBVariables+0x2c>
     d5e:	82 2f       	mov	r24, r18
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	fb 01       	movw	r30, r22
     d64:	e8 0f       	add	r30, r24
     d66:	f9 1f       	adc	r31, r25
     d68:	30 81       	ld	r19, Z
     d6a:	de 01       	movw	r26, r28
     d6c:	a8 0f       	add	r26, r24
     d6e:	b9 1f       	adc	r27, r25
     d70:	59 96       	adiw	r26, 0x19	; 25
     d72:	3c 93       	st	X, r19
     d74:	80 81       	ld	r24, Z
     d76:	88 23       	and	r24, r24
     d78:	19 f0       	breq	.+6      	; 0xd80 <prvInitialiseTCBVariables+0x30>
     d7a:	2f 5f       	subi	r18, 0xFF	; 255
     d7c:	29 31       	cpi	r18, 0x19	; 25
     d7e:	78 f3       	brcs	.-34     	; 0xd5e <prvInitialiseTCBVariables+0xe>
     d80:	19 aa       	std	Y+49, r1	; 0x31
     d82:	16 30       	cpi	r17, 0x06	; 6
     d84:	08 f0       	brcs	.+2      	; 0xd88 <prvInitialiseTCBVariables+0x38>
     d86:	15 e0       	ldi	r17, 0x05	; 5
     d88:	1e 8b       	std	Y+22, r17	; 0x16
     d8a:	1a ab       	std	Y+50, r17	; 0x32
     d8c:	1b aa       	std	Y+51, r1	; 0x33
     d8e:	ce 01       	movw	r24, r28
     d90:	02 96       	adiw	r24, 0x02	; 2
     d92:	0e 94 c5 01 	call	0x38a	; 0x38a <vListInitialiseItem>
     d96:	ce 01       	movw	r24, r28
     d98:	0c 96       	adiw	r24, 0x0c	; 12
     d9a:	0e 94 c5 01 	call	0x38a	; 0x38a <vListInitialiseItem>
     d9e:	d9 87       	std	Y+9, r29	; 0x09
     da0:	c8 87       	std	Y+8, r28	; 0x08
     da2:	86 e0       	ldi	r24, 0x06	; 6
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	81 1b       	sub	r24, r17
     da8:	91 09       	sbc	r25, r1
     daa:	9d 87       	std	Y+13, r25	; 0x0d
     dac:	8c 87       	std	Y+12, r24	; 0x0c
     dae:	db 8b       	std	Y+19, r29	; 0x13
     db0:	ca 8b       	std	Y+18, r28	; 0x12
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	08 95       	ret

00000dba <prvInitialiseTaskLists>:
     dba:	cf 93       	push	r28
     dbc:	c0 e0       	ldi	r28, 0x00	; 0
     dbe:	10 c0       	rjmp	.+32     	; 0xde0 <prvInitialiseTaskLists+0x26>
     dc0:	8c 2f       	mov	r24, r28
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	9c 01       	movw	r18, r24
     dc6:	22 0f       	add	r18, r18
     dc8:	33 1f       	adc	r19, r19
     dca:	22 0f       	add	r18, r18
     dcc:	33 1f       	adc	r19, r19
     dce:	22 0f       	add	r18, r18
     dd0:	33 1f       	adc	r19, r19
     dd2:	82 0f       	add	r24, r18
     dd4:	93 1f       	adc	r25, r19
     dd6:	85 50       	subi	r24, 0x05	; 5
     dd8:	9a 4f       	sbci	r25, 0xFA	; 250
     dda:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dde:	cf 5f       	subi	r28, 0xFF	; 255
     de0:	c6 30       	cpi	r28, 0x06	; 6
     de2:	70 f3       	brcs	.-36     	; 0xdc0 <prvInitialiseTaskLists+0x6>
     de4:	82 ef       	ldi	r24, 0xF2	; 242
     de6:	95 e0       	ldi	r25, 0x05	; 5
     de8:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dec:	89 ee       	ldi	r24, 0xE9	; 233
     dee:	95 e0       	ldi	r25, 0x05	; 5
     df0:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     df4:	8c ed       	ldi	r24, 0xDC	; 220
     df6:	95 e0       	ldi	r25, 0x05	; 5
     df8:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dfc:	83 ed       	ldi	r24, 0xD3	; 211
     dfe:	95 e0       	ldi	r25, 0x05	; 5
     e00:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     e04:	82 ef       	ldi	r24, 0xF2	; 242
     e06:	95 e0       	ldi	r25, 0x05	; 5
     e08:	90 93 e8 05 	sts	0x05E8, r25	; 0x8005e8 <pxDelayedTaskList+0x1>
     e0c:	80 93 e7 05 	sts	0x05E7, r24	; 0x8005e7 <pxDelayedTaskList>
     e10:	89 ee       	ldi	r24, 0xE9	; 233
     e12:	95 e0       	ldi	r25, 0x05	; 5
     e14:	90 93 e6 05 	sts	0x05E6, r25	; 0x8005e6 <pxOverflowDelayedTaskList+0x1>
     e18:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <pxOverflowDelayedTaskList>
     e1c:	cf 91       	pop	r28
     e1e:	08 95       	ret

00000e20 <prvAddCurrentTaskToDelayedList>:
     e20:	cf 93       	push	r28
     e22:	df 93       	push	r29
     e24:	ec 01       	movw	r28, r24
     e26:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
     e2a:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     e2e:	93 83       	std	Z+3, r25	; 0x03
     e30:	82 83       	std	Z+2, r24	; 0x02
     e32:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <xTickCount>
     e36:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <xTickCount+0x1>
     e3a:	c8 17       	cp	r28, r24
     e3c:	d9 07       	cpc	r29, r25
     e3e:	68 f4       	brcc	.+26     	; 0xe5a <prvAddCurrentTaskToDelayedList+0x3a>
     e40:	60 91 31 06 	lds	r22, 0x0631	; 0x800631 <pxCurrentTCB>
     e44:	70 91 32 06 	lds	r23, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     e48:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <pxOverflowDelayedTaskList>
     e4c:	90 91 e6 05 	lds	r25, 0x05E6	; 0x8005e6 <pxOverflowDelayedTaskList+0x1>
     e50:	6e 5f       	subi	r22, 0xFE	; 254
     e52:	7f 4f       	sbci	r23, 0xFF	; 255
     e54:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
     e58:	17 c0       	rjmp	.+46     	; 0xe88 <prvAddCurrentTaskToDelayedList+0x68>
     e5a:	60 91 31 06 	lds	r22, 0x0631	; 0x800631 <pxCurrentTCB>
     e5e:	70 91 32 06 	lds	r23, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     e62:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <pxDelayedTaskList>
     e66:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <pxDelayedTaskList+0x1>
     e6a:	6e 5f       	subi	r22, 0xFE	; 254
     e6c:	7f 4f       	sbci	r23, 0xFF	; 255
     e6e:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
     e72:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     e76:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     e7a:	c8 17       	cp	r28, r24
     e7c:	d9 07       	cpc	r29, r25
     e7e:	20 f4       	brcc	.+8      	; 0xe88 <prvAddCurrentTaskToDelayedList+0x68>
     e80:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     e84:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	08 95       	ret

00000e8e <xTaskGenericCreate>:
     e8e:	2f 92       	push	r2
     e90:	3f 92       	push	r3
     e92:	4f 92       	push	r4
     e94:	5f 92       	push	r5
     e96:	7f 92       	push	r7
     e98:	8f 92       	push	r8
     e9a:	9f 92       	push	r9
     e9c:	af 92       	push	r10
     e9e:	bf 92       	push	r11
     ea0:	cf 92       	push	r12
     ea2:	df 92       	push	r13
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <xTaskGenericCreate+0x24>
     eb2:	00 d0       	rcall	.+0      	; 0xeb4 <xTaskGenericCreate+0x26>
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	9a 83       	std	Y+2, r25	; 0x02
     eba:	89 83       	std	Y+1, r24	; 0x01
     ebc:	4b 01       	movw	r8, r22
     ebe:	5c 83       	std	Y+4, r21	; 0x04
     ec0:	4b 83       	std	Y+3, r20	; 0x03
     ec2:	19 01       	movw	r2, r18
     ec4:	70 2e       	mov	r7, r16
     ec6:	b6 01       	movw	r22, r12
     ec8:	25 01       	movw	r4, r10
     eca:	ca 01       	movw	r24, r20
     ecc:	0e 94 73 06 	call	0xce6	; 0xce6 <prvAllocateTCBAndStack>
     ed0:	5c 01       	movw	r10, r24
     ed2:	00 97       	sbiw	r24, 0x00	; 0
     ed4:	09 f4       	brne	.+2      	; 0xed8 <xTaskGenericCreate+0x4a>
     ed6:	6a c0       	rjmp	.+212    	; 0xfac <xTaskGenericCreate+0x11e>
     ed8:	fc 01       	movw	r30, r24
     eda:	c7 88       	ldd	r12, Z+23	; 0x17
     edc:	d0 8c       	ldd	r13, Z+24	; 0x18
     ede:	8b 81       	ldd	r24, Y+3	; 0x03
     ee0:	9c 81       	ldd	r25, Y+4	; 0x04
     ee2:	01 97       	sbiw	r24, 0x01	; 1
     ee4:	c8 0e       	add	r12, r24
     ee6:	d9 1e       	adc	r13, r25
     ee8:	0b 81       	ldd	r16, Y+3	; 0x03
     eea:	1c 81       	ldd	r17, Y+4	; 0x04
     eec:	92 01       	movw	r18, r4
     eee:	47 2d       	mov	r20, r7
     ef0:	b4 01       	movw	r22, r8
     ef2:	c5 01       	movw	r24, r10
     ef4:	0e 94 a8 06 	call	0xd50	; 0xd50 <prvInitialiseTCBVariables>
     ef8:	a1 01       	movw	r20, r2
     efa:	69 81       	ldd	r22, Y+1	; 0x01
     efc:	7a 81       	ldd	r23, Y+2	; 0x02
     efe:	c6 01       	movw	r24, r12
     f00:	0e 94 4a 02 	call	0x494	; 0x494 <pxPortInitialiseStack>
     f04:	f5 01       	movw	r30, r10
     f06:	91 83       	std	Z+1, r25	; 0x01
     f08:	80 83       	st	Z, r24
     f0a:	e1 14       	cp	r14, r1
     f0c:	f1 04       	cpc	r15, r1
     f0e:	19 f0       	breq	.+6      	; 0xf16 <xTaskGenericCreate+0x88>
     f10:	f7 01       	movw	r30, r14
     f12:	b1 82       	std	Z+1, r11	; 0x01
     f14:	a0 82       	st	Z, r10
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	f8 94       	cli
     f1a:	0f 92       	push	r0
     f1c:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <uxCurrentNumberOfTasks>
     f20:	8f 5f       	subi	r24, 0xFF	; 255
     f22:	80 93 d1 05 	sts	0x05D1, r24	; 0x8005d1 <uxCurrentNumberOfTasks>
     f26:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <pxCurrentTCB>
     f2a:	90 91 32 06 	lds	r25, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     f2e:	89 2b       	or	r24, r25
     f30:	59 f4       	brne	.+22     	; 0xf48 <xTaskGenericCreate+0xba>
     f32:	b0 92 32 06 	sts	0x0632, r11	; 0x800632 <pxCurrentTCB+0x1>
     f36:	a0 92 31 06 	sts	0x0631, r10	; 0x800631 <pxCurrentTCB>
     f3a:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <uxCurrentNumberOfTasks>
     f3e:	81 30       	cpi	r24, 0x01	; 1
     f40:	91 f4       	brne	.+36     	; 0xf66 <xTaskGenericCreate+0xd8>
     f42:	0e 94 dd 06 	call	0xdba	; 0xdba <prvInitialiseTaskLists>
     f46:	0f c0       	rjmp	.+30     	; 0xf66 <xTaskGenericCreate+0xd8>
     f48:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <xSchedulerRunning>
     f4c:	81 11       	cpse	r24, r1
     f4e:	0b c0       	rjmp	.+22     	; 0xf66 <xTaskGenericCreate+0xd8>
     f50:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
     f54:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     f58:	86 89       	ldd	r24, Z+22	; 0x16
     f5a:	78 16       	cp	r7, r24
     f5c:	20 f0       	brcs	.+8      	; 0xf66 <xTaskGenericCreate+0xd8>
     f5e:	b0 92 32 06 	sts	0x0632, r11	; 0x800632 <pxCurrentTCB+0x1>
     f62:	a0 92 31 06 	sts	0x0631, r10	; 0x800631 <pxCurrentTCB>
     f66:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <uxTaskNumber>
     f6a:	8f 5f       	subi	r24, 0xFF	; 255
     f6c:	80 93 c9 05 	sts	0x05C9, r24	; 0x8005c9 <uxTaskNumber>
     f70:	f5 01       	movw	r30, r10
     f72:	86 89       	ldd	r24, Z+22	; 0x16
     f74:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
     f78:	98 17       	cp	r25, r24
     f7a:	10 f4       	brcc	.+4      	; 0xf80 <xTaskGenericCreate+0xf2>
     f7c:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	b5 01       	movw	r22, r10
     f84:	6e 5f       	subi	r22, 0xFE	; 254
     f86:	7f 4f       	sbci	r23, 0xFF	; 255
     f88:	9c 01       	movw	r18, r24
     f8a:	22 0f       	add	r18, r18
     f8c:	33 1f       	adc	r19, r19
     f8e:	22 0f       	add	r18, r18
     f90:	33 1f       	adc	r19, r19
     f92:	22 0f       	add	r18, r18
     f94:	33 1f       	adc	r19, r19
     f96:	82 0f       	add	r24, r18
     f98:	93 1f       	adc	r25, r19
     f9a:	85 50       	subi	r24, 0x05	; 5
     f9c:	9a 4f       	sbci	r25, 0xFA	; 250
     f9e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
     fa2:	0f 90       	pop	r0
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	f1 e0       	ldi	r31, 0x01	; 1
     fa8:	f9 83       	std	Y+1, r31	; 0x01
     faa:	02 c0       	rjmp	.+4      	; 0xfb0 <xTaskGenericCreate+0x122>
     fac:	8f ef       	ldi	r24, 0xFF	; 255
     fae:	89 83       	std	Y+1, r24	; 0x01
     fb0:	e9 81       	ldd	r30, Y+1	; 0x01
     fb2:	e1 30       	cpi	r30, 0x01	; 1
     fb4:	69 f4       	brne	.+26     	; 0xfd0 <xTaskGenericCreate+0x142>
     fb6:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <xSchedulerRunning>
     fba:	88 23       	and	r24, r24
     fbc:	49 f0       	breq	.+18     	; 0xfd0 <xTaskGenericCreate+0x142>
     fbe:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
     fc2:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
     fc6:	86 89       	ldd	r24, Z+22	; 0x16
     fc8:	87 15       	cp	r24, r7
     fca:	10 f4       	brcc	.+4      	; 0xfd0 <xTaskGenericCreate+0x142>
     fcc:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     fd0:	89 81       	ldd	r24, Y+1	; 0x01
     fd2:	0f 90       	pop	r0
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	df 91       	pop	r29
     fdc:	cf 91       	pop	r28
     fde:	1f 91       	pop	r17
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	bf 90       	pop	r11
     fec:	af 90       	pop	r10
     fee:	9f 90       	pop	r9
     ff0:	8f 90       	pop	r8
     ff2:	7f 90       	pop	r7
     ff4:	5f 90       	pop	r5
     ff6:	4f 90       	pop	r4
     ff8:	3f 90       	pop	r3
     ffa:	2f 90       	pop	r2
     ffc:	08 95       	ret

00000ffe <vTaskStartScheduler>:
     ffe:	af 92       	push	r10
    1000:	bf 92       	push	r11
    1002:	cf 92       	push	r12
    1004:	df 92       	push	r13
    1006:	ef 92       	push	r14
    1008:	ff 92       	push	r15
    100a:	0f 93       	push	r16
    100c:	a1 2c       	mov	r10, r1
    100e:	b1 2c       	mov	r11, r1
    1010:	c1 2c       	mov	r12, r1
    1012:	d1 2c       	mov	r13, r1
    1014:	e1 2c       	mov	r14, r1
    1016:	f1 2c       	mov	r15, r1
    1018:	00 e0       	ldi	r16, 0x00	; 0
    101a:	20 e0       	ldi	r18, 0x00	; 0
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	45 e5       	ldi	r20, 0x55	; 85
    1020:	50 e0       	ldi	r21, 0x00	; 0
    1022:	62 e7       	ldi	r22, 0x72	; 114
    1024:	70 e0       	ldi	r23, 0x00	; 0
    1026:	8d ea       	ldi	r24, 0xAD	; 173
    1028:	99 e0       	ldi	r25, 0x09	; 9
    102a:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	49 f4       	brne	.+18     	; 0x1044 <vTaskStartScheduler+0x46>
    1032:	f8 94       	cli
    1034:	80 93 cd 05 	sts	0x05CD, r24	; 0x8005cd <xSchedulerRunning>
    1038:	10 92 d0 05 	sts	0x05D0, r1	; 0x8005d0 <xTickCount+0x1>
    103c:	10 92 cf 05 	sts	0x05CF, r1	; 0x8005cf <xTickCount>
    1040:	0e 94 b6 02 	call	0x56c	; 0x56c <xPortStartScheduler>
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	08 95       	ret

00001054 <vTaskSuspendAll>:
    1054:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxSchedulerSuspended>
    1058:	8f 5f       	subi	r24, 0xFF	; 255
    105a:	80 93 c8 05 	sts	0x05C8, r24	; 0x8005c8 <uxSchedulerSuspended>
    105e:	08 95       	ret

00001060 <xTaskIncrementTick>:
    1060:	df 92       	push	r13
    1062:	ef 92       	push	r14
    1064:	ff 92       	push	r15
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxSchedulerSuspended>
    1072:	81 11       	cpse	r24, r1
    1074:	99 c0       	rjmp	.+306    	; 0x11a8 <xTaskIncrementTick+0x148>
    1076:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <xTickCount>
    107a:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    107e:	01 96       	adiw	r24, 0x01	; 1
    1080:	90 93 d0 05 	sts	0x05D0, r25	; 0x8005d0 <xTickCount+0x1>
    1084:	80 93 cf 05 	sts	0x05CF, r24	; 0x8005cf <xTickCount>
    1088:	e0 90 cf 05 	lds	r14, 0x05CF	; 0x8005cf <xTickCount>
    108c:	f0 90 d0 05 	lds	r15, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    1090:	e1 14       	cp	r14, r1
    1092:	f1 04       	cpc	r15, r1
    1094:	b9 f4       	brne	.+46     	; 0x10c4 <xTaskIncrementTick+0x64>
    1096:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <pxDelayedTaskList>
    109a:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <pxDelayedTaskList+0x1>
    109e:	20 91 e5 05 	lds	r18, 0x05E5	; 0x8005e5 <pxOverflowDelayedTaskList>
    10a2:	30 91 e6 05 	lds	r19, 0x05E6	; 0x8005e6 <pxOverflowDelayedTaskList+0x1>
    10a6:	30 93 e8 05 	sts	0x05E8, r19	; 0x8005e8 <pxDelayedTaskList+0x1>
    10aa:	20 93 e7 05 	sts	0x05E7, r18	; 0x8005e7 <pxDelayedTaskList>
    10ae:	90 93 e6 05 	sts	0x05E6, r25	; 0x8005e6 <pxOverflowDelayedTaskList+0x1>
    10b2:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <pxOverflowDelayedTaskList>
    10b6:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <xNumOfOverflows>
    10ba:	8f 5f       	subi	r24, 0xFF	; 255
    10bc:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <xNumOfOverflows>
    10c0:	0e 94 54 06 	call	0xca8	; 0xca8 <prvResetNextTaskUnblockTime>
    10c4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    10c8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    10cc:	e8 16       	cp	r14, r24
    10ce:	f9 06       	cpc	r15, r25
    10d0:	28 f4       	brcc	.+10     	; 0x10dc <xTaskIncrementTick+0x7c>
    10d2:	d1 2c       	mov	r13, r1
    10d4:	53 c0       	rjmp	.+166    	; 0x117c <xTaskIncrementTick+0x11c>
    10d6:	dd 24       	eor	r13, r13
    10d8:	d3 94       	inc	r13
    10da:	01 c0       	rjmp	.+2      	; 0x10de <xTaskIncrementTick+0x7e>
    10dc:	d1 2c       	mov	r13, r1
    10de:	e0 91 e7 05 	lds	r30, 0x05E7	; 0x8005e7 <pxDelayedTaskList>
    10e2:	f0 91 e8 05 	lds	r31, 0x05E8	; 0x8005e8 <pxDelayedTaskList+0x1>
    10e6:	80 81       	ld	r24, Z
    10e8:	81 11       	cpse	r24, r1
    10ea:	07 c0       	rjmp	.+14     	; 0x10fa <xTaskIncrementTick+0x9a>
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	9f ef       	ldi	r25, 0xFF	; 255
    10f0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    10f4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    10f8:	41 c0       	rjmp	.+130    	; 0x117c <xTaskIncrementTick+0x11c>
    10fa:	e0 91 e7 05 	lds	r30, 0x05E7	; 0x8005e7 <pxDelayedTaskList>
    10fe:	f0 91 e8 05 	lds	r31, 0x05E8	; 0x8005e8 <pxDelayedTaskList+0x1>
    1102:	05 80       	ldd	r0, Z+5	; 0x05
    1104:	f6 81       	ldd	r31, Z+6	; 0x06
    1106:	e0 2d       	mov	r30, r0
    1108:	c6 81       	ldd	r28, Z+6	; 0x06
    110a:	d7 81       	ldd	r29, Z+7	; 0x07
    110c:	8a 81       	ldd	r24, Y+2	; 0x02
    110e:	9b 81       	ldd	r25, Y+3	; 0x03
    1110:	e8 16       	cp	r14, r24
    1112:	f9 06       	cpc	r15, r25
    1114:	28 f4       	brcc	.+10     	; 0x1120 <xTaskIncrementTick+0xc0>
    1116:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    111a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    111e:	2e c0       	rjmp	.+92     	; 0x117c <xTaskIncrementTick+0x11c>
    1120:	8e 01       	movw	r16, r28
    1122:	0e 5f       	subi	r16, 0xFE	; 254
    1124:	1f 4f       	sbci	r17, 0xFF	; 255
    1126:	c8 01       	movw	r24, r16
    1128:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    112c:	8c 89       	ldd	r24, Y+20	; 0x14
    112e:	9d 89       	ldd	r25, Y+21	; 0x15
    1130:	89 2b       	or	r24, r25
    1132:	21 f0       	breq	.+8      	; 0x113c <xTaskIncrementTick+0xdc>
    1134:	ce 01       	movw	r24, r28
    1136:	0c 96       	adiw	r24, 0x0c	; 12
    1138:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    113c:	8e 89       	ldd	r24, Y+22	; 0x16
    113e:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    1142:	98 17       	cp	r25, r24
    1144:	10 f4       	brcc	.+4      	; 0x114a <xTaskIncrementTick+0xea>
    1146:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	9c 01       	movw	r18, r24
    114e:	22 0f       	add	r18, r18
    1150:	33 1f       	adc	r19, r19
    1152:	22 0f       	add	r18, r18
    1154:	33 1f       	adc	r19, r19
    1156:	22 0f       	add	r18, r18
    1158:	33 1f       	adc	r19, r19
    115a:	82 0f       	add	r24, r18
    115c:	93 1f       	adc	r25, r19
    115e:	b8 01       	movw	r22, r16
    1160:	85 50       	subi	r24, 0x05	; 5
    1162:	9a 4f       	sbci	r25, 0xFA	; 250
    1164:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1168:	9e 89       	ldd	r25, Y+22	; 0x16
    116a:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    116e:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1172:	86 89       	ldd	r24, Z+22	; 0x16
    1174:	98 17       	cp	r25, r24
    1176:	08 f0       	brcs	.+2      	; 0x117a <xTaskIncrementTick+0x11a>
    1178:	ae cf       	rjmp	.-164    	; 0x10d6 <xTaskIncrementTick+0x76>
    117a:	b1 cf       	rjmp	.-158    	; 0x10de <xTaskIncrementTick+0x7e>
    117c:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    1180:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1184:	86 89       	ldd	r24, Z+22	; 0x16
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	fc 01       	movw	r30, r24
    118a:	ee 0f       	add	r30, r30
    118c:	ff 1f       	adc	r31, r31
    118e:	ee 0f       	add	r30, r30
    1190:	ff 1f       	adc	r31, r31
    1192:	ee 0f       	add	r30, r30
    1194:	ff 1f       	adc	r31, r31
    1196:	8e 0f       	add	r24, r30
    1198:	9f 1f       	adc	r25, r31
    119a:	fc 01       	movw	r30, r24
    119c:	e5 50       	subi	r30, 0x05	; 5
    119e:	fa 4f       	sbci	r31, 0xFA	; 250
    11a0:	80 81       	ld	r24, Z
    11a2:	82 30       	cpi	r24, 0x02	; 2
    11a4:	40 f4       	brcc	.+16     	; 0x11b6 <xTaskIncrementTick+0x156>
    11a6:	09 c0       	rjmp	.+18     	; 0x11ba <xTaskIncrementTick+0x15a>
    11a8:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <uxPendedTicks>
    11ac:	8f 5f       	subi	r24, 0xFF	; 255
    11ae:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <uxPendedTicks>
    11b2:	d1 2c       	mov	r13, r1
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <xTaskIncrementTick+0x15a>
    11b6:	dd 24       	eor	r13, r13
    11b8:	d3 94       	inc	r13
    11ba:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xYieldPending>
    11be:	88 23       	and	r24, r24
    11c0:	11 f0       	breq	.+4      	; 0x11c6 <xTaskIncrementTick+0x166>
    11c2:	dd 24       	eor	r13, r13
    11c4:	d3 94       	inc	r13
    11c6:	8d 2d       	mov	r24, r13
    11c8:	df 91       	pop	r29
    11ca:	cf 91       	pop	r28
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	ff 90       	pop	r15
    11d2:	ef 90       	pop	r14
    11d4:	df 90       	pop	r13
    11d6:	08 95       	ret

000011d8 <xTaskResumeAll>:
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	0f b6       	in	r0, 0x3f	; 63
    11e2:	f8 94       	cli
    11e4:	0f 92       	push	r0
    11e6:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxSchedulerSuspended>
    11ea:	81 50       	subi	r24, 0x01	; 1
    11ec:	80 93 c8 05 	sts	0x05C8, r24	; 0x8005c8 <uxSchedulerSuspended>
    11f0:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxSchedulerSuspended>
    11f4:	81 11       	cpse	r24, r1
    11f6:	57 c0       	rjmp	.+174    	; 0x12a6 <xTaskResumeAll+0xce>
    11f8:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <uxCurrentNumberOfTasks>
    11fc:	81 11       	cpse	r24, r1
    11fe:	32 c0       	rjmp	.+100    	; 0x1264 <xTaskResumeAll+0x8c>
    1200:	55 c0       	rjmp	.+170    	; 0x12ac <xTaskResumeAll+0xd4>
    1202:	e0 91 e1 05 	lds	r30, 0x05E1	; 0x8005e1 <xPendingReadyList+0x5>
    1206:	f0 91 e2 05 	lds	r31, 0x05E2	; 0x8005e2 <xPendingReadyList+0x6>
    120a:	c6 81       	ldd	r28, Z+6	; 0x06
    120c:	d7 81       	ldd	r29, Z+7	; 0x07
    120e:	ce 01       	movw	r24, r28
    1210:	0c 96       	adiw	r24, 0x0c	; 12
    1212:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1216:	8e 01       	movw	r16, r28
    1218:	0e 5f       	subi	r16, 0xFE	; 254
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	c8 01       	movw	r24, r16
    121e:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1222:	8e 89       	ldd	r24, Y+22	; 0x16
    1224:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    1228:	98 17       	cp	r25, r24
    122a:	10 f4       	brcc	.+4      	; 0x1230 <xTaskResumeAll+0x58>
    122c:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	9c 01       	movw	r18, r24
    1234:	22 0f       	add	r18, r18
    1236:	33 1f       	adc	r19, r19
    1238:	22 0f       	add	r18, r18
    123a:	33 1f       	adc	r19, r19
    123c:	22 0f       	add	r18, r18
    123e:	33 1f       	adc	r19, r19
    1240:	82 0f       	add	r24, r18
    1242:	93 1f       	adc	r25, r19
    1244:	b8 01       	movw	r22, r16
    1246:	85 50       	subi	r24, 0x05	; 5
    1248:	9a 4f       	sbci	r25, 0xFA	; 250
    124a:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    124e:	9e 89       	ldd	r25, Y+22	; 0x16
    1250:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    1254:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1258:	86 89       	ldd	r24, Z+22	; 0x16
    125a:	98 17       	cp	r25, r24
    125c:	18 f0       	brcs	.+6      	; 0x1264 <xTaskResumeAll+0x8c>
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xYieldPending>
    1264:	80 91 dc 05 	lds	r24, 0x05DC	; 0x8005dc <xPendingReadyList>
    1268:	81 11       	cpse	r24, r1
    126a:	cb cf       	rjmp	.-106    	; 0x1202 <xTaskResumeAll+0x2a>
    126c:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <uxPendedTicks>
    1270:	81 11       	cpse	r24, r1
    1272:	0d c0       	rjmp	.+26     	; 0x128e <xTaskResumeAll+0xb6>
    1274:	10 c0       	rjmp	.+32     	; 0x1296 <xTaskResumeAll+0xbe>
    1276:	0e 94 30 08 	call	0x1060	; 0x1060 <xTaskIncrementTick>
    127a:	88 23       	and	r24, r24
    127c:	19 f0       	breq	.+6      	; 0x1284 <xTaskResumeAll+0xac>
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xYieldPending>
    1284:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <uxPendedTicks>
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <uxPendedTicks>
    128e:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <uxPendedTicks>
    1292:	81 11       	cpse	r24, r1
    1294:	f0 cf       	rjmp	.-32     	; 0x1276 <xTaskResumeAll+0x9e>
    1296:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xYieldPending>
    129a:	81 30       	cpi	r24, 0x01	; 1
    129c:	31 f4       	brne	.+12     	; 0x12aa <xTaskResumeAll+0xd2>
    129e:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	03 c0       	rjmp	.+6      	; 0x12ac <xTaskResumeAll+0xd4>
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <xTaskResumeAll+0xd4>
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	0f 90       	pop	r0
    12ae:	0f be       	out	0x3f, r0	; 63
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	08 95       	ret

000012ba <vTaskDelay>:
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ec 01       	movw	r28, r24
    12c0:	89 2b       	or	r24, r25
    12c2:	a9 f0       	breq	.+42     	; 0x12ee <vTaskDelay+0x34>
    12c4:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
    12c8:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <xTickCount>
    12cc:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    12d0:	c8 0f       	add	r28, r24
    12d2:	d9 1f       	adc	r29, r25
    12d4:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <pxCurrentTCB>
    12d8:	90 91 32 06 	lds	r25, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    12dc:	02 96       	adiw	r24, 0x02	; 2
    12de:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    12e2:	ce 01       	movw	r24, r28
    12e4:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    12e8:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
    12ec:	01 c0       	rjmp	.+2      	; 0x12f0 <vTaskDelay+0x36>
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	81 11       	cpse	r24, r1
    12f2:	02 c0       	rjmp	.+4      	; 0x12f8 <vTaskDelay+0x3e>
    12f4:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
    12fc:	08 95       	ret

000012fe <prvCheckTasksWaitingTermination>:
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	24 c0       	rjmp	.+72     	; 0x134c <prvCheckTasksWaitingTermination+0x4e>
    1304:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
    1308:	c0 91 d3 05 	lds	r28, 0x05D3	; 0x8005d3 <xTasksWaitingTermination>
    130c:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
    1310:	cc 23       	and	r28, r28
    1312:	e1 f0       	breq	.+56     	; 0x134c <prvCheckTasksWaitingTermination+0x4e>
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	0f 92       	push	r0
    131a:	e0 91 d8 05 	lds	r30, 0x05D8	; 0x8005d8 <xTasksWaitingTermination+0x5>
    131e:	f0 91 d9 05 	lds	r31, 0x05D9	; 0x8005d9 <xTasksWaitingTermination+0x6>
    1322:	c6 81       	ldd	r28, Z+6	; 0x06
    1324:	d7 81       	ldd	r29, Z+7	; 0x07
    1326:	ce 01       	movw	r24, r28
    1328:	02 96       	adiw	r24, 0x02	; 2
    132a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    132e:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <uxCurrentNumberOfTasks>
    1332:	81 50       	subi	r24, 0x01	; 1
    1334:	80 93 d1 05 	sts	0x05D1, r24	; 0x8005d1 <uxCurrentNumberOfTasks>
    1338:	80 91 d2 05 	lds	r24, 0x05D2	; 0x8005d2 <uxTasksDeleted>
    133c:	81 50       	subi	r24, 0x01	; 1
    133e:	80 93 d2 05 	sts	0x05D2, r24	; 0x8005d2 <uxTasksDeleted>
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	ce 01       	movw	r24, r28
    1348:	0e 94 9b 06 	call	0xd36	; 0xd36 <prvDeleteTCB>
    134c:	80 91 d2 05 	lds	r24, 0x05D2	; 0x8005d2 <uxTasksDeleted>
    1350:	81 11       	cpse	r24, r1
    1352:	d8 cf       	rjmp	.-80     	; 0x1304 <prvCheckTasksWaitingTermination+0x6>
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	08 95       	ret

0000135a <prvIdleTask>:
    135a:	0e 94 7f 09 	call	0x12fe	; 0x12fe <prvCheckTasksWaitingTermination>
    135e:	80 91 fb 05 	lds	r24, 0x05FB	; 0x8005fb <pxReadyTasksLists>
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	d0 f3       	brcs	.-12     	; 0x135a <prvIdleTask>
    1366:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    136a:	f7 cf       	rjmp	.-18     	; 0x135a <prvIdleTask>

0000136c <vTaskSwitchContext>:
    136c:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxSchedulerSuspended>
    1370:	88 23       	and	r24, r24
    1372:	21 f0       	breq	.+8      	; 0x137c <vTaskSwitchContext+0x10>
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xYieldPending>
    137a:	08 95       	ret
    137c:	10 92 cb 05 	sts	0x05CB, r1	; 0x8005cb <xYieldPending>
    1380:	05 c0       	rjmp	.+10     	; 0x138c <vTaskSwitchContext+0x20>
    1382:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    1386:	81 50       	subi	r24, 0x01	; 1
    1388:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    138c:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    1390:	90 e0       	ldi	r25, 0x00	; 0
    1392:	fc 01       	movw	r30, r24
    1394:	ee 0f       	add	r30, r30
    1396:	ff 1f       	adc	r31, r31
    1398:	ee 0f       	add	r30, r30
    139a:	ff 1f       	adc	r31, r31
    139c:	ee 0f       	add	r30, r30
    139e:	ff 1f       	adc	r31, r31
    13a0:	8e 0f       	add	r24, r30
    13a2:	9f 1f       	adc	r25, r31
    13a4:	fc 01       	movw	r30, r24
    13a6:	e5 50       	subi	r30, 0x05	; 5
    13a8:	fa 4f       	sbci	r31, 0xFA	; 250
    13aa:	80 81       	ld	r24, Z
    13ac:	88 23       	and	r24, r24
    13ae:	49 f3       	breq	.-46     	; 0x1382 <vTaskSwitchContext+0x16>
    13b0:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	9c 01       	movw	r18, r24
    13b8:	22 0f       	add	r18, r18
    13ba:	33 1f       	adc	r19, r19
    13bc:	22 0f       	add	r18, r18
    13be:	33 1f       	adc	r19, r19
    13c0:	22 0f       	add	r18, r18
    13c2:	33 1f       	adc	r19, r19
    13c4:	28 0f       	add	r18, r24
    13c6:	39 1f       	adc	r19, r25
    13c8:	d9 01       	movw	r26, r18
    13ca:	a5 50       	subi	r26, 0x05	; 5
    13cc:	ba 4f       	sbci	r27, 0xFA	; 250
    13ce:	11 96       	adiw	r26, 0x01	; 1
    13d0:	ed 91       	ld	r30, X+
    13d2:	fc 91       	ld	r31, X
    13d4:	12 97       	sbiw	r26, 0x02	; 2
    13d6:	02 80       	ldd	r0, Z+2	; 0x02
    13d8:	f3 81       	ldd	r31, Z+3	; 0x03
    13da:	e0 2d       	mov	r30, r0
    13dc:	12 96       	adiw	r26, 0x02	; 2
    13de:	fc 93       	st	X, r31
    13e0:	ee 93       	st	-X, r30
    13e2:	11 97       	sbiw	r26, 0x01	; 1
    13e4:	22 50       	subi	r18, 0x02	; 2
    13e6:	3a 4f       	sbci	r19, 0xFA	; 250
    13e8:	e2 17       	cp	r30, r18
    13ea:	f3 07       	cpc	r31, r19
    13ec:	29 f4       	brne	.+10     	; 0x13f8 <vTaskSwitchContext+0x8c>
    13ee:	22 81       	ldd	r18, Z+2	; 0x02
    13f0:	33 81       	ldd	r19, Z+3	; 0x03
    13f2:	fd 01       	movw	r30, r26
    13f4:	32 83       	std	Z+2, r19	; 0x02
    13f6:	21 83       	std	Z+1, r18	; 0x01
    13f8:	fc 01       	movw	r30, r24
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	ee 0f       	add	r30, r30
    1400:	ff 1f       	adc	r31, r31
    1402:	ee 0f       	add	r30, r30
    1404:	ff 1f       	adc	r31, r31
    1406:	8e 0f       	add	r24, r30
    1408:	9f 1f       	adc	r25, r31
    140a:	fc 01       	movw	r30, r24
    140c:	e5 50       	subi	r30, 0x05	; 5
    140e:	fa 4f       	sbci	r31, 0xFA	; 250
    1410:	01 80       	ldd	r0, Z+1	; 0x01
    1412:	f2 81       	ldd	r31, Z+2	; 0x02
    1414:	e0 2d       	mov	r30, r0
    1416:	86 81       	ldd	r24, Z+6	; 0x06
    1418:	97 81       	ldd	r25, Z+7	; 0x07
    141a:	90 93 32 06 	sts	0x0632, r25	; 0x800632 <pxCurrentTCB+0x1>
    141e:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <pxCurrentTCB>
    1422:	08 95       	ret

00001424 <vTaskPlaceOnEventList>:
    1424:	cf 93       	push	r28
    1426:	df 93       	push	r29
    1428:	eb 01       	movw	r28, r22
    142a:	60 91 31 06 	lds	r22, 0x0631	; 0x800631 <pxCurrentTCB>
    142e:	70 91 32 06 	lds	r23, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1432:	64 5f       	subi	r22, 0xF4	; 244
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
    143a:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <pxCurrentTCB>
    143e:	90 91 32 06 	lds	r25, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1442:	02 96       	adiw	r24, 0x02	; 2
    1444:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1448:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <xTickCount>
    144c:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    1450:	8c 0f       	add	r24, r28
    1452:	9d 1f       	adc	r25, r29
    1454:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	08 95       	ret

0000145e <vTaskPlaceOnUnorderedEventList>:
    145e:	cf 93       	push	r28
    1460:	df 93       	push	r29
    1462:	ea 01       	movw	r28, r20
    1464:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    1468:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    146c:	70 68       	ori	r23, 0x80	; 128
    146e:	75 87       	std	Z+13, r23	; 0x0d
    1470:	64 87       	std	Z+12, r22	; 0x0c
    1472:	60 91 31 06 	lds	r22, 0x0631	; 0x800631 <pxCurrentTCB>
    1476:	70 91 32 06 	lds	r23, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    147a:	64 5f       	subi	r22, 0xF4	; 244
    147c:	7f 4f       	sbci	r23, 0xFF	; 255
    147e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1482:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <pxCurrentTCB>
    1486:	90 91 32 06 	lds	r25, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    148a:	02 96       	adiw	r24, 0x02	; 2
    148c:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1490:	80 91 cf 05 	lds	r24, 0x05CF	; 0x8005cf <xTickCount>
    1494:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    1498:	8c 0f       	add	r24, r28
    149a:	9d 1f       	adc	r25, r29
    149c:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	08 95       	ret

000014a6 <xTaskRemoveFromEventList>:
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	dc 01       	movw	r26, r24
    14b0:	15 96       	adiw	r26, 0x05	; 5
    14b2:	ed 91       	ld	r30, X+
    14b4:	fc 91       	ld	r31, X
    14b6:	16 97       	sbiw	r26, 0x06	; 6
    14b8:	c6 81       	ldd	r28, Z+6	; 0x06
    14ba:	d7 81       	ldd	r29, Z+7	; 0x07
    14bc:	8e 01       	movw	r16, r28
    14be:	04 5f       	subi	r16, 0xF4	; 244
    14c0:	1f 4f       	sbci	r17, 0xFF	; 255
    14c2:	c8 01       	movw	r24, r16
    14c4:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    14c8:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxSchedulerSuspended>
    14cc:	81 11       	cpse	r24, r1
    14ce:	1c c0       	rjmp	.+56     	; 0x1508 <xTaskRemoveFromEventList+0x62>
    14d0:	0a 50       	subi	r16, 0x0A	; 10
    14d2:	11 09       	sbc	r17, r1
    14d4:	c8 01       	movw	r24, r16
    14d6:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    14da:	8e 89       	ldd	r24, Y+22	; 0x16
    14dc:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    14e0:	98 17       	cp	r25, r24
    14e2:	10 f4       	brcc	.+4      	; 0x14e8 <xTaskRemoveFromEventList+0x42>
    14e4:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    14e8:	90 e0       	ldi	r25, 0x00	; 0
    14ea:	9c 01       	movw	r18, r24
    14ec:	22 0f       	add	r18, r18
    14ee:	33 1f       	adc	r19, r19
    14f0:	22 0f       	add	r18, r18
    14f2:	33 1f       	adc	r19, r19
    14f4:	22 0f       	add	r18, r18
    14f6:	33 1f       	adc	r19, r19
    14f8:	82 0f       	add	r24, r18
    14fa:	93 1f       	adc	r25, r19
    14fc:	b8 01       	movw	r22, r16
    14fe:	85 50       	subi	r24, 0x05	; 5
    1500:	9a 4f       	sbci	r25, 0xFA	; 250
    1502:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1506:	05 c0       	rjmp	.+10     	; 0x1512 <xTaskRemoveFromEventList+0x6c>
    1508:	b8 01       	movw	r22, r16
    150a:	8c ed       	ldi	r24, 0xDC	; 220
    150c:	95 e0       	ldi	r25, 0x05	; 5
    150e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1512:	9e 89       	ldd	r25, Y+22	; 0x16
    1514:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    1518:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    151c:	86 89       	ldd	r24, Z+22	; 0x16
    151e:	89 17       	cp	r24, r25
    1520:	20 f4       	brcc	.+8      	; 0x152a <xTaskRemoveFromEventList+0x84>
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xYieldPending>
    1528:	01 c0       	rjmp	.+2      	; 0x152c <xTaskRemoveFromEventList+0x86>
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	df 91       	pop	r29
    152e:	cf 91       	pop	r28
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	08 95       	ret

00001536 <xTaskRemoveFromUnorderedEventList>:
    1536:	0f 93       	push	r16
    1538:	1f 93       	push	r17
    153a:	cf 93       	push	r28
    153c:	df 93       	push	r29
    153e:	70 68       	ori	r23, 0x80	; 128
    1540:	fc 01       	movw	r30, r24
    1542:	71 83       	std	Z+1, r23	; 0x01
    1544:	60 83       	st	Z, r22
    1546:	c6 81       	ldd	r28, Z+6	; 0x06
    1548:	d7 81       	ldd	r29, Z+7	; 0x07
    154a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    154e:	8e 01       	movw	r16, r28
    1550:	0e 5f       	subi	r16, 0xFE	; 254
    1552:	1f 4f       	sbci	r17, 0xFF	; 255
    1554:	c8 01       	movw	r24, r16
    1556:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    155a:	8e 89       	ldd	r24, Y+22	; 0x16
    155c:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    1560:	98 17       	cp	r25, r24
    1562:	10 f4       	brcc	.+4      	; 0x1568 <xTaskRemoveFromUnorderedEventList+0x32>
    1564:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	9c 01       	movw	r18, r24
    156c:	22 0f       	add	r18, r18
    156e:	33 1f       	adc	r19, r19
    1570:	22 0f       	add	r18, r18
    1572:	33 1f       	adc	r19, r19
    1574:	22 0f       	add	r18, r18
    1576:	33 1f       	adc	r19, r19
    1578:	82 0f       	add	r24, r18
    157a:	93 1f       	adc	r25, r19
    157c:	b8 01       	movw	r22, r16
    157e:	85 50       	subi	r24, 0x05	; 5
    1580:	9a 4f       	sbci	r25, 0xFA	; 250
    1582:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1586:	9e 89       	ldd	r25, Y+22	; 0x16
    1588:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    158c:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1590:	86 89       	ldd	r24, Z+22	; 0x16
    1592:	89 17       	cp	r24, r25
    1594:	20 f4       	brcc	.+8      	; 0x159e <xTaskRemoveFromUnorderedEventList+0x68>
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xYieldPending>
    159c:	01 c0       	rjmp	.+2      	; 0x15a0 <xTaskRemoveFromUnorderedEventList+0x6a>
    159e:	80 e0       	ldi	r24, 0x00	; 0
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	08 95       	ret

000015aa <vTaskSetTimeOutState>:
    15aa:	20 91 ca 05 	lds	r18, 0x05CA	; 0x8005ca <xNumOfOverflows>
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
    15b2:	20 91 cf 05 	lds	r18, 0x05CF	; 0x8005cf <xTickCount>
    15b6:	30 91 d0 05 	lds	r19, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    15ba:	32 83       	std	Z+2, r19	; 0x02
    15bc:	21 83       	std	Z+1, r18	; 0x01
    15be:	08 95       	ret

000015c0 <xTaskCheckForTimeOut>:
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	fc 01       	movw	r30, r24
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
    15cc:	40 91 cf 05 	lds	r20, 0x05CF	; 0x8005cf <xTickCount>
    15d0:	50 91 d0 05 	lds	r21, 0x05D0	; 0x8005d0 <xTickCount+0x1>
    15d4:	90 81       	ld	r25, Z
    15d6:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <xNumOfOverflows>
    15da:	98 17       	cp	r25, r24
    15dc:	29 f0       	breq	.+10     	; 0x15e8 <xTaskCheckForTimeOut+0x28>
    15de:	81 81       	ldd	r24, Z+1	; 0x01
    15e0:	92 81       	ldd	r25, Z+2	; 0x02
    15e2:	48 17       	cp	r20, r24
    15e4:	59 07       	cpc	r21, r25
    15e6:	b0 f4       	brcc	.+44     	; 0x1614 <xTaskCheckForTimeOut+0x54>
    15e8:	21 81       	ldd	r18, Z+1	; 0x01
    15ea:	32 81       	ldd	r19, Z+2	; 0x02
    15ec:	ca 01       	movw	r24, r20
    15ee:	82 1b       	sub	r24, r18
    15f0:	93 0b       	sbc	r25, r19
    15f2:	eb 01       	movw	r28, r22
    15f4:	a8 81       	ld	r26, Y
    15f6:	b9 81       	ldd	r27, Y+1	; 0x01
    15f8:	8a 17       	cp	r24, r26
    15fa:	9b 07       	cpc	r25, r27
    15fc:	68 f4       	brcc	.+26     	; 0x1618 <xTaskCheckForTimeOut+0x58>
    15fe:	cf 01       	movw	r24, r30
    1600:	24 1b       	sub	r18, r20
    1602:	35 0b       	sbc	r19, r21
    1604:	2a 0f       	add	r18, r26
    1606:	3b 1f       	adc	r19, r27
    1608:	39 83       	std	Y+1, r19	; 0x01
    160a:	28 83       	st	Y, r18
    160c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	03 c0       	rjmp	.+6      	; 0x161a <xTaskCheckForTimeOut+0x5a>
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	01 c0       	rjmp	.+2      	; 0x161a <xTaskCheckForTimeOut+0x5a>
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	df 91       	pop	r29
    1620:	cf 91       	pop	r28
    1622:	08 95       	ret

00001624 <vTaskMissedYield>:
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xYieldPending>
    162a:	08 95       	ret

0000162c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1636:	89 2b       	or	r24, r25
    1638:	09 f4       	brne	.+2      	; 0x163c <vTaskPriorityInherit+0x10>
    163a:	55 c0       	rjmp	.+170    	; 0x16e6 <vTaskPriorityInherit+0xba>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    163c:	26 89       	ldd	r18, Z+22	; 0x16
    163e:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
    1642:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1646:	56 96       	adiw	r26, 0x16	; 22
    1648:	8c 91       	ld	r24, X
    164a:	28 17       	cp	r18, r24
    164c:	08 f0       	brcs	.+2      	; 0x1650 <vTaskPriorityInherit+0x24>
    164e:	4b c0       	rjmp	.+150    	; 0x16e6 <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1650:	84 85       	ldd	r24, Z+12	; 0x0c
    1652:	95 85       	ldd	r25, Z+13	; 0x0d
    1654:	99 23       	and	r25, r25
    1656:	64 f0       	brlt	.+24     	; 0x1670 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1658:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
    165c:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1660:	56 96       	adiw	r26, 0x16	; 22
    1662:	3c 91       	ld	r19, X
    1664:	86 e0       	ldi	r24, 0x06	; 6
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	83 1b       	sub	r24, r19
    166a:	91 09       	sbc	r25, r1
    166c:	95 87       	std	Z+13, r25	; 0x0d
    166e:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1670:	82 85       	ldd	r24, Z+10	; 0x0a
    1672:	93 85       	ldd	r25, Z+11	; 0x0b
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	a9 01       	movw	r20, r18
    1678:	44 0f       	add	r20, r20
    167a:	55 1f       	adc	r21, r21
    167c:	44 0f       	add	r20, r20
    167e:	55 1f       	adc	r21, r21
    1680:	44 0f       	add	r20, r20
    1682:	55 1f       	adc	r21, r21
    1684:	24 0f       	add	r18, r20
    1686:	35 1f       	adc	r19, r21
    1688:	25 50       	subi	r18, 0x05	; 5
    168a:	3a 4f       	sbci	r19, 0xFA	; 250
    168c:	82 17       	cp	r24, r18
    168e:	93 07       	cpc	r25, r19
    1690:	19 f5       	brne	.+70     	; 0x16d8 <vTaskPriorityInherit+0xac>
    1692:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1694:	ef 01       	movw	r28, r30
    1696:	22 96       	adiw	r28, 0x02	; 2
    1698:	ce 01       	movw	r24, r28
    169a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    169e:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    16a2:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    16a6:	86 89       	ldd	r24, Z+22	; 0x16
    16a8:	f8 01       	movw	r30, r16
    16aa:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    16ac:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    16b0:	98 17       	cp	r25, r24
    16b2:	10 f4       	brcc	.+4      	; 0x16b8 <vTaskPriorityInherit+0x8c>
    16b4:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	9c 01       	movw	r18, r24
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	22 0f       	add	r18, r18
    16c2:	33 1f       	adc	r19, r19
    16c4:	22 0f       	add	r18, r18
    16c6:	33 1f       	adc	r19, r19
    16c8:	82 0f       	add	r24, r18
    16ca:	93 1f       	adc	r25, r19
    16cc:	be 01       	movw	r22, r28
    16ce:	85 50       	subi	r24, 0x05	; 5
    16d0:	9a 4f       	sbci	r25, 0xFA	; 250
    16d2:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    16d6:	07 c0       	rjmp	.+14     	; 0x16e6 <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    16d8:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
    16dc:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    16e0:	56 96       	adiw	r26, 0x16	; 22
    16e2:	8c 91       	ld	r24, X
    16e4:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    16e6:	df 91       	pop	r29
    16e8:	cf 91       	pop	r28
    16ea:	1f 91       	pop	r17
    16ec:	0f 91       	pop	r16
    16ee:	08 95       	ret

000016f0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    16fa:	89 2b       	or	r24, r25
    16fc:	79 f1       	breq	.+94     	; 0x175c <xTaskPriorityDisinherit+0x6c>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    16fe:	83 a9       	ldd	r24, Z+51	; 0x33
    1700:	81 50       	subi	r24, 0x01	; 1
    1702:	83 ab       	std	Z+51, r24	; 0x33

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1704:	26 89       	ldd	r18, Z+22	; 0x16
    1706:	92 a9       	ldd	r25, Z+50	; 0x32
    1708:	29 17       	cp	r18, r25
    170a:	51 f1       	breq	.+84     	; 0x1760 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    170c:	81 11       	cpse	r24, r1
    170e:	2a c0       	rjmp	.+84     	; 0x1764 <xTaskPriorityDisinherit+0x74>
    1710:	ef 01       	movw	r28, r30
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1712:	8f 01       	movw	r16, r30
    1714:	0e 5f       	subi	r16, 0xFE	; 254
    1716:	1f 4f       	sbci	r17, 0xFF	; 255
    1718:	c8 01       	movw	r24, r16
    171a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    171e:	8a a9       	ldd	r24, Y+50	; 0x32
    1720:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1722:	26 e0       	ldi	r18, 0x06	; 6
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	28 1b       	sub	r18, r24
    1728:	31 09       	sbc	r19, r1
    172a:	3d 87       	std	Y+13, r19	; 0x0d
    172c:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    172e:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <uxTopReadyPriority>
    1732:	98 17       	cp	r25, r24
    1734:	10 f4       	brcc	.+4      	; 0x173a <xTaskPriorityDisinherit+0x4a>
    1736:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTopReadyPriority>
    173a:	90 e0       	ldi	r25, 0x00	; 0
    173c:	9c 01       	movw	r18, r24
    173e:	22 0f       	add	r18, r18
    1740:	33 1f       	adc	r19, r19
    1742:	22 0f       	add	r18, r18
    1744:	33 1f       	adc	r19, r19
    1746:	22 0f       	add	r18, r18
    1748:	33 1f       	adc	r19, r19
    174a:	82 0f       	add	r24, r18
    174c:	93 1f       	adc	r25, r19
    174e:	b8 01       	movw	r22, r16
    1750:	85 50       	subi	r24, 0x05	; 5
    1752:	9a 4f       	sbci	r25, 0xFA	; 250
    1754:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	05 c0       	rjmp	.+10     	; 0x1766 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    175c:	80 e0       	ldi	r24, 0x00	; 0
    175e:	03 c0       	rjmp	.+6      	; 0x1766 <xTaskPriorityDisinherit+0x76>
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	01 c0       	rjmp	.+2      	; 0x1766 <xTaskPriorityDisinherit+0x76>
    1764:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	08 95       	ret

00001770 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1770:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    1774:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1778:	84 85       	ldd	r24, Z+12	; 0x0c
    177a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    177c:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    1780:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    1784:	a0 91 31 06 	lds	r26, 0x0631	; 0x800631 <pxCurrentTCB>
    1788:	b0 91 32 06 	lds	r27, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    178c:	56 96       	adiw	r26, 0x16	; 22
    178e:	4c 91       	ld	r20, X
    1790:	26 e0       	ldi	r18, 0x06	; 6
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	24 1b       	sub	r18, r20
    1796:	31 09       	sbc	r19, r1
    1798:	35 87       	std	Z+13, r19	; 0x0d
    179a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    179c:	08 95       	ret

0000179e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    179e:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <pxCurrentTCB>
    17a2:	90 91 32 06 	lds	r25, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    17a6:	89 2b       	or	r24, r25
    17a8:	39 f0       	breq	.+14     	; 0x17b8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17aa:	e0 91 31 06 	lds	r30, 0x0631	; 0x800631 <pxCurrentTCB>
    17ae:	f0 91 32 06 	lds	r31, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
    17b2:	83 a9       	ldd	r24, Z+51	; 0x33
    17b4:	8f 5f       	subi	r24, 0xFF	; 255
    17b6:	83 ab       	std	Z+51, r24	; 0x33
		}

		return pxCurrentTCB;
    17b8:	80 91 31 06 	lds	r24, 0x0631	; 0x800631 <pxCurrentTCB>
    17bc:	90 91 32 06 	lds	r25, 0x0632	; 0x800632 <pxCurrentTCB+0x1>
	}
    17c0:	08 95       	ret

000017c2 <LCD_SendCommand>:

void LCD_DisplayCustomCharacterRowCol(uint8 location , uint8 row ,uint8 col)
{
    LCD_MoveCursor(row,col);
    LCD_DisplayCharacter(location);
}
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	c8 2f       	mov	r28, r24
    17c8:	40 e0       	ldi	r20, 0x00	; 0
    17ca:	63 e0       	ldi	r22, 0x03	; 3
    17cc:	80 e0       	ldi	r24, 0x00	; 0
    17ce:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    17d2:	8f ec       	ldi	r24, 0xCF	; 207
    17d4:	97 e0       	ldi	r25, 0x07	; 7
    17d6:	01 97       	sbiw	r24, 0x01	; 1
    17d8:	f1 f7       	brne	.-4      	; 0x17d6 <LCD_SendCommand+0x14>
    17da:	00 c0       	rjmp	.+0      	; 0x17dc <LCD_SendCommand+0x1a>
    17dc:	00 00       	nop
    17de:	41 e0       	ldi	r20, 0x01	; 1
    17e0:	62 e0       	ldi	r22, 0x02	; 2
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    17e8:	8f ec       	ldi	r24, 0xCF	; 207
    17ea:	97 e0       	ldi	r25, 0x07	; 7
    17ec:	01 97       	sbiw	r24, 0x01	; 1
    17ee:	f1 f7       	brne	.-4      	; 0x17ec <LCD_SendCommand+0x2a>
    17f0:	00 c0       	rjmp	.+0      	; 0x17f2 <LCD_SendCommand+0x30>
    17f2:	00 00       	nop
    17f4:	dc 2f       	mov	r29, r28
    17f6:	d2 95       	swap	r29
    17f8:	df 70       	andi	r29, 0x0F	; 15
    17fa:	4d 2f       	mov	r20, r29
    17fc:	41 70       	andi	r20, 0x01	; 1
    17fe:	60 e0       	ldi	r22, 0x00	; 0
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1806:	d1 fb       	bst	r29, 1
    1808:	44 27       	eor	r20, r20
    180a:	40 f9       	bld	r20, 0
    180c:	61 e0       	ldi	r22, 0x01	; 1
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1814:	d2 fb       	bst	r29, 2
    1816:	44 27       	eor	r20, r20
    1818:	40 f9       	bld	r20, 0
    181a:	62 e0       	ldi	r22, 0x02	; 2
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1822:	4c 2f       	mov	r20, r28
    1824:	44 1f       	adc	r20, r20
    1826:	44 27       	eor	r20, r20
    1828:	44 1f       	adc	r20, r20
    182a:	64 e0       	ldi	r22, 0x04	; 4
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1832:	8f ec       	ldi	r24, 0xCF	; 207
    1834:	97 e0       	ldi	r25, 0x07	; 7
    1836:	01 97       	sbiw	r24, 0x01	; 1
    1838:	f1 f7       	brne	.-4      	; 0x1836 <LCD_SendCommand+0x74>
    183a:	00 c0       	rjmp	.+0      	; 0x183c <LCD_SendCommand+0x7a>
    183c:	00 00       	nop
    183e:	40 e0       	ldi	r20, 0x00	; 0
    1840:	62 e0       	ldi	r22, 0x02	; 2
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1848:	8f ec       	ldi	r24, 0xCF	; 207
    184a:	97 e0       	ldi	r25, 0x07	; 7
    184c:	01 97       	sbiw	r24, 0x01	; 1
    184e:	f1 f7       	brne	.-4      	; 0x184c <LCD_SendCommand+0x8a>
    1850:	00 c0       	rjmp	.+0      	; 0x1852 <LCD_SendCommand+0x90>
    1852:	00 00       	nop
    1854:	41 e0       	ldi	r20, 0x01	; 1
    1856:	62 e0       	ldi	r22, 0x02	; 2
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    185e:	8f ec       	ldi	r24, 0xCF	; 207
    1860:	97 e0       	ldi	r25, 0x07	; 7
    1862:	01 97       	sbiw	r24, 0x01	; 1
    1864:	f1 f7       	brne	.-4      	; 0x1862 <LCD_SendCommand+0xa0>
    1866:	00 c0       	rjmp	.+0      	; 0x1868 <LCD_SendCommand+0xa6>
    1868:	00 00       	nop
    186a:	dc 2f       	mov	r29, r28
    186c:	df 70       	andi	r29, 0x0F	; 15
    186e:	4c 2f       	mov	r20, r28
    1870:	41 70       	andi	r20, 0x01	; 1
    1872:	60 e0       	ldi	r22, 0x00	; 0
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    187a:	d1 fb       	bst	r29, 1
    187c:	44 27       	eor	r20, r20
    187e:	40 f9       	bld	r20, 0
    1880:	61 e0       	ldi	r22, 0x01	; 1
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1888:	d2 fb       	bst	r29, 2
    188a:	44 27       	eor	r20, r20
    188c:	40 f9       	bld	r20, 0
    188e:	62 e0       	ldi	r22, 0x02	; 2
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1896:	4d 2f       	mov	r20, r29
    1898:	46 95       	lsr	r20
    189a:	46 95       	lsr	r20
    189c:	46 95       	lsr	r20
    189e:	64 e0       	ldi	r22, 0x04	; 4
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    18a6:	8f ec       	ldi	r24, 0xCF	; 207
    18a8:	97 e0       	ldi	r25, 0x07	; 7
    18aa:	01 97       	sbiw	r24, 0x01	; 1
    18ac:	f1 f7       	brne	.-4      	; 0x18aa <LCD_SendCommand+0xe8>
    18ae:	00 c0       	rjmp	.+0      	; 0x18b0 <LCD_SendCommand+0xee>
    18b0:	00 00       	nop
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	62 e0       	ldi	r22, 0x02	; 2
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    18bc:	8f ec       	ldi	r24, 0xCF	; 207
    18be:	97 e0       	ldi	r25, 0x07	; 7
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	f1 f7       	brne	.-4      	; 0x18c0 <LCD_SendCommand+0xfe>
    18c4:	00 c0       	rjmp	.+0      	; 0x18c6 <LCD_SendCommand+0x104>
    18c6:	00 00       	nop
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <LCD_init>:
    18ce:	42 e0       	ldi	r20, 0x02	; 2
    18d0:	63 e0       	ldi	r22, 0x03	; 3
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
    18d8:	42 e0       	ldi	r20, 0x02	; 2
    18da:	62 e0       	ldi	r22, 0x02	; 2
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
    18e2:	42 e0       	ldi	r20, 0x02	; 2
    18e4:	60 e0       	ldi	r22, 0x00	; 0
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
    18ec:	42 e0       	ldi	r20, 0x02	; 2
    18ee:	61 e0       	ldi	r22, 0x01	; 1
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
    18f6:	42 e0       	ldi	r20, 0x02	; 2
    18f8:	62 e0       	ldi	r22, 0x02	; 2
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
    1900:	42 e0       	ldi	r20, 0x02	; 2
    1902:	64 e0       	ldi	r22, 0x04	; 4
    1904:	81 e0       	ldi	r24, 0x01	; 1
    1906:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
    190a:	82 e0       	ldi	r24, 0x02	; 2
    190c:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1910:	88 e2       	ldi	r24, 0x28	; 40
    1912:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1916:	8c e0       	ldi	r24, 0x0C	; 12
    1918:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1922:	08 95       	ret

00001924 <LCD_DisplayCharacter>:
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	c8 2f       	mov	r28, r24
    192a:	41 e0       	ldi	r20, 0x01	; 1
    192c:	63 e0       	ldi	r22, 0x03	; 3
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1934:	8f ec       	ldi	r24, 0xCF	; 207
    1936:	97 e0       	ldi	r25, 0x07	; 7
    1938:	01 97       	sbiw	r24, 0x01	; 1
    193a:	f1 f7       	brne	.-4      	; 0x1938 <LCD_DisplayCharacter+0x14>
    193c:	00 c0       	rjmp	.+0      	; 0x193e <LCD_DisplayCharacter+0x1a>
    193e:	00 00       	nop
    1940:	41 e0       	ldi	r20, 0x01	; 1
    1942:	62 e0       	ldi	r22, 0x02	; 2
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    194a:	8f ec       	ldi	r24, 0xCF	; 207
    194c:	97 e0       	ldi	r25, 0x07	; 7
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	f1 f7       	brne	.-4      	; 0x194e <LCD_DisplayCharacter+0x2a>
    1952:	00 c0       	rjmp	.+0      	; 0x1954 <LCD_DisplayCharacter+0x30>
    1954:	00 00       	nop
    1956:	dc 2f       	mov	r29, r28
    1958:	d2 95       	swap	r29
    195a:	df 70       	andi	r29, 0x0F	; 15
    195c:	4d 2f       	mov	r20, r29
    195e:	41 70       	andi	r20, 0x01	; 1
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1968:	d1 fb       	bst	r29, 1
    196a:	44 27       	eor	r20, r20
    196c:	40 f9       	bld	r20, 0
    196e:	61 e0       	ldi	r22, 0x01	; 1
    1970:	81 e0       	ldi	r24, 0x01	; 1
    1972:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1976:	d2 fb       	bst	r29, 2
    1978:	44 27       	eor	r20, r20
    197a:	40 f9       	bld	r20, 0
    197c:	62 e0       	ldi	r22, 0x02	; 2
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1984:	4c 2f       	mov	r20, r28
    1986:	44 1f       	adc	r20, r20
    1988:	44 27       	eor	r20, r20
    198a:	44 1f       	adc	r20, r20
    198c:	64 e0       	ldi	r22, 0x04	; 4
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1994:	8f ec       	ldi	r24, 0xCF	; 207
    1996:	97 e0       	ldi	r25, 0x07	; 7
    1998:	01 97       	sbiw	r24, 0x01	; 1
    199a:	f1 f7       	brne	.-4      	; 0x1998 <LCD_DisplayCharacter+0x74>
    199c:	00 c0       	rjmp	.+0      	; 0x199e <LCD_DisplayCharacter+0x7a>
    199e:	00 00       	nop
    19a0:	40 e0       	ldi	r20, 0x00	; 0
    19a2:	62 e0       	ldi	r22, 0x02	; 2
    19a4:	80 e0       	ldi	r24, 0x00	; 0
    19a6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    19aa:	8f ec       	ldi	r24, 0xCF	; 207
    19ac:	97 e0       	ldi	r25, 0x07	; 7
    19ae:	01 97       	sbiw	r24, 0x01	; 1
    19b0:	f1 f7       	brne	.-4      	; 0x19ae <LCD_DisplayCharacter+0x8a>
    19b2:	00 c0       	rjmp	.+0      	; 0x19b4 <LCD_DisplayCharacter+0x90>
    19b4:	00 00       	nop
    19b6:	41 e0       	ldi	r20, 0x01	; 1
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    19c0:	8f ec       	ldi	r24, 0xCF	; 207
    19c2:	97 e0       	ldi	r25, 0x07	; 7
    19c4:	01 97       	sbiw	r24, 0x01	; 1
    19c6:	f1 f7       	brne	.-4      	; 0x19c4 <LCD_DisplayCharacter+0xa0>
    19c8:	00 c0       	rjmp	.+0      	; 0x19ca <LCD_DisplayCharacter+0xa6>
    19ca:	00 00       	nop
    19cc:	dc 2f       	mov	r29, r28
    19ce:	df 70       	andi	r29, 0x0F	; 15
    19d0:	4c 2f       	mov	r20, r28
    19d2:	41 70       	andi	r20, 0x01	; 1
    19d4:	60 e0       	ldi	r22, 0x00	; 0
    19d6:	81 e0       	ldi	r24, 0x01	; 1
    19d8:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    19dc:	d1 fb       	bst	r29, 1
    19de:	44 27       	eor	r20, r20
    19e0:	40 f9       	bld	r20, 0
    19e2:	61 e0       	ldi	r22, 0x01	; 1
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    19ea:	d2 fb       	bst	r29, 2
    19ec:	44 27       	eor	r20, r20
    19ee:	40 f9       	bld	r20, 0
    19f0:	62 e0       	ldi	r22, 0x02	; 2
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    19f8:	4d 2f       	mov	r20, r29
    19fa:	46 95       	lsr	r20
    19fc:	46 95       	lsr	r20
    19fe:	46 95       	lsr	r20
    1a00:	64 e0       	ldi	r22, 0x04	; 4
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1a08:	8f ec       	ldi	r24, 0xCF	; 207
    1a0a:	97 e0       	ldi	r25, 0x07	; 7
    1a0c:	01 97       	sbiw	r24, 0x01	; 1
    1a0e:	f1 f7       	brne	.-4      	; 0x1a0c <LCD_DisplayCharacter+0xe8>
    1a10:	00 c0       	rjmp	.+0      	; 0x1a12 <LCD_DisplayCharacter+0xee>
    1a12:	00 00       	nop
    1a14:	40 e0       	ldi	r20, 0x00	; 0
    1a16:	62 e0       	ldi	r22, 0x02	; 2
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <GPIO_WritePin>
    1a1e:	8f ec       	ldi	r24, 0xCF	; 207
    1a20:	97 e0       	ldi	r25, 0x07	; 7
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	f1 f7       	brne	.-4      	; 0x1a22 <LCD_DisplayCharacter+0xfe>
    1a26:	00 c0       	rjmp	.+0      	; 0x1a28 <LCD_DisplayCharacter+0x104>
    1a28:	00 00       	nop
    1a2a:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <col_global>
    1a2e:	8f 5f       	subi	r24, 0xFF	; 255
    1a30:	80 93 33 06 	sts	0x0633, r24	; 0x800633 <col_global>
    1a34:	84 31       	cpi	r24, 0x14	; 20
    1a36:	59 f4       	brne	.+22     	; 0x1a4e <LCD_DisplayCharacter+0x12a>
    1a38:	80 91 34 06 	lds	r24, 0x0634	; 0x800634 <row_global>
    1a3c:	8f 5f       	subi	r24, 0xFF	; 255
    1a3e:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <row_global>
    1a42:	10 92 33 06 	sts	0x0633, r1	; 0x800633 <col_global>
    1a46:	84 31       	cpi	r24, 0x14	; 20
    1a48:	11 f4       	brne	.+4      	; 0x1a4e <LCD_DisplayCharacter+0x12a>
    1a4a:	10 92 34 06 	sts	0x0634, r1	; 0x800634 <row_global>
    1a4e:	df 91       	pop	r29
    1a50:	cf 91       	pop	r28
    1a52:	08 95       	ret

00001a54 <LCD_DisplayString>:
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	8c 01       	movw	r16, r24
    1a5c:	c0 e0       	ldi	r28, 0x00	; 0
    1a5e:	03 c0       	rjmp	.+6      	; 0x1a66 <LCD_DisplayString+0x12>
    1a60:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    1a64:	cf 5f       	subi	r28, 0xFF	; 255
    1a66:	f8 01       	movw	r30, r16
    1a68:	ec 0f       	add	r30, r28
    1a6a:	f1 1d       	adc	r31, r1
    1a6c:	80 81       	ld	r24, Z
    1a6e:	81 11       	cpse	r24, r1
    1a70:	f7 cf       	rjmp	.-18     	; 0x1a60 <LCD_DisplayString+0xc>
    1a72:	cf 91       	pop	r28
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	08 95       	ret

00001a7a <LCD_MoveCursor>:
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	61 f0       	breq	.+24     	; 0x1a96 <LCD_MoveCursor+0x1c>
    1a7e:	28 f0       	brcs	.+10     	; 0x1a8a <LCD_MoveCursor+0x10>
    1a80:	82 30       	cpi	r24, 0x02	; 2
    1a82:	89 f0       	breq	.+34     	; 0x1aa6 <LCD_MoveCursor+0x2c>
    1a84:	83 30       	cpi	r24, 0x03	; 3
    1a86:	b9 f0       	breq	.+46     	; 0x1ab6 <LCD_MoveCursor+0x3c>
    1a88:	1d c0       	rjmp	.+58     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1a8a:	60 93 33 06 	sts	0x0633, r22	; 0x800633 <col_global>
    1a8e:	10 92 34 06 	sts	0x0634, r1	; 0x800634 <row_global>
    1a92:	96 2f       	mov	r25, r22
    1a94:	17 c0       	rjmp	.+46     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1a96:	90 e4       	ldi	r25, 0x40	; 64
    1a98:	96 0f       	add	r25, r22
    1a9a:	60 93 33 06 	sts	0x0633, r22	; 0x800633 <col_global>
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <row_global>
    1aa4:	0f c0       	rjmp	.+30     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1aa6:	94 e1       	ldi	r25, 0x14	; 20
    1aa8:	96 0f       	add	r25, r22
    1aaa:	60 93 33 06 	sts	0x0633, r22	; 0x800633 <col_global>
    1aae:	82 e0       	ldi	r24, 0x02	; 2
    1ab0:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <row_global>
    1ab4:	07 c0       	rjmp	.+14     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1ab6:	94 e5       	ldi	r25, 0x54	; 84
    1ab8:	96 0f       	add	r25, r22
    1aba:	60 93 33 06 	sts	0x0633, r22	; 0x800633 <col_global>
    1abe:	83 e0       	ldi	r24, 0x03	; 3
    1ac0:	80 93 34 06 	sts	0x0634, r24	; 0x800634 <row_global>
    1ac4:	89 2f       	mov	r24, r25
    1ac6:	80 68       	ori	r24, 0x80	; 128
    1ac8:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1acc:	08 95       	ret

00001ace <LCD_DisplayStringRowCol>:
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	ec 01       	movw	r28, r24
    1ad4:	86 2f       	mov	r24, r22
    1ad6:	64 2f       	mov	r22, r20
    1ad8:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
    1adc:	ce 01       	movw	r24, r28
    1ade:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <LCD_ClearScreen>:
    1ae8:	10 92 33 06 	sts	0x0633, r1	; 0x800633 <col_global>
    1aec:	10 92 34 06 	sts	0x0634, r1	; 0x800634 <row_global>
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1af6:	08 95       	ret

00001af8 <LCD_intToString>:




void LCD_intToString(uint32 data)
{
    1af8:	cf 93       	push	r28
    1afa:	df 93       	push	r29
    1afc:	cd b7       	in	r28, 0x3d	; 61
    1afe:	de b7       	in	r29, 0x3e	; 62
    1b00:	61 97       	sbiw	r28, 0x11	; 17
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	de bf       	out	0x3e, r29	; 62
    1b08:	0f be       	out	0x3f, r0	; 63
    1b0a:	cd bf       	out	0x3d, r28	; 61
    1b0c:	dc 01       	movw	r26, r24
    1b0e:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1b10:	4a e0       	ldi	r20, 0x0A	; 10
    1b12:	be 01       	movw	r22, r28
    1b14:	6f 5f       	subi	r22, 0xFF	; 255
    1b16:	7f 4f       	sbci	r23, 0xFF	; 255
    1b18:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <__itoa_ncheck>
	 uint8 string_buff[17];// I write char not sint8_t(signed char ) to avoid warning
	 itoa(data , string_buff , 10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
	 LCD_DisplayString( (uint8_t *)string_buff);
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	01 96       	adiw	r24, 0x01	; 1
    1b20:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
}
    1b24:	61 96       	adiw	r28, 0x11	; 17
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	f8 94       	cli
    1b2a:	de bf       	out	0x3e, r29	; 62
    1b2c:	0f be       	out	0x3f, r0	; 63
    1b2e:	cd bf       	out	0x3d, r28	; 61
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	08 95       	ret

00001b36 <NTC_GetTemperature>:
#include "../../MCAL/ADC/ADC_interface.h"
#include <math.h>


uint8 NTC_GetTemperature(void)
{
    1b36:	8f 92       	push	r8
    1b38:	9f 92       	push	r9
    1b3a:	af 92       	push	r10
    1b3c:	bf 92       	push	r11
    1b3e:	cf 92       	push	r12
    1b40:	df 92       	push	r13
    1b42:	ef 92       	push	r14
    1b44:	ff 92       	push	r15
    uint16 V_out = ADC_ReadChannelSingleConvertion(NTC_PIN);
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	0e 94 1c 11 	call	0x2238	; 0x2238 <ADC_ReadChannelSingleConvertion>
    /*  Apply voltage divider to get Current resistance for NTC     */
    float32 R1 = R2 * ( (ADC_MAX_VALUE / (float32)V_out) - 1.0 ) ;
    1b4c:	bc 01       	movw	r22, r24
    1b4e:	80 e0       	ldi	r24, 0x00	; 0
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	0e 94 91 14 	call	0x2922	; 0x2922 <__floatunsisf>
    1b56:	9b 01       	movw	r18, r22
    1b58:	ac 01       	movw	r20, r24
    1b5a:	60 e0       	ldi	r22, 0x00	; 0
    1b5c:	70 ec       	ldi	r23, 0xC0	; 192
    1b5e:	8f e7       	ldi	r24, 0x7F	; 127
    1b60:	94 e4       	ldi	r25, 0x44	; 68
    1b62:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <__divsf3>
    1b66:	20 e0       	ldi	r18, 0x00	; 0
    1b68:	30 e0       	ldi	r19, 0x00	; 0
    1b6a:	40 e8       	ldi	r20, 0x80	; 128
    1b6c:	5f e3       	ldi	r21, 0x3F	; 63
    1b6e:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
    1b72:	20 e0       	ldi	r18, 0x00	; 0
    1b74:	30 e4       	ldi	r19, 0x40	; 64
    1b76:	4c e1       	ldi	r20, 0x1C	; 28
    1b78:	56 e4       	ldi	r21, 0x46	; 70
    1b7a:	0e 94 6f 15 	call	0x2ade	; 0x2ade <__mulsf3>
    float32 LogR1 = log(R1) ;
    1b7e:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <log>
    1b82:	6b 01       	movw	r12, r22
    1b84:	7c 01       	movw	r14, r24
    float32 T = (1.0 / ( C1 + (C2 *LogR1) + (C3 * LogR1 * LogR1 * LogR1) ) ) ;
    1b86:	26 ed       	ldi	r18, 0xD6	; 214
    1b88:	34 e6       	ldi	r19, 0x64	; 100
    1b8a:	49 e7       	ldi	r20, 0x79	; 121
    1b8c:	59 e3       	ldi	r21, 0x39	; 57
    1b8e:	0e 94 6f 15 	call	0x2ade	; 0x2ade <__mulsf3>
    1b92:	2b ec       	ldi	r18, 0xCB	; 203
    1b94:	38 e4       	ldi	r19, 0x48	; 72
    1b96:	44 e8       	ldi	r20, 0x84	; 132
    1b98:	5a e3       	ldi	r21, 0x3A	; 58
    1b9a:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    1b9e:	4b 01       	movw	r8, r22
    1ba0:	5c 01       	movw	r10, r24
    1ba2:	2c e6       	ldi	r18, 0x6C	; 108
    1ba4:	3f ec       	ldi	r19, 0xCF	; 207
    1ba6:	48 e5       	ldi	r20, 0x58	; 88
    1ba8:	54 e3       	ldi	r21, 0x34	; 52
    1baa:	c7 01       	movw	r24, r14
    1bac:	b6 01       	movw	r22, r12
    1bae:	0e 94 6f 15 	call	0x2ade	; 0x2ade <__mulsf3>
    1bb2:	9b 01       	movw	r18, r22
    1bb4:	ac 01       	movw	r20, r24
    1bb6:	c7 01       	movw	r24, r14
    1bb8:	b6 01       	movw	r22, r12
    1bba:	0e 94 6f 15 	call	0x2ade	; 0x2ade <__mulsf3>
    1bbe:	9b 01       	movw	r18, r22
    1bc0:	ac 01       	movw	r20, r24
    1bc2:	c7 01       	movw	r24, r14
    1bc4:	b6 01       	movw	r22, r12
    1bc6:	0e 94 6f 15 	call	0x2ade	; 0x2ade <__mulsf3>
    1bca:	9b 01       	movw	r18, r22
    1bcc:	ac 01       	movw	r20, r24
    1bce:	c5 01       	movw	r24, r10
    1bd0:	b4 01       	movw	r22, r8
    1bd2:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    1bd6:	9b 01       	movw	r18, r22
    1bd8:	ac 01       	movw	r20, r24
    1bda:	60 e0       	ldi	r22, 0x00	; 0
    1bdc:	70 e0       	ldi	r23, 0x00	; 0
    1bde:	80 e8       	ldi	r24, 0x80	; 128
    1be0:	9f e3       	ldi	r25, 0x3F	; 63
    1be2:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <__divsf3>
    T -= 273.15 ;
    1be6:	23 e3       	ldi	r18, 0x33	; 51
    1be8:	33 e9       	ldi	r19, 0x93	; 147
    1bea:	48 e8       	ldi	r20, 0x88	; 136
    1bec:	53 e4       	ldi	r21, 0x43	; 67
    1bee:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
    return T ;
    1bf2:	0e 94 62 14 	call	0x28c4	; 0x28c4 <__fixunssfsi>
    1bf6:	86 2f       	mov	r24, r22
}
    1bf8:	ff 90       	pop	r15
    1bfa:	ef 90       	pop	r14
    1bfc:	df 90       	pop	r13
    1bfe:	cf 90       	pop	r12
    1c00:	bf 90       	pop	r11
    1c02:	af 90       	pop	r10
    1c04:	9f 90       	pop	r9
    1c06:	8f 90       	pop	r8
    1c08:	08 95       	ret

00001c0a <T_T3_Catch_Update_Temp>:
{
	
	while(1)
	{
		/*	Read Current temperature sensor value*/
		Current_Temp = NTC_GetTemperature();
    1c0a:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <NTC_GetTemperature>
    1c0e:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <Current_Temp>
		
		/*	Check if current temperature >= Threshold temperature*/
		if(Current_Temp >= thresold_Temp )
    1c12:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <thresold_Temp>
    1c16:	89 17       	cp	r24, r25
    1c18:	48 f0       	brcs	.+18     	; 0x1c2c <T_T3_Catch_Update_Temp+0x22>
		{
			/*	set event of exceeding temperature	*/
			xEventGroupSetBits(egEvents,ExceedTemperature);
    1c1a:	61 e0       	ldi	r22, 0x01	; 1
    1c1c:	70 e0       	ldi	r23, 0x00	; 0
    1c1e:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1c22:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1c26:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
    1c2a:	08 c0       	rjmp	.+16     	; 0x1c3c <T_T3_Catch_Update_Temp+0x32>
		}
		else
		{
			/*	Clear event of exceeding temperature	*/
			xEventGroupClearBits(egEvents,ExceedTemperature);
    1c2c:	61 e0       	ldi	r22, 0x01	; 1
    1c2e:	70 e0       	ldi	r23, 0x00	; 0
    1c30:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1c34:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1c38:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>

		}

		/*	take mutex to access LCD shared resource*/
		if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 100 ) == pdTRUE )
    1c3c:	20 e0       	ldi	r18, 0x00	; 0
    1c3e:	44 e6       	ldi	r20, 0x64	; 100
    1c40:	50 e0       	ldi	r21, 0x00	; 0
    1c42:	60 e0       	ldi	r22, 0x00	; 0
    1c44:	70 e0       	ldi	r23, 0x00	; 0
    1c46:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1c4a:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1c4e:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1c52:	81 30       	cpi	r24, 0x01	; 1
    1c54:	f9 f4       	brne	.+62     	; 0x1c94 <T_T3_Catch_Update_Temp+0x8a>
		{
			/*	Dispalay value of current Temperature in LCD */
			LCD_MoveCursor(0,10);
    1c56:	6a e0       	ldi	r22, 0x0A	; 10
    1c58:	80 e0       	ldi	r24, 0x00	; 0
    1c5a:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
			LCD_intToString(Current_Temp);
    1c5e:	60 91 41 06 	lds	r22, 0x0641	; 0x800641 <Current_Temp>
    1c62:	70 e0       	ldi	r23, 0x00	; 0
    1c64:	80 e0       	ldi	r24, 0x00	; 0
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
			if(Current_Temp < 100)
    1c6c:	80 91 41 06 	lds	r24, 0x0641	; 0x800641 <Current_Temp>
    1c70:	84 36       	cpi	r24, 0x64	; 100
    1c72:	20 f4       	brcc	.+8      	; 0x1c7c <T_T3_Catch_Update_Temp+0x72>
			{
				LCD_DisplayString((uint8 *)" ");
    1c74:	89 ee       	ldi	r24, 0xE9	; 233
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
			}
			// USART_SendStringPolling((uint8 *)"ADC update lcd\r");
			xSemaphoreGive( xMutexLCD );
    1c7c:	20 e0       	ldi	r18, 0x00	; 0
    1c7e:	40 e0       	ldi	r20, 0x00	; 0
    1c80:	50 e0       	ldi	r21, 0x00	; 0
    1c82:	60 e0       	ldi	r22, 0x00	; 0
    1c84:	70 e0       	ldi	r23, 0x00	; 0
    1c86:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1c8a:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1c8e:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1c92:	04 c0       	rjmp	.+8      	; 0x1c9c <T_T3_Catch_Update_Temp+0x92>
		}
		/*	Failed to take mutex*/
		else
		{
			/*	tell that failled to update LCD	*/
			USART_SendStringPolling((uint8 *)"ADC Failed update lcd\r");
    1c94:	87 e7       	ldi	r24, 0x77	; 119
    1c96:	90 e0       	ldi	r25, 0x00	; 0
    1c98:	0e 94 66 13 	call	0x26cc	; 0x26cc <USART_SendStringPolling>
		}

		vTaskDelay(500);/*	As I want to take new Temperature Value every half second	*/
    1c9c:	84 ef       	ldi	r24, 0xF4	; 244
    1c9e:	91 e0       	ldi	r25, 0x01	; 1
    1ca0:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskDelay>
	}
    1ca4:	b2 cf       	rjmp	.-156    	; 0x1c0a <T_T3_Catch_Update_Temp>

00001ca6 <T_T4_UART_listen>:
}


void T_T4_UART_listen(void * pvparam)
{
    1ca6:	cf 93       	push	r28
    1ca8:	df 93       	push	r29
    1caa:	00 d0       	rcall	.+0      	; 0x1cac <T_T4_UART_listen+0x6>
    1cac:	00 d0       	rcall	.+0      	; 0x1cae <T_T4_UART_listen+0x8>
    1cae:	1f 92       	push	r1
    1cb0:	cd b7       	in	r28, 0x3d	; 61
    1cb2:	de b7       	in	r29, 0x3e	; 62
	
	uint8 u8Ind = 0;
	uint8 txMsg_UART[4] ={};
    1cb4:	19 82       	std	Y+1, r1	; 0x01
    1cb6:	1a 82       	std	Y+2, r1	; 0x02
    1cb8:	1b 82       	std	Y+3, r1	; 0x03
    1cba:	1c 82       	std	Y+4, r1	; 0x04
	uint8 u8Data = 0;
    1cbc:	1d 82       	std	Y+5, r1	; 0x05
	boolean update_thresould_temp = FALSE ;
    1cbe:	10 e0       	ldi	r17, 0x00	; 0


void T_T4_UART_listen(void * pvparam)
{
	
	uint8 u8Ind = 0;
    1cc0:	00 e0       	ldi	r16, 0x00	; 0
    1cc2:	04 c0       	rjmp	.+8      	; 0x1ccc <T_T4_UART_listen+0x26>
			
			
			
			if(u8Data == 'G') /*	Will update flag of Threshold Temperature */
			{
				update_thresould_temp = TRUE ;
    1cc4:	11 e0       	ldi	r17, 0x01	; 1
    1cc6:	02 c0       	rjmp	.+4      	; 0x1ccc <T_T4_UART_listen+0x26>
				update_thresould_temp = FALSE ;
				u8Ind = 0;	
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'C')) /*	Cancel new threshold temperature value*/
			{
				update_thresould_temp = FALSE ;
    1cc8:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;
    1cca:	00 e0       	ldi	r16, 0x00	; 0
	uint8 txMsg_UART[4] ={};
	uint8 u8Data = 0;
	boolean update_thresould_temp = FALSE ;
	while(1){
		/*	Check if received any new data */
		if(UART_receiveByteUnblocking(&u8Data)){
    1ccc:	ce 01       	movw	r24, r28
    1cce:	05 96       	adiw	r24, 0x05	; 5
    1cd0:	0e 94 7a 13 	call	0x26f4	; 0x26f4 <UART_receiveByteUnblocking>
    1cd4:	88 23       	and	r24, r24
    1cd6:	d1 f3       	breq	.-12     	; 0x1ccc <T_T4_UART_listen+0x26>
			
			
			
			if(u8Data == 'G') /*	Will update flag of Threshold Temperature */
    1cd8:	8d 81       	ldd	r24, Y+5	; 0x05
    1cda:	87 34       	cpi	r24, 0x47	; 71
    1cdc:	99 f3       	breq	.-26     	; 0x1cc4 <T_T4_UART_listen+0x1e>
			{
				update_thresould_temp = TRUE ;
			}
			else if( (update_thresould_temp == TRUE) && ((u8Data >= '0') && (u8Data <= '9')) )
    1cde:	11 30       	cpi	r17, 0x01	; 1
    1ce0:	69 f4       	brne	.+26     	; 0x1cfc <T_T4_UART_listen+0x56>
    1ce2:	90 ed       	ldi	r25, 0xD0	; 208
    1ce4:	98 0f       	add	r25, r24
    1ce6:	9a 30       	cpi	r25, 0x0A	; 10
    1ce8:	48 f4       	brcc	.+18     	; 0x1cfc <T_T4_UART_listen+0x56>
			{
				txMsg_UART[u8Ind] = u8Data;
    1cea:	e1 e0       	ldi	r30, 0x01	; 1
    1cec:	f0 e0       	ldi	r31, 0x00	; 0
    1cee:	ec 0f       	add	r30, r28
    1cf0:	fd 1f       	adc	r31, r29
    1cf2:	e0 0f       	add	r30, r16
    1cf4:	f1 1d       	adc	r31, r1
    1cf6:	80 83       	st	Z, r24
				u8Ind++;
    1cf8:	0f 5f       	subi	r16, 0xFF	; 255
    1cfa:	e8 cf       	rjmp	.-48     	; 0x1ccc <T_T4_UART_listen+0x26>
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'K')) /*	Accept new threshold temperature value*/
    1cfc:	11 30       	cpi	r17, 0x01	; 1
    1cfe:	c1 f4       	brne	.+48     	; 0x1d30 <T_T4_UART_listen+0x8a>
    1d00:	8b 34       	cpi	r24, 0x4B	; 75
    1d02:	b1 f4       	brne	.+44     	; 0x1d30 <T_T4_UART_listen+0x8a>
			{
				txMsg_UART[u8Ind] = 0;
    1d04:	e1 e0       	ldi	r30, 0x01	; 1
    1d06:	f0 e0       	ldi	r31, 0x00	; 0
    1d08:	ec 0f       	add	r30, r28
    1d0a:	fd 1f       	adc	r31, r29
    1d0c:	e0 0f       	add	r30, r16
    1d0e:	f1 1d       	adc	r31, r1
    1d10:	10 82       	st	Z, r1
				xQueueSend(MessQUart_Thres_temp, txMsg_UART, portMAX_DELAY);
    1d12:	20 e0       	ldi	r18, 0x00	; 0
    1d14:	4f ef       	ldi	r20, 0xFF	; 255
    1d16:	5f ef       	ldi	r21, 0xFF	; 255
    1d18:	be 01       	movw	r22, r28
    1d1a:	6f 5f       	subi	r22, 0xFF	; 255
    1d1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1d1e:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <MessQUart_Thres_temp>
    1d22:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <MessQUart_Thres_temp+0x1>
    1d26:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
				update_thresould_temp = FALSE ;
    1d2a:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;	
    1d2c:	00 e0       	ldi	r16, 0x00	; 0
    1d2e:	ce cf       	rjmp	.-100    	; 0x1ccc <T_T4_UART_listen+0x26>
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'C')) /*	Cancel new threshold temperature value*/
    1d30:	11 30       	cpi	r17, 0x01	; 1
    1d32:	11 f4       	brne	.+4      	; 0x1d38 <T_T4_UART_listen+0x92>
    1d34:	83 34       	cpi	r24, 0x43	; 67
    1d36:	41 f2       	breq	.-112    	; 0x1cc8 <T_T4_UART_listen+0x22>
			{
				update_thresould_temp = FALSE ;
				u8Ind = 0;
			}
			else if(u8Data == 'T') /*	Will toggle state of Alarm system*/
    1d38:	84 35       	cpi	r24, 0x54	; 84
    1d3a:	69 f4       	brne	.+26     	; 0x1d56 <T_T4_UART_listen+0xb0>
			{
				xQueueSend(MessMailuart_fireState, &u8Data, portMAX_DELAY);
    1d3c:	20 e0       	ldi	r18, 0x00	; 0
    1d3e:	4f ef       	ldi	r20, 0xFF	; 255
    1d40:	5f ef       	ldi	r21, 0xFF	; 255
    1d42:	be 01       	movw	r22, r28
    1d44:	6b 5f       	subi	r22, 0xFB	; 251
    1d46:	7f 4f       	sbci	r23, 0xFF	; 255
    1d48:	80 91 39 06 	lds	r24, 0x0639	; 0x800639 <MessMailuart_fireState>
    1d4c:	90 91 3a 06 	lds	r25, 0x063A	; 0x80063a <MessMailuart_fireState+0x1>
    1d50:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1d54:	bb cf       	rjmp	.-138    	; 0x1ccc <T_T4_UART_listen+0x26>
			}
			else if(u8Data == 'D') /*	Will Disbale Alarm system*/
    1d56:	84 34       	cpi	r24, 0x44	; 68
    1d58:	09 f0       	breq	.+2      	; 0x1d5c <T_T4_UART_listen+0xb6>
    1d5a:	b8 cf       	rjmp	.-144    	; 0x1ccc <T_T4_UART_listen+0x26>
			{
				xQueueSend(MessMailuart_fireState, &u8Data, portMAX_DELAY);
    1d5c:	20 e0       	ldi	r18, 0x00	; 0
    1d5e:	4f ef       	ldi	r20, 0xFF	; 255
    1d60:	5f ef       	ldi	r21, 0xFF	; 255
    1d62:	be 01       	movw	r22, r28
    1d64:	6b 5f       	subi	r22, 0xFB	; 251
    1d66:	7f 4f       	sbci	r23, 0xFF	; 255
    1d68:	80 91 39 06 	lds	r24, 0x0639	; 0x800639 <MessMailuart_fireState>
    1d6c:	90 91 3a 06 	lds	r25, 0x063A	; 0x80063a <MessMailuart_fireState+0x1>
    1d70:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1d74:	ab cf       	rjmp	.-170    	; 0x1ccc <T_T4_UART_listen+0x26>

00001d76 <T_T5_Update_LCD>:
	}
}


void T_T5_Update_LCD(void *pvparam)
{
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	00 d0       	rcall	.+0      	; 0x1d7c <T_T5_Update_LCD+0x6>
    1d7c:	00 d0       	rcall	.+0      	; 0x1d7e <T_T5_Update_LCD+0x8>
    1d7e:	1f 92       	push	r1
    1d80:	cd b7       	in	r28, 0x3d	; 61
    1d82:	de b7       	in	r29, 0x3e	; 62
	uint8 rxMsg_thresholdTemp[4] = {};
    1d84:	19 82       	std	Y+1, r1	; 0x01
    1d86:	1a 82       	std	Y+2, r1	; 0x02
    1d88:	1b 82       	std	Y+3, r1	; 0x03
    1d8a:	1c 82       	std	Y+4, r1	; 0x04
	uint8 rxmsg_fireState ;
	while(1)
	{
		/*	handle received thresould temperature value and display it */
		if(xQueueReceive(MessQUart_Thres_temp, rxMsg_thresholdTemp, 100))
    1d8c:	20 e0       	ldi	r18, 0x00	; 0
    1d8e:	44 e6       	ldi	r20, 0x64	; 100
    1d90:	50 e0       	ldi	r21, 0x00	; 0
    1d92:	be 01       	movw	r22, r28
    1d94:	6f 5f       	subi	r22, 0xFF	; 255
    1d96:	7f 4f       	sbci	r23, 0xFF	; 255
    1d98:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <MessQUart_Thres_temp>
    1d9c:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <MessQUart_Thres_temp+0x1>
    1da0:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1da4:	88 23       	and	r24, r24
    1da6:	09 f4       	brne	.+2      	; 0x1daa <T_T5_Update_LCD+0x34>
    1da8:	48 c0       	rjmp	.+144    	; 0x1e3a <T_T5_Update_LCD+0xc4>
		{
			thresold_Temp = rxMsg_thresholdTemp[0] - '0';
    1daa:	89 81       	ldd	r24, Y+1	; 0x01
    1dac:	80 53       	subi	r24, 0x30	; 48
			thresold_Temp *= 10 ;
    1dae:	88 0f       	add	r24, r24
    1db0:	98 2f       	mov	r25, r24
    1db2:	99 0f       	add	r25, r25
    1db4:	99 0f       	add	r25, r25
    1db6:	89 0f       	add	r24, r25
			thresold_Temp += rxMsg_thresholdTemp[1] - '0';
    1db8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dba:	89 0f       	add	r24, r25
    1dbc:	80 53       	subi	r24, 0x30	; 48
    1dbe:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <thresold_Temp>

			/*	Update Event state if thresold_Temp <= Current_Temp */
			if(thresold_Temp <= Current_Temp)
    1dc2:	90 91 41 06 	lds	r25, 0x0641	; 0x800641 <Current_Temp>
    1dc6:	98 17       	cp	r25, r24
    1dc8:	48 f0       	brcs	.+18     	; 0x1ddc <T_T5_Update_LCD+0x66>
			{
				/*	set event of exceeding temperature	*/
				xEventGroupSetBits(egEvents,ExceedTemperature);
    1dca:	61 e0       	ldi	r22, 0x01	; 1
    1dcc:	70 e0       	ldi	r23, 0x00	; 0
    1dce:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1dd2:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1dd6:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
    1dda:	08 c0       	rjmp	.+16     	; 0x1dec <T_T5_Update_LCD+0x76>
			}
			/*	No need to update threshold value	*/
			else
			{
				/*	Clear event of exceeding temperature	*/
				xEventGroupClearBits(egEvents,ExceedTemperature);
    1ddc:	61 e0       	ldi	r22, 0x01	; 1
    1dde:	70 e0       	ldi	r23, 0x00	; 0
    1de0:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1de4:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1de8:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
			}

			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 100 ) == pdTRUE )
    1dec:	20 e0       	ldi	r18, 0x00	; 0
    1dee:	44 e6       	ldi	r20, 0x64	; 100
    1df0:	50 e0       	ldi	r21, 0x00	; 0
    1df2:	60 e0       	ldi	r22, 0x00	; 0
    1df4:	70 e0       	ldi	r23, 0x00	; 0
    1df6:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1dfa:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1dfe:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e02:	81 30       	cpi	r24, 0x01	; 1
    1e04:	b1 f4       	brne	.+44     	; 0x1e32 <T_T5_Update_LCD+0xbc>
			{
				LCD_DisplayStringRowCol(rxMsg_thresholdTemp,1,16);
    1e06:	40 e1       	ldi	r20, 0x10	; 16
    1e08:	61 e0       	ldi	r22, 0x01	; 1
    1e0a:	ce 01       	movw	r24, r28
    1e0c:	01 96       	adiw	r24, 0x01	; 1
    1e0e:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
				USART_SendStringPolling((uint8 *)"Thre update lcd\r");
    1e12:	8e e8       	ldi	r24, 0x8E	; 142
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	0e 94 66 13 	call	0x26cc	; 0x26cc <USART_SendStringPolling>
				xSemaphoreGive( xMutexLCD );
    1e1a:	20 e0       	ldi	r18, 0x00	; 0
    1e1c:	40 e0       	ldi	r20, 0x00	; 0
    1e1e:	50 e0       	ldi	r21, 0x00	; 0
    1e20:	60 e0       	ldi	r22, 0x00	; 0
    1e22:	70 e0       	ldi	r23, 0x00	; 0
    1e24:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1e28:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1e2c:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1e30:	04 c0       	rjmp	.+8      	; 0x1e3a <T_T5_Update_LCD+0xc4>
			}
			else
			{
				USART_SendStringPolling((uint8 *)"thre Failed update lcd\r");
    1e32:	8f e9       	ldi	r24, 0x9F	; 159
    1e34:	90 e0       	ldi	r25, 0x00	; 0
    1e36:	0e 94 66 13 	call	0x26cc	; 0x26cc <USART_SendStringPolling>
		{

		}

		/*	handle state of firing system if it enabled or disabled and update lcd with this change	*/
		if(xQueueReceive(MessMailuart_fireState, &rxmsg_fireState, 100))
    1e3a:	20 e0       	ldi	r18, 0x00	; 0
    1e3c:	44 e6       	ldi	r20, 0x64	; 100
    1e3e:	50 e0       	ldi	r21, 0x00	; 0
    1e40:	be 01       	movw	r22, r28
    1e42:	6b 5f       	subi	r22, 0xFB	; 251
    1e44:	7f 4f       	sbci	r23, 0xFF	; 255
    1e46:	80 91 39 06 	lds	r24, 0x0639	; 0x800639 <MessMailuart_fireState>
    1e4a:	90 91 3a 06 	lds	r25, 0x063A	; 0x80063a <MessMailuart_fireState+0x1>
    1e4e:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e52:	88 23       	and	r24, r24
    1e54:	09 f4       	brne	.+2      	; 0x1e58 <T_T5_Update_LCD+0xe2>
    1e56:	9a cf       	rjmp	.-204    	; 0x1d8c <T_T5_Update_LCD+0x16>
		{
			/*	Disable state of fire system */
			if(rxmsg_fireState == 'D')
    1e58:	8d 81       	ldd	r24, Y+5	; 0x05
    1e5a:	84 34       	cpi	r24, 0x44	; 68
    1e5c:	51 f5       	brne	.+84     	; 0x1eb2 <T_T5_Update_LCD+0x13c>
			{
				AlarmState = FALSE ;
    1e5e:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <AlarmState>
				xEventGroupClearBits(egEvents,SystemFireState);
    1e62:	62 e0       	ldi	r22, 0x02	; 2
    1e64:	70 e0       	ldi	r23, 0x00	; 0
    1e66:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1e6a:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1e6e:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
				if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 400 ) == pdTRUE )
    1e72:	20 e0       	ldi	r18, 0x00	; 0
    1e74:	40 e9       	ldi	r20, 0x90	; 144
    1e76:	51 e0       	ldi	r21, 0x01	; 1
    1e78:	60 e0       	ldi	r22, 0x00	; 0
    1e7a:	70 e0       	ldi	r23, 0x00	; 0
    1e7c:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1e80:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1e84:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e88:	81 30       	cpi	r24, 0x01	; 1
    1e8a:	09 f0       	breq	.+2      	; 0x1e8e <T_T5_Update_LCD+0x118>
    1e8c:	7f cf       	rjmp	.-258    	; 0x1d8c <T_T5_Update_LCD+0x16>
				{
					LCD_DisplayStringRowCol((uint8 *)"D",2,13);	
    1e8e:	4d e0       	ldi	r20, 0x0D	; 13
    1e90:	62 e0       	ldi	r22, 0x02	; 2
    1e92:	87 eb       	ldi	r24, 0xB7	; 183
    1e94:	90 e0       	ldi	r25, 0x00	; 0
    1e96:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
					xSemaphoreGive( xMutexLCD );
    1e9a:	20 e0       	ldi	r18, 0x00	; 0
    1e9c:	40 e0       	ldi	r20, 0x00	; 0
    1e9e:	50 e0       	ldi	r21, 0x00	; 0
    1ea0:	60 e0       	ldi	r22, 0x00	; 0
    1ea2:	70 e0       	ldi	r23, 0x00	; 0
    1ea4:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1ea8:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1eac:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1eb0:	6d cf       	rjmp	.-294    	; 0x1d8c <T_T5_Update_LCD+0x16>
				{

				}
			}
			/*	Toggle state of fire system */
			else if(rxmsg_fireState == 'T')
    1eb2:	84 35       	cpi	r24, 0x54	; 84
    1eb4:	09 f0       	breq	.+2      	; 0x1eb8 <T_T5_Update_LCD+0x142>
    1eb6:	6a cf       	rjmp	.-300    	; 0x1d8c <T_T5_Update_LCD+0x16>
			{
				
				if(AlarmState == TRUE)
    1eb8:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <AlarmState>
    1ebc:	81 30       	cpi	r24, 0x01	; 1
    1ebe:	51 f5       	brne	.+84     	; 0x1f14 <T_T5_Update_LCD+0x19e>
				{
					AlarmState = FALSE ;
    1ec0:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <AlarmState>
					xEventGroupClearBits(egEvents,SystemFireState);
    1ec4:	62 e0       	ldi	r22, 0x02	; 2
    1ec6:	70 e0       	ldi	r23, 0x00	; 0
    1ec8:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1ecc:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1ed0:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
					if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 400 ) == pdTRUE )
    1ed4:	20 e0       	ldi	r18, 0x00	; 0
    1ed6:	40 e9       	ldi	r20, 0x90	; 144
    1ed8:	51 e0       	ldi	r21, 0x01	; 1
    1eda:	60 e0       	ldi	r22, 0x00	; 0
    1edc:	70 e0       	ldi	r23, 0x00	; 0
    1ede:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1ee2:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1ee6:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1eea:	81 30       	cpi	r24, 0x01	; 1
    1eec:	09 f0       	breq	.+2      	; 0x1ef0 <T_T5_Update_LCD+0x17a>
    1eee:	4e cf       	rjmp	.-356    	; 0x1d8c <T_T5_Update_LCD+0x16>
					{
						LCD_DisplayStringRowCol((uint8 *)"D",2,13);	
    1ef0:	4d e0       	ldi	r20, 0x0D	; 13
    1ef2:	62 e0       	ldi	r22, 0x02	; 2
    1ef4:	87 eb       	ldi	r24, 0xB7	; 183
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
						xSemaphoreGive( xMutexLCD );
    1efc:	20 e0       	ldi	r18, 0x00	; 0
    1efe:	40 e0       	ldi	r20, 0x00	; 0
    1f00:	50 e0       	ldi	r21, 0x00	; 0
    1f02:	60 e0       	ldi	r22, 0x00	; 0
    1f04:	70 e0       	ldi	r23, 0x00	; 0
    1f06:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1f0a:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1f0e:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1f12:	3c cf       	rjmp	.-392    	; 0x1d8c <T_T5_Update_LCD+0x16>
					else 
					{

					}
				}
				else if(AlarmState == FALSE)
    1f14:	81 11       	cpse	r24, r1
    1f16:	3a cf       	rjmp	.-396    	; 0x1d8c <T_T5_Update_LCD+0x16>
				{
					AlarmState = TRUE ;
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <AlarmState>
					xEventGroupSetBits(egEvents,SystemFireState);
    1f1e:	62 e0       	ldi	r22, 0x02	; 2
    1f20:	70 e0       	ldi	r23, 0x00	; 0
    1f22:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    1f26:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    1f2a:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
					if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 400 ) == pdTRUE )
    1f2e:	20 e0       	ldi	r18, 0x00	; 0
    1f30:	40 e9       	ldi	r20, 0x90	; 144
    1f32:	51 e0       	ldi	r21, 0x01	; 1
    1f34:	60 e0       	ldi	r22, 0x00	; 0
    1f36:	70 e0       	ldi	r23, 0x00	; 0
    1f38:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1f3c:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1f40:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1f44:	81 30       	cpi	r24, 0x01	; 1
    1f46:	09 f0       	breq	.+2      	; 0x1f4a <T_T5_Update_LCD+0x1d4>
    1f48:	21 cf       	rjmp	.-446    	; 0x1d8c <T_T5_Update_LCD+0x16>
					{
						LCD_DisplayStringRowCol((uint8 *)"E",2,13);	
    1f4a:	4d e0       	ldi	r20, 0x0D	; 13
    1f4c:	62 e0       	ldi	r22, 0x02	; 2
    1f4e:	85 e7       	ldi	r24, 0x75	; 117
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
						xSemaphoreGive( xMutexLCD );
    1f56:	20 e0       	ldi	r18, 0x00	; 0
    1f58:	40 e0       	ldi	r20, 0x00	; 0
    1f5a:	50 e0       	ldi	r21, 0x00	; 0
    1f5c:	60 e0       	ldi	r22, 0x00	; 0
    1f5e:	70 e0       	ldi	r23, 0x00	; 0
    1f60:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    1f64:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    1f68:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1f6c:	0f cf       	rjmp	.-482    	; 0x1d8c <T_T5_Update_LCD+0x16>

00001f6e <System_Init>:
}


void System_Init(void)
{
	LCD_init();
    1f6e:	0e 94 67 0c 	call	0x18ce	; 0x18ce <LCD_init>
	USART_Init();
    1f72:	0e 94 18 13 	call	0x2630	; 0x2630 <USART_Init>
    ADC_Init();
    1f76:	0e 94 bb 10 	call	0x2176	; 0x2176 <ADC_Init>
    GPIO_init();
    1f7a:	0e 94 c2 12 	call	0x2584	; 0x2584 <GPIO_init>
    1f7e:	08 95       	ret

00001f80 <LCD_MAINInit>:

}

void LCD_MAINInit(void)
{
	LCD_ClearScreen();
    1f80:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_ClearScreen>
	LCD_DisplayStringRowCol((uint8 *)"Cur Temp:    C",0,0);	
    1f84:	40 e0       	ldi	r20, 0x00	; 0
    1f86:	60 e0       	ldi	r22, 0x00	; 0
    1f88:	89 eb       	ldi	r24, 0xB9	; 185
    1f8a:	90 e0       	ldi	r25, 0x00	; 0
    1f8c:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	/*	Catch value for Temperature and Display it  */
	Current_Temp = NTC_GetTemperature();
    1f90:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <NTC_GetTemperature>
    1f94:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <Current_Temp>
	LCD_MoveCursor(0,10);
    1f98:	6a e0       	ldi	r22, 0x0A	; 10
    1f9a:	80 e0       	ldi	r24, 0x00	; 0
    1f9c:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	LCD_intToString(Current_Temp);
    1fa0:	60 91 41 06 	lds	r22, 0x0641	; 0x800641 <Current_Temp>
    1fa4:	70 e0       	ldi	r23, 0x00	; 0
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
	LCD_DisplayStringRowCol((uint8 *)"Threshold Temp:    C",1,0);	
    1fae:	40 e0       	ldi	r20, 0x00	; 0
    1fb0:	61 e0       	ldi	r22, 0x01	; 1
    1fb2:	88 ec       	ldi	r24, 0xC8	; 200
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	LCD_MoveCursor(1,16);
    1fba:	60 e1       	ldi	r22, 0x10	; 16
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	LCD_intToString(thresold_Temp);
    1fc2:	60 91 63 00 	lds	r22, 0x0063	; 0x800063 <thresold_Temp>
    1fc6:	70 e0       	ldi	r23, 0x00	; 0
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	90 e0       	ldi	r25, 0x00	; 0
    1fcc:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
	LCD_DisplayStringRowCol((uint8 *)"Alarm State: ",2,0);	
    1fd0:	40 e0       	ldi	r20, 0x00	; 0
    1fd2:	62 e0       	ldi	r22, 0x02	; 2
    1fd4:	8d ed       	ldi	r24, 0xDD	; 221
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	LCD_MoveCursor(2,13);
    1fdc:	6d e0       	ldi	r22, 0x0D	; 13
    1fde:	82 e0       	ldi	r24, 0x02	; 2
    1fe0:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	if(AlarmState == TRUE)
    1fe4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <AlarmState>
    1fe8:	81 30       	cpi	r24, 0x01	; 1
    1fea:	21 f4       	brne	.+8      	; 0x1ff4 <LCD_MAINInit+0x74>
	{
		LCD_DisplayCharacter('E');
    1fec:	85 e4       	ldi	r24, 0x45	; 69
    1fee:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    1ff2:	08 95       	ret
	}
	else 
	{
		LCD_DisplayCharacter('D');
    1ff4:	84 e4       	ldi	r24, 0x44	; 68
    1ff6:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    1ffa:	08 95       	ret

00001ffc <main>:

EventGroupHandle_t 	egEvents = NULL;
EventBits_t			ebValues = 0;

int main(void)
{
    1ffc:	af 92       	push	r10
    1ffe:	bf 92       	push	r11
    2000:	cf 92       	push	r12
    2002:	df 92       	push	r13
    2004:	ef 92       	push	r14
    2006:	ff 92       	push	r15
    2008:	0f 93       	push	r16

	System_Init();
    200a:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <System_Init>
	LCD_MAINInit();
    200e:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <LCD_MAINInit>
	
	xMutexLCD = xSemaphoreCreateMutex();
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	0e 94 6e 05 	call	0xadc	; 0xadc <xQueueCreateMutex>
    2018:	90 93 40 06 	sts	0x0640, r25	; 0x800640 <xMutexLCD+0x1>
    201c:	80 93 3f 06 	sts	0x063F, r24	; 0x80063f <xMutexLCD>
	// XFiresystemState_Semph = xSemaphoreCreateBinary();
	MessQUart_Thres_temp = xQueueCreate(3,3 * sizeof(uint8) );	
    2020:	40 e0       	ldi	r20, 0x00	; 0
    2022:	63 e0       	ldi	r22, 0x03	; 3
    2024:	83 e0       	ldi	r24, 0x03	; 3
    2026:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericCreate>
    202a:	90 93 3c 06 	sts	0x063C, r25	; 0x80063c <MessQUart_Thres_temp+0x1>
    202e:	80 93 3b 06 	sts	0x063B, r24	; 0x80063b <MessQUart_Thres_temp>
	MessMailuart_fireState = xQueueCreate(3, sizeof(uint8));
    2032:	40 e0       	ldi	r20, 0x00	; 0
    2034:	61 e0       	ldi	r22, 0x01	; 1
    2036:	83 e0       	ldi	r24, 0x03	; 3
    2038:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericCreate>
    203c:	90 93 3a 06 	sts	0x063A, r25	; 0x80063a <MessMailuart_fireState+0x1>
    2040:	80 93 39 06 	sts	0x0639, r24	; 0x800639 <MessMailuart_fireState>

	egEvents = xEventGroupCreate();
    2044:	0e 94 89 00 	call	0x112	; 0x112 <xEventGroupCreate>
    2048:	90 93 38 06 	sts	0x0638, r25	; 0x800638 <egEvents+0x1>
    204c:	80 93 37 06 	sts	0x0637, r24	; 0x800637 <egEvents>



	xTaskCreate(T_T6_SwitchBetHaz_Nor, "Emergency_normal", 200, NULL, 4, NULL);
    2050:	a1 2c       	mov	r10, r1
    2052:	b1 2c       	mov	r11, r1
    2054:	c1 2c       	mov	r12, r1
    2056:	d1 2c       	mov	r13, r1
    2058:	e1 2c       	mov	r14, r1
    205a:	f1 2c       	mov	r15, r1
    205c:	04 e0       	ldi	r16, 0x04	; 4
    205e:	20 e0       	ldi	r18, 0x00	; 0
    2060:	30 e0       	ldi	r19, 0x00	; 0
    2062:	48 ec       	ldi	r20, 0xC8	; 200
    2064:	50 e0       	ldi	r21, 0x00	; 0
    2066:	6b ee       	ldi	r22, 0xEB	; 235
    2068:	70 e0       	ldi	r23, 0x00	; 0
    206a:	87 e7       	ldi	r24, 0x77	; 119
    206c:	90 e1       	ldi	r25, 0x10	; 16
    206e:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T3_Catch_Update_Temp, "Update Current Temp", 100, &Current_Temp, 3, NULL);
    2072:	03 e0       	ldi	r16, 0x03	; 3
    2074:	21 e4       	ldi	r18, 0x41	; 65
    2076:	36 e0       	ldi	r19, 0x06	; 6
    2078:	44 e6       	ldi	r20, 0x64	; 100
    207a:	50 e0       	ldi	r21, 0x00	; 0
    207c:	6c ef       	ldi	r22, 0xFC	; 252
    207e:	70 e0       	ldi	r23, 0x00	; 0
    2080:	85 e0       	ldi	r24, 0x05	; 5
    2082:	9e e0       	ldi	r25, 0x0E	; 14
    2084:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T5_Update_LCD, "update Threshold_state", 100, NULL, 2, NULL);
    2088:	02 e0       	ldi	r16, 0x02	; 2
    208a:	20 e0       	ldi	r18, 0x00	; 0
    208c:	30 e0       	ldi	r19, 0x00	; 0
    208e:	44 e6       	ldi	r20, 0x64	; 100
    2090:	50 e0       	ldi	r21, 0x00	; 0
    2092:	60 e1       	ldi	r22, 0x10	; 16
    2094:	71 e0       	ldi	r23, 0x01	; 1
    2096:	8b eb       	ldi	r24, 0xBB	; 187
    2098:	9e e0       	ldi	r25, 0x0E	; 14
    209a:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T4_UART_listen, "Recieve UART Mess", 100, NULL, 1, NULL);
    209e:	01 e0       	ldi	r16, 0x01	; 1
    20a0:	20 e0       	ldi	r18, 0x00	; 0
    20a2:	30 e0       	ldi	r19, 0x00	; 0
    20a4:	44 e6       	ldi	r20, 0x64	; 100
    20a6:	50 e0       	ldi	r21, 0x00	; 0
    20a8:	67 e2       	ldi	r22, 0x27	; 39
    20aa:	71 e0       	ldi	r23, 0x01	; 1
    20ac:	83 e5       	ldi	r24, 0x53	; 83
    20ae:	9e e0       	ldi	r25, 0x0E	; 14
    20b0:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>

	xEventGroupSetBits(egEvents,SystemFireState); // As I by defualt make system Fire Enable
    20b4:	62 e0       	ldi	r22, 0x02	; 2
    20b6:	70 e0       	ldi	r23, 0x00	; 0
    20b8:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    20bc:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    20c0:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>

	vTaskStartScheduler();
    20c4:	0e 94 ff 07 	call	0xffe	; 0xffe <vTaskStartScheduler>

	return 0 ;
}
    20c8:	80 e0       	ldi	r24, 0x00	; 0
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	0f 91       	pop	r16
    20ce:	ff 90       	pop	r15
    20d0:	ef 90       	pop	r14
    20d2:	df 90       	pop	r13
    20d4:	cf 90       	pop	r12
    20d6:	bf 90       	pop	r11
    20d8:	af 90       	pop	r10
    20da:	08 95       	ret

000020dc <F_fireStateScreen>:
}


void F_fireStateScreen(void)
{
	LCD_ClearScreen();
    20dc:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_ClearScreen>
	LCD_DisplayStringRowCol((uint8 *)"!! ALARM !!", 1 , 4);
    20e0:	44 e0       	ldi	r20, 0x04	; 4
    20e2:	61 e0       	ldi	r22, 0x01	; 1
    20e4:	89 e3       	ldi	r24, 0x39	; 57
    20e6:	91 e0       	ldi	r25, 0x01	; 1
    20e8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
    20ec:	08 95       	ret

000020ee <T_T6_SwitchBetHaz_Nor>:
}


void T_T6_SwitchBetHaz_Nor(void *pvparam)
{
	boolean Mutex_Taken_Already = FALSE ;
    20ee:	c0 e0       	ldi	r28, 0x00	; 0
	while (1)
	{
		ebValues = xEventGroupWaitBits(egEvents,
    20f0:	04 e6       	ldi	r16, 0x64	; 100
    20f2:	10 e0       	ldi	r17, 0x00	; 0
    20f4:	21 e0       	ldi	r18, 0x01	; 1
    20f6:	40 e0       	ldi	r20, 0x00	; 0
    20f8:	63 e0       	ldi	r22, 0x03	; 3
    20fa:	70 e0       	ldi	r23, 0x00	; 0
    20fc:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <egEvents>
    2100:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <egEvents+0x1>
    2104:	0e 94 9c 00 	call	0x138	; 0x138 <xEventGroupWaitBits>
    2108:	90 93 36 06 	sts	0x0636, r25	; 0x800636 <ebValues+0x1>
    210c:	80 93 35 06 	sts	0x0635, r24	; 0x800635 <ebValues>
										(SystemFireState | ExceedTemperature),
										0,
										1,//AND
										100);

		if( ( ebValues & (SystemFireState | ExceedTemperature) )== (SystemFireState | ExceedTemperature) )
    2110:	83 70       	andi	r24, 0x03	; 3
    2112:	99 27       	eor	r25, r25
    2114:	03 97       	sbiw	r24, 0x03	; 3
    2116:	89 f4       	brne	.+34     	; 0x213a <T_T6_SwitchBetHaz_Nor+0x4c>
		{
			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 1000 ) == pdTRUE )
    2118:	20 e0       	ldi	r18, 0x00	; 0
    211a:	48 ee       	ldi	r20, 0xE8	; 232
    211c:	53 e0       	ldi	r21, 0x03	; 3
    211e:	60 e0       	ldi	r22, 0x00	; 0
    2120:	70 e0       	ldi	r23, 0x00	; 0
    2122:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    2126:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    212a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    212e:	81 30       	cpi	r24, 0x01	; 1
    2130:	a1 f4       	brne	.+40     	; 0x215a <T_T6_SwitchBetHaz_Nor+0x6c>
			{
				Mutex_Taken_Already = TRUE ;
				F_fireStateScreen();
    2132:	0e 94 6e 10 	call	0x20dc	; 0x20dc <F_fireStateScreen>

		if( ( ebValues & (SystemFireState | ExceedTemperature) )== (SystemFireState | ExceedTemperature) )
		{
			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 1000 ) == pdTRUE )
			{
				Mutex_Taken_Already = TRUE ;
    2136:	c1 e0       	ldi	r28, 0x01	; 1
    2138:	10 c0       	rjmp	.+32     	; 0x215a <T_T6_SwitchBetHaz_Nor+0x6c>
			// GPIO_TogglePin(PORTC_ID,PIN0_ID);
			// vTaskDelay(300);
		}
		else
		{
			if(Mutex_Taken_Already == TRUE)
    213a:	c1 30       	cpi	r28, 0x01	; 1
    213c:	71 f4       	brne	.+28     	; 0x215a <T_T6_SwitchBetHaz_Nor+0x6c>
			{
				Mutex_Taken_Already = FALSE ;
				xSemaphoreGive( xMutexLCD );
    213e:	20 e0       	ldi	r18, 0x00	; 0
    2140:	40 e0       	ldi	r20, 0x00	; 0
    2142:	50 e0       	ldi	r21, 0x00	; 0
    2144:	60 e0       	ldi	r22, 0x00	; 0
    2146:	70 e0       	ldi	r23, 0x00	; 0
    2148:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <xMutexLCD>
    214c:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <xMutexLCD+0x1>
    2150:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
				/*	Should be here to avoid continous update LCD without go from Fire state to normal state*/
				LCD_MAINInit();	
    2154:	0e 94 c0 0f 	call	0x1f80	; 0x1f80 <LCD_MAINInit>
		}
		else
		{
			if(Mutex_Taken_Already == TRUE)
			{
				Mutex_Taken_Already = FALSE ;
    2158:	c0 e0       	ldi	r28, 0x00	; 0
				LCD_MAINInit();	
			}
			// GPIO_TogglePin(PORTC_ID,PIN1_ID);
			// vTaskDelay(300);
		}
		vTaskDelay(500);
    215a:	84 ef       	ldi	r24, 0xF4	; 244
    215c:	91 e0       	ldi	r25, 0x01	; 1
    215e:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskDelay>
	}
    2162:	c6 cf       	rjmp	.-116    	; 0x20f0 <T_T6_SwitchBetHaz_Nor+0x2>

00002164 <ADC_OnlyStartConversionGeneral>:
    return ADC_conversion_value;
}

void ADC_FreeRunningStart (uint8 Channel_NUM)
{
    ADC_OnlyStartConversionGeneral(Channel_NUM);
    2164:	87 70       	andi	r24, 0x07	; 7
    2166:	97 b1       	in	r25, 0x07	; 7
    2168:	90 7e       	andi	r25, 0xE0	; 224
    216a:	89 2b       	or	r24, r25
    216c:	87 b9       	out	0x07, r24	; 7
    216e:	86 b1       	in	r24, 0x06	; 6
    2170:	80 64       	ori	r24, 0x40	; 64
    2172:	86 b9       	out	0x06, r24	; 6
    2174:	08 95       	ret

00002176 <ADC_Init>:
    2176:	27 b1       	in	r18, 0x07	; 7
    2178:	e4 e6       	ldi	r30, 0x64	; 100
    217a:	f0 e0       	ldi	r31, 0x00	; 0
    217c:	91 81       	ldd	r25, Z+1	; 0x01
    217e:	30 e4       	ldi	r19, 0x40	; 64
    2180:	93 9f       	mul	r25, r19
    2182:	c0 01       	movw	r24, r0
    2184:	11 24       	eor	r1, r1
    2186:	92 2f       	mov	r25, r18
    2188:	9f 73       	andi	r25, 0x3F	; 63
    218a:	89 2b       	or	r24, r25
    218c:	87 b9       	out	0x07, r24	; 7
    218e:	82 81       	ldd	r24, Z+2	; 0x02
    2190:	81 11       	cpse	r24, r1
    2192:	04 c0       	rjmp	.+8      	; 0x219c <ADC_Init+0x26>
    2194:	87 b1       	in	r24, 0x07	; 7
    2196:	8f 7d       	andi	r24, 0xDF	; 223
    2198:	87 b9       	out	0x07, r24	; 7
    219a:	05 c0       	rjmp	.+10     	; 0x21a6 <ADC_Init+0x30>
    219c:	81 30       	cpi	r24, 0x01	; 1
    219e:	19 f4       	brne	.+6      	; 0x21a6 <ADC_Init+0x30>
    21a0:	87 b1       	in	r24, 0x07	; 7
    21a2:	80 62       	ori	r24, 0x20	; 32
    21a4:	87 b9       	out	0x07, r24	; 7
    21a6:	86 b1       	in	r24, 0x06	; 6
    21a8:	80 68       	ori	r24, 0x80	; 128
    21aa:	86 b9       	out	0x06, r24	; 6
    21ac:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <ADC_ConfigTypeParam>
    21b0:	88 23       	and	r24, r24
    21b2:	c9 f0       	breq	.+50     	; 0x21e6 <ADC_Init+0x70>
    21b4:	81 30       	cpi	r24, 0x01	; 1
    21b6:	39 f4       	brne	.+14     	; 0x21c6 <ADC_Init+0x50>
    21b8:	86 b1       	in	r24, 0x06	; 6
    21ba:	80 62       	ori	r24, 0x20	; 32
    21bc:	86 b9       	out	0x06, r24	; 6
    21be:	80 b7       	in	r24, 0x30	; 48
    21c0:	8f 70       	andi	r24, 0x0F	; 15
    21c2:	80 bf       	out	0x30, r24	; 48
    21c4:	10 c0       	rjmp	.+32     	; 0x21e6 <ADC_Init+0x70>
    21c6:	82 30       	cpi	r24, 0x02	; 2
    21c8:	71 f4       	brne	.+28     	; 0x21e6 <ADC_Init+0x70>
    21ca:	86 b1       	in	r24, 0x06	; 6
    21cc:	80 62       	ori	r24, 0x20	; 32
    21ce:	86 b9       	out	0x06, r24	; 6
    21d0:	20 b7       	in	r18, 0x30	; 48
    21d2:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <ADC_ConfigTypeParam+0x4>
    21d6:	30 e2       	ldi	r19, 0x20	; 32
    21d8:	93 9f       	mul	r25, r19
    21da:	c0 01       	movw	r24, r0
    21dc:	11 24       	eor	r1, r1
    21de:	92 2f       	mov	r25, r18
    21e0:	9f 70       	andi	r25, 0x0F	; 15
    21e2:	89 2b       	or	r24, r25
    21e4:	80 bf       	out	0x30, r24	; 48
    21e6:	96 b1       	in	r25, 0x06	; 6
    21e8:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <ADC_ConfigTypeParam+0x3>
    21ec:	98 7f       	andi	r25, 0xF8	; 248
    21ee:	87 70       	andi	r24, 0x07	; 7
    21f0:	89 2b       	or	r24, r25
    21f2:	86 b9       	out	0x06, r24	; 6
    21f4:	86 b1       	in	r24, 0x06	; 6
    21f6:	87 7f       	andi	r24, 0xF7	; 247
    21f8:	86 b9       	out	0x06, r24	; 6
    21fa:	08 95       	ret

000021fc <ADC_ReadConversionRegister>:

uint16 ADC_ReadConversionRegister(void)
{   
    /* ⚠️NOTE if I use #define ADC (* (volatile uint16 *) (0x24) )  will reduce all below steps */
    uint16 RegisterValue = 0 ;
    if(ADC_ConfigTypeParam.ADC_ValueAdjustment_value == ADC_Adjust_Right)
    21fc:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <ADC_ConfigTypeParam+0x2>
    2200:	81 11       	cpse	r24, r1
    2202:	08 c0       	rjmp	.+16     	; 0x2214 <ADC_ReadConversionRegister+0x18>
    {
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ADCL;
    2204:	24 b1       	in	r18, 0x04	; 4
        RegisterValue = (( (uint16)(ADCH & 0x03) ) << 8) | RegisterValue ;
    2206:	85 b1       	in	r24, 0x05	; 5
    2208:	83 70       	andi	r24, 0x03	; 3
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	98 2f       	mov	r25, r24
    220e:	88 27       	eor	r24, r24
    2210:	82 2b       	or	r24, r18
    2212:	08 95       	ret
    }
    else if(ADC_ConfigTypeParam.ADC_ValueAdjustment_value == ADC_Adjust_Left)
    2214:	81 30       	cpi	r24, 0x01	; 1
    2216:	69 f4       	brne	.+26     	; 0x2232 <ADC_ReadConversionRegister+0x36>
    {
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ((ADCL & 0xC0) ) >> 6 ;
    2218:	24 b1       	in	r18, 0x04	; 4
    221a:	22 95       	swap	r18
    221c:	26 95       	lsr	r18
    221e:	26 95       	lsr	r18
    2220:	23 70       	andi	r18, 0x03	; 3
        RegisterValue = (( (uint16)ADCH ) << 2) | RegisterValue ;
    2222:	85 b1       	in	r24, 0x05	; 5
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	88 0f       	add	r24, r24
    2228:	99 1f       	adc	r25, r25
    222a:	88 0f       	add	r24, r24
    222c:	99 1f       	adc	r25, r25
    222e:	82 2b       	or	r24, r18
    2230:	08 95       	ret
}

uint16 ADC_ReadConversionRegister(void)
{   
    /* ⚠️NOTE if I use #define ADC (* (volatile uint16 *) (0x24) )  will reduce all below steps */
    uint16 RegisterValue = 0 ;
    2232:	80 e0       	ldi	r24, 0x00	; 0
    2234:	90 e0       	ldi	r25, 0x00	; 0
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ((ADCL & 0xC0) ) >> 6 ;
        RegisterValue = (( (uint16)ADCH ) << 2) | RegisterValue ;
    }
    return RegisterValue ;
}
    2236:	08 95       	ret

00002238 <ADC_ReadChannelSingleConvertion>:


uint16 ADC_ReadChannelSingleConvertion(uint8 Channel_NUM)
{
    uint16 ADC_conversion_value = 0 ;
    ADC_OnlyStartConversionGeneral(Channel_NUM);
    2238:	0e 94 b2 10 	call	0x2164	; 0x2164 <ADC_OnlyStartConversionGeneral>
    /*  wait uintil ADIF (conversion flag) in ADCSRA register convert from Low to High As that mean conversion completed  */
    while (BIT_IS_CLEAR(ADCSRA,ADIF));
    223c:	34 9b       	sbis	0x06, 4	; 6
    223e:	fe cf       	rjmp	.-4      	; 0x223c <ADC_ReadChannelSingleConvertion+0x4>
    ADC_conversion_value = ADC_ReadConversionRegister();
    2240:	0e 94 fe 10 	call	0x21fc	; 0x21fc <ADC_ReadConversionRegister>
    /*  Clear ADIF (conversion flag) in ADCSRA register by write one when use Polling Technique     */
    SET_BIT(ADCSRA,ADIF);
    2244:	26 b1       	in	r18, 0x06	; 6
    2246:	20 61       	ori	r18, 0x10	; 16
    2248:	26 b9       	out	0x06, r18	; 6
    return ADC_conversion_value;
}
    224a:	08 95       	ret

0000224c <GPIO_SetPinDirection>:
            case PORTC_ID :
                TOGGLE_BIT(PORTC,PIN);
                break;

            case PORTD_ID :
                TOGGLE_BIT(PORTD,PIN);
    224c:	84 30       	cpi	r24, 0x04	; 4
    224e:	08 f0       	brcs	.+2      	; 0x2252 <GPIO_SetPinDirection+0x6>
    2250:	d2 c0       	rjmp	.+420    	; 0x23f6 <GPIO_SetPinDirection+0x1aa>
    2252:	68 30       	cpi	r22, 0x08	; 8
    2254:	08 f0       	brcs	.+2      	; 0x2258 <GPIO_SetPinDirection+0xc>
    2256:	cf c0       	rjmp	.+414    	; 0x23f6 <GPIO_SetPinDirection+0x1aa>
    2258:	81 30       	cpi	r24, 0x01	; 1
    225a:	d1 f1       	breq	.+116    	; 0x22d0 <GPIO_SetPinDirection+0x84>
    225c:	38 f0       	brcs	.+14     	; 0x226c <GPIO_SetPinDirection+0x20>
    225e:	82 30       	cpi	r24, 0x02	; 2
    2260:	09 f4       	brne	.+2      	; 0x2264 <GPIO_SetPinDirection+0x18>
    2262:	68 c0       	rjmp	.+208    	; 0x2334 <GPIO_SetPinDirection+0xe8>
    2264:	83 30       	cpi	r24, 0x03	; 3
    2266:	09 f4       	brne	.+2      	; 0x226a <GPIO_SetPinDirection+0x1e>
    2268:	96 c0       	rjmp	.+300    	; 0x2396 <GPIO_SetPinDirection+0x14a>
    226a:	08 95       	ret
    226c:	41 11       	cpse	r20, r1
    226e:	10 c0       	rjmp	.+32     	; 0x2290 <GPIO_SetPinDirection+0x44>
    2270:	2a b3       	in	r18, 0x1a	; 26
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	02 c0       	rjmp	.+4      	; 0x227c <GPIO_SetPinDirection+0x30>
    2278:	88 0f       	add	r24, r24
    227a:	99 1f       	adc	r25, r25
    227c:	6a 95       	dec	r22
    227e:	e2 f7       	brpl	.-8      	; 0x2278 <GPIO_SetPinDirection+0x2c>
    2280:	80 95       	com	r24
    2282:	92 2f       	mov	r25, r18
    2284:	98 23       	and	r25, r24
    2286:	9a bb       	out	0x1a, r25	; 26
    2288:	9b b3       	in	r25, 0x1b	; 27
    228a:	89 23       	and	r24, r25
    228c:	8b bb       	out	0x1b, r24	; 27
    228e:	08 95       	ret
    2290:	41 30       	cpi	r20, 0x01	; 1
    2292:	81 f4       	brne	.+32     	; 0x22b4 <GPIO_SetPinDirection+0x68>
    2294:	2a b3       	in	r18, 0x1a	; 26
    2296:	81 e0       	ldi	r24, 0x01	; 1
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	02 c0       	rjmp	.+4      	; 0x22a0 <GPIO_SetPinDirection+0x54>
    229c:	88 0f       	add	r24, r24
    229e:	99 1f       	adc	r25, r25
    22a0:	6a 95       	dec	r22
    22a2:	e2 f7       	brpl	.-8      	; 0x229c <GPIO_SetPinDirection+0x50>
    22a4:	98 2f       	mov	r25, r24
    22a6:	90 95       	com	r25
    22a8:	92 23       	and	r25, r18
    22aa:	9a bb       	out	0x1a, r25	; 26
    22ac:	9b b3       	in	r25, 0x1b	; 27
    22ae:	89 2b       	or	r24, r25
    22b0:	8b bb       	out	0x1b, r24	; 27
    22b2:	08 95       	ret
    22b4:	42 30       	cpi	r20, 0x02	; 2
    22b6:	09 f0       	breq	.+2      	; 0x22ba <GPIO_SetPinDirection+0x6e>
    22b8:	9e c0       	rjmp	.+316    	; 0x23f6 <GPIO_SetPinDirection+0x1aa>
    22ba:	2a b3       	in	r18, 0x1a	; 26
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	02 c0       	rjmp	.+4      	; 0x22c6 <GPIO_SetPinDirection+0x7a>
    22c2:	88 0f       	add	r24, r24
    22c4:	99 1f       	adc	r25, r25
    22c6:	6a 95       	dec	r22
    22c8:	e2 f7       	brpl	.-8      	; 0x22c2 <GPIO_SetPinDirection+0x76>
    22ca:	82 2b       	or	r24, r18
    22cc:	8a bb       	out	0x1a, r24	; 26
    22ce:	08 95       	ret
    22d0:	41 11       	cpse	r20, r1
    22d2:	10 c0       	rjmp	.+32     	; 0x22f4 <GPIO_SetPinDirection+0xa8>
    22d4:	27 b3       	in	r18, 0x17	; 23
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	90 e0       	ldi	r25, 0x00	; 0
    22da:	02 c0       	rjmp	.+4      	; 0x22e0 <GPIO_SetPinDirection+0x94>
    22dc:	88 0f       	add	r24, r24
    22de:	99 1f       	adc	r25, r25
    22e0:	6a 95       	dec	r22
    22e2:	e2 f7       	brpl	.-8      	; 0x22dc <GPIO_SetPinDirection+0x90>
    22e4:	80 95       	com	r24
    22e6:	92 2f       	mov	r25, r18
    22e8:	98 23       	and	r25, r24
    22ea:	97 bb       	out	0x17, r25	; 23
    22ec:	98 b3       	in	r25, 0x18	; 24
    22ee:	89 23       	and	r24, r25
    22f0:	88 bb       	out	0x18, r24	; 24
    22f2:	08 95       	ret
    22f4:	41 30       	cpi	r20, 0x01	; 1
    22f6:	81 f4       	brne	.+32     	; 0x2318 <GPIO_SetPinDirection+0xcc>
    22f8:	27 b3       	in	r18, 0x17	; 23
    22fa:	81 e0       	ldi	r24, 0x01	; 1
    22fc:	90 e0       	ldi	r25, 0x00	; 0
    22fe:	02 c0       	rjmp	.+4      	; 0x2304 <GPIO_SetPinDirection+0xb8>
    2300:	88 0f       	add	r24, r24
    2302:	99 1f       	adc	r25, r25
    2304:	6a 95       	dec	r22
    2306:	e2 f7       	brpl	.-8      	; 0x2300 <GPIO_SetPinDirection+0xb4>
    2308:	98 2f       	mov	r25, r24
    230a:	90 95       	com	r25
    230c:	92 23       	and	r25, r18
    230e:	97 bb       	out	0x17, r25	; 23
    2310:	98 b3       	in	r25, 0x18	; 24
    2312:	89 2b       	or	r24, r25
    2314:	88 bb       	out	0x18, r24	; 24
    2316:	08 95       	ret
    2318:	42 30       	cpi	r20, 0x02	; 2
    231a:	09 f0       	breq	.+2      	; 0x231e <GPIO_SetPinDirection+0xd2>
    231c:	6c c0       	rjmp	.+216    	; 0x23f6 <GPIO_SetPinDirection+0x1aa>
    231e:	27 b3       	in	r18, 0x17	; 23
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	90 e0       	ldi	r25, 0x00	; 0
    2324:	02 c0       	rjmp	.+4      	; 0x232a <GPIO_SetPinDirection+0xde>
    2326:	88 0f       	add	r24, r24
    2328:	99 1f       	adc	r25, r25
    232a:	6a 95       	dec	r22
    232c:	e2 f7       	brpl	.-8      	; 0x2326 <GPIO_SetPinDirection+0xda>
    232e:	82 2b       	or	r24, r18
    2330:	87 bb       	out	0x17, r24	; 23
    2332:	08 95       	ret
    2334:	41 11       	cpse	r20, r1
    2336:	10 c0       	rjmp	.+32     	; 0x2358 <GPIO_SetPinDirection+0x10c>
    2338:	24 b3       	in	r18, 0x14	; 20
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	02 c0       	rjmp	.+4      	; 0x2344 <GPIO_SetPinDirection+0xf8>
    2340:	88 0f       	add	r24, r24
    2342:	99 1f       	adc	r25, r25
    2344:	6a 95       	dec	r22
    2346:	e2 f7       	brpl	.-8      	; 0x2340 <GPIO_SetPinDirection+0xf4>
    2348:	80 95       	com	r24
    234a:	92 2f       	mov	r25, r18
    234c:	98 23       	and	r25, r24
    234e:	94 bb       	out	0x14, r25	; 20
    2350:	95 b3       	in	r25, 0x15	; 21
    2352:	89 23       	and	r24, r25
    2354:	85 bb       	out	0x15, r24	; 21
    2356:	08 95       	ret
    2358:	41 30       	cpi	r20, 0x01	; 1
    235a:	81 f4       	brne	.+32     	; 0x237c <GPIO_SetPinDirection+0x130>
    235c:	24 b3       	in	r18, 0x14	; 20
    235e:	81 e0       	ldi	r24, 0x01	; 1
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	02 c0       	rjmp	.+4      	; 0x2368 <GPIO_SetPinDirection+0x11c>
    2364:	88 0f       	add	r24, r24
    2366:	99 1f       	adc	r25, r25
    2368:	6a 95       	dec	r22
    236a:	e2 f7       	brpl	.-8      	; 0x2364 <GPIO_SetPinDirection+0x118>
    236c:	98 2f       	mov	r25, r24
    236e:	90 95       	com	r25
    2370:	92 23       	and	r25, r18
    2372:	94 bb       	out	0x14, r25	; 20
    2374:	95 b3       	in	r25, 0x15	; 21
    2376:	89 2b       	or	r24, r25
    2378:	85 bb       	out	0x15, r24	; 21
    237a:	08 95       	ret
    237c:	42 30       	cpi	r20, 0x02	; 2
    237e:	d9 f5       	brne	.+118    	; 0x23f6 <GPIO_SetPinDirection+0x1aa>
    2380:	24 b3       	in	r18, 0x14	; 20
    2382:	81 e0       	ldi	r24, 0x01	; 1
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	02 c0       	rjmp	.+4      	; 0x238c <GPIO_SetPinDirection+0x140>
    2388:	88 0f       	add	r24, r24
    238a:	99 1f       	adc	r25, r25
    238c:	6a 95       	dec	r22
    238e:	e2 f7       	brpl	.-8      	; 0x2388 <GPIO_SetPinDirection+0x13c>
    2390:	82 2b       	or	r24, r18
    2392:	84 bb       	out	0x14, r24	; 20
    2394:	08 95       	ret
    2396:	41 11       	cpse	r20, r1
    2398:	10 c0       	rjmp	.+32     	; 0x23ba <GPIO_SetPinDirection+0x16e>
    239a:	21 b3       	in	r18, 0x11	; 17
    239c:	81 e0       	ldi	r24, 0x01	; 1
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	02 c0       	rjmp	.+4      	; 0x23a6 <GPIO_SetPinDirection+0x15a>
    23a2:	88 0f       	add	r24, r24
    23a4:	99 1f       	adc	r25, r25
    23a6:	6a 95       	dec	r22
    23a8:	e2 f7       	brpl	.-8      	; 0x23a2 <GPIO_SetPinDirection+0x156>
    23aa:	80 95       	com	r24
    23ac:	92 2f       	mov	r25, r18
    23ae:	98 23       	and	r25, r24
    23b0:	91 bb       	out	0x11, r25	; 17
    23b2:	92 b3       	in	r25, 0x12	; 18
    23b4:	89 23       	and	r24, r25
    23b6:	82 bb       	out	0x12, r24	; 18
    23b8:	08 95       	ret
    23ba:	41 30       	cpi	r20, 0x01	; 1
    23bc:	81 f4       	brne	.+32     	; 0x23de <GPIO_SetPinDirection+0x192>
    23be:	21 b3       	in	r18, 0x11	; 17
    23c0:	81 e0       	ldi	r24, 0x01	; 1
    23c2:	90 e0       	ldi	r25, 0x00	; 0
    23c4:	02 c0       	rjmp	.+4      	; 0x23ca <GPIO_SetPinDirection+0x17e>
    23c6:	88 0f       	add	r24, r24
    23c8:	99 1f       	adc	r25, r25
    23ca:	6a 95       	dec	r22
    23cc:	e2 f7       	brpl	.-8      	; 0x23c6 <GPIO_SetPinDirection+0x17a>
    23ce:	98 2f       	mov	r25, r24
    23d0:	90 95       	com	r25
    23d2:	92 23       	and	r25, r18
    23d4:	91 bb       	out	0x11, r25	; 17
    23d6:	92 b3       	in	r25, 0x12	; 18
    23d8:	89 2b       	or	r24, r25
    23da:	82 bb       	out	0x12, r24	; 18
    23dc:	08 95       	ret
    23de:	42 30       	cpi	r20, 0x02	; 2
    23e0:	51 f4       	brne	.+20     	; 0x23f6 <GPIO_SetPinDirection+0x1aa>
    23e2:	21 b3       	in	r18, 0x11	; 17
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	02 c0       	rjmp	.+4      	; 0x23ee <GPIO_SetPinDirection+0x1a2>
    23ea:	88 0f       	add	r24, r24
    23ec:	99 1f       	adc	r25, r25
    23ee:	6a 95       	dec	r22
    23f0:	e2 f7       	brpl	.-8      	; 0x23ea <GPIO_SetPinDirection+0x19e>
    23f2:	82 2b       	or	r24, r18
    23f4:	81 bb       	out	0x11, r24	; 17
    23f6:	08 95       	ret

000023f8 <GPIO_WritePin>:
    23f8:	84 30       	cpi	r24, 0x04	; 4
    23fa:	08 f0       	brcs	.+2      	; 0x23fe <GPIO_WritePin+0x6>
    23fc:	77 c0       	rjmp	.+238    	; 0x24ec <GPIO_WritePin+0xf4>
    23fe:	68 30       	cpi	r22, 0x08	; 8
    2400:	08 f0       	brcs	.+2      	; 0x2404 <GPIO_WritePin+0xc>
    2402:	74 c0       	rjmp	.+232    	; 0x24ec <GPIO_WritePin+0xf4>
    2404:	81 30       	cpi	r24, 0x01	; 1
    2406:	11 f1       	breq	.+68     	; 0x244c <GPIO_WritePin+0x54>
    2408:	30 f0       	brcs	.+12     	; 0x2416 <GPIO_WritePin+0x1e>
    240a:	82 30       	cpi	r24, 0x02	; 2
    240c:	d1 f1       	breq	.+116    	; 0x2482 <GPIO_WritePin+0x8a>
    240e:	83 30       	cpi	r24, 0x03	; 3
    2410:	09 f4       	brne	.+2      	; 0x2414 <GPIO_WritePin+0x1c>
    2412:	52 c0       	rjmp	.+164    	; 0x24b8 <GPIO_WritePin+0xc0>
    2414:	08 95       	ret
    2416:	41 30       	cpi	r20, 0x01	; 1
    2418:	59 f4       	brne	.+22     	; 0x2430 <GPIO_WritePin+0x38>
    241a:	2b b3       	in	r18, 0x1b	; 27
    241c:	81 e0       	ldi	r24, 0x01	; 1
    241e:	90 e0       	ldi	r25, 0x00	; 0
    2420:	02 c0       	rjmp	.+4      	; 0x2426 <GPIO_WritePin+0x2e>
    2422:	88 0f       	add	r24, r24
    2424:	99 1f       	adc	r25, r25
    2426:	6a 95       	dec	r22
    2428:	e2 f7       	brpl	.-8      	; 0x2422 <GPIO_WritePin+0x2a>
    242a:	82 2b       	or	r24, r18
    242c:	8b bb       	out	0x1b, r24	; 27
    242e:	08 95       	ret
    2430:	41 11       	cpse	r20, r1
    2432:	5c c0       	rjmp	.+184    	; 0x24ec <GPIO_WritePin+0xf4>
    2434:	2b b3       	in	r18, 0x1b	; 27
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	02 c0       	rjmp	.+4      	; 0x2440 <GPIO_WritePin+0x48>
    243c:	88 0f       	add	r24, r24
    243e:	99 1f       	adc	r25, r25
    2440:	6a 95       	dec	r22
    2442:	e2 f7       	brpl	.-8      	; 0x243c <GPIO_WritePin+0x44>
    2444:	80 95       	com	r24
    2446:	82 23       	and	r24, r18
    2448:	8b bb       	out	0x1b, r24	; 27
    244a:	08 95       	ret
    244c:	41 30       	cpi	r20, 0x01	; 1
    244e:	59 f4       	brne	.+22     	; 0x2466 <GPIO_WritePin+0x6e>
    2450:	28 b3       	in	r18, 0x18	; 24
    2452:	81 e0       	ldi	r24, 0x01	; 1
    2454:	90 e0       	ldi	r25, 0x00	; 0
    2456:	02 c0       	rjmp	.+4      	; 0x245c <GPIO_WritePin+0x64>
    2458:	88 0f       	add	r24, r24
    245a:	99 1f       	adc	r25, r25
    245c:	6a 95       	dec	r22
    245e:	e2 f7       	brpl	.-8      	; 0x2458 <GPIO_WritePin+0x60>
    2460:	82 2b       	or	r24, r18
    2462:	88 bb       	out	0x18, r24	; 24
    2464:	08 95       	ret
    2466:	41 11       	cpse	r20, r1
    2468:	41 c0       	rjmp	.+130    	; 0x24ec <GPIO_WritePin+0xf4>
    246a:	28 b3       	in	r18, 0x18	; 24
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	90 e0       	ldi	r25, 0x00	; 0
    2470:	02 c0       	rjmp	.+4      	; 0x2476 <GPIO_WritePin+0x7e>
    2472:	88 0f       	add	r24, r24
    2474:	99 1f       	adc	r25, r25
    2476:	6a 95       	dec	r22
    2478:	e2 f7       	brpl	.-8      	; 0x2472 <GPIO_WritePin+0x7a>
    247a:	80 95       	com	r24
    247c:	82 23       	and	r24, r18
    247e:	88 bb       	out	0x18, r24	; 24
    2480:	08 95       	ret
    2482:	41 30       	cpi	r20, 0x01	; 1
    2484:	59 f4       	brne	.+22     	; 0x249c <GPIO_WritePin+0xa4>
    2486:	25 b3       	in	r18, 0x15	; 21
    2488:	81 e0       	ldi	r24, 0x01	; 1
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	02 c0       	rjmp	.+4      	; 0x2492 <GPIO_WritePin+0x9a>
    248e:	88 0f       	add	r24, r24
    2490:	99 1f       	adc	r25, r25
    2492:	6a 95       	dec	r22
    2494:	e2 f7       	brpl	.-8      	; 0x248e <GPIO_WritePin+0x96>
    2496:	82 2b       	or	r24, r18
    2498:	85 bb       	out	0x15, r24	; 21
    249a:	08 95       	ret
    249c:	41 11       	cpse	r20, r1
    249e:	26 c0       	rjmp	.+76     	; 0x24ec <GPIO_WritePin+0xf4>
    24a0:	25 b3       	in	r18, 0x15	; 21
    24a2:	81 e0       	ldi	r24, 0x01	; 1
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	02 c0       	rjmp	.+4      	; 0x24ac <GPIO_WritePin+0xb4>
    24a8:	88 0f       	add	r24, r24
    24aa:	99 1f       	adc	r25, r25
    24ac:	6a 95       	dec	r22
    24ae:	e2 f7       	brpl	.-8      	; 0x24a8 <GPIO_WritePin+0xb0>
    24b0:	80 95       	com	r24
    24b2:	82 23       	and	r24, r18
    24b4:	85 bb       	out	0x15, r24	; 21
    24b6:	08 95       	ret
    24b8:	41 30       	cpi	r20, 0x01	; 1
    24ba:	59 f4       	brne	.+22     	; 0x24d2 <GPIO_WritePin+0xda>
    24bc:	22 b3       	in	r18, 0x12	; 18
    24be:	81 e0       	ldi	r24, 0x01	; 1
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	02 c0       	rjmp	.+4      	; 0x24c8 <GPIO_WritePin+0xd0>
    24c4:	88 0f       	add	r24, r24
    24c6:	99 1f       	adc	r25, r25
    24c8:	6a 95       	dec	r22
    24ca:	e2 f7       	brpl	.-8      	; 0x24c4 <GPIO_WritePin+0xcc>
    24cc:	82 2b       	or	r24, r18
    24ce:	82 bb       	out	0x12, r24	; 18
    24d0:	08 95       	ret
    24d2:	41 11       	cpse	r20, r1
    24d4:	0b c0       	rjmp	.+22     	; 0x24ec <GPIO_WritePin+0xf4>
    24d6:	22 b3       	in	r18, 0x12	; 18
    24d8:	81 e0       	ldi	r24, 0x01	; 1
    24da:	90 e0       	ldi	r25, 0x00	; 0
    24dc:	02 c0       	rjmp	.+4      	; 0x24e2 <GPIO_WritePin+0xea>
    24de:	88 0f       	add	r24, r24
    24e0:	99 1f       	adc	r25, r25
    24e2:	6a 95       	dec	r22
    24e4:	e2 f7       	brpl	.-8      	; 0x24de <GPIO_WritePin+0xe6>
    24e6:	80 95       	com	r24
    24e8:	82 23       	and	r24, r18
    24ea:	82 bb       	out	0x12, r24	; 18
    24ec:	08 95       	ret

000024ee <GPIO_SetPortDirection>:
{
#if (Param_Disable_All_PULLUP_resistor == Disable_PullUp_resistor)
	SET_BIT(SFIOR,PUD);
#endif

	if(PORTX >= NUM_PORT)
    24ee:	84 30       	cpi	r24, 0x04	; 4
    24f0:	08 f0       	brcs	.+2      	; 0x24f4 <GPIO_SetPortDirection+0x6>
    24f2:	47 c0       	rjmp	.+142    	; 0x2582 <GPIO_SetPortDirection+0x94>
	{
		/** Do Nothing **/
	}
	else
	{
		switch(PORTX)
    24f4:	81 30       	cpi	r24, 0x01	; 1
    24f6:	b1 f0       	breq	.+44     	; 0x2524 <GPIO_SetPortDirection+0x36>
    24f8:	28 f0       	brcs	.+10     	; 0x2504 <GPIO_SetPortDirection+0x16>
    24fa:	82 30       	cpi	r24, 0x02	; 2
    24fc:	19 f1       	breq	.+70     	; 0x2544 <GPIO_SetPortDirection+0x56>
    24fe:	83 30       	cpi	r24, 0x03	; 3
    2500:	89 f1       	breq	.+98     	; 0x2564 <GPIO_SetPortDirection+0x76>
    2502:	08 95       	ret
		{
			case PORTA_ID :
					if(PortDirection == INPUT_PORT)
    2504:	61 11       	cpse	r22, r1
    2506:	03 c0       	rjmp	.+6      	; 0x250e <GPIO_SetPortDirection+0x20>
					{
						DDRA = ZEROS_WORD ; // set port input
    2508:	1a ba       	out	0x1a, r1	; 26
						PORTA = ZEROS_WORD ; //disable pullup resistor
    250a:	1b ba       	out	0x1b, r1	; 27
    250c:	08 95       	ret

					}
					else if(PortDirection == INPUT_PORT_PULLUP)
    250e:	61 30       	cpi	r22, 0x01	; 1
    2510:	21 f4       	brne	.+8      	; 0x251a <GPIO_SetPortDirection+0x2c>
					{
						DDRA = ZEROS_WORD ;// set port input
    2512:	1a ba       	out	0x1a, r1	; 26
						PORTA = ONES_WORD ; //enable pullup resistor
    2514:	8f ef       	ldi	r24, 0xFF	; 255
    2516:	8b bb       	out	0x1b, r24	; 27
    2518:	08 95       	ret

					}
					else if(PortDirection == OUTPUT_PORT )
    251a:	6f 3f       	cpi	r22, 0xFF	; 255
    251c:	91 f5       	brne	.+100    	; 0x2582 <GPIO_SetPortDirection+0x94>
					{
						DDRA = ONES_WORD ;
    251e:	8f ef       	ldi	r24, 0xFF	; 255
    2520:	8a bb       	out	0x1a, r24	; 26
    2522:	08 95       	ret
					}
					break;

			case PORTB_ID :
					if(PortDirection == INPUT_PORT)
    2524:	61 11       	cpse	r22, r1
    2526:	03 c0       	rjmp	.+6      	; 0x252e <GPIO_SetPortDirection+0x40>
					{
						DDRB = ZEROS_WORD ; // set port input
    2528:	17 ba       	out	0x17, r1	; 23
						PORTB = ZEROS_WORD ; //disable pullup resistor
    252a:	18 ba       	out	0x18, r1	; 24
    252c:	08 95       	ret

					}
					else if(PortDirection == INPUT_PORT_PULLUP)
    252e:	61 30       	cpi	r22, 0x01	; 1
    2530:	21 f4       	brne	.+8      	; 0x253a <GPIO_SetPortDirection+0x4c>
					{
						DDRB = ZEROS_WORD ;// set port input
    2532:	17 ba       	out	0x17, r1	; 23
						PORTB = ONES_WORD ; //enable pullup resistor
    2534:	8f ef       	ldi	r24, 0xFF	; 255
    2536:	88 bb       	out	0x18, r24	; 24
    2538:	08 95       	ret

					}
					else if(PortDirection == OUTPUT_PORT )
    253a:	6f 3f       	cpi	r22, 0xFF	; 255
    253c:	11 f5       	brne	.+68     	; 0x2582 <GPIO_SetPortDirection+0x94>
					{
						DDRB = ONES_WORD ;
    253e:	8f ef       	ldi	r24, 0xFF	; 255
    2540:	87 bb       	out	0x17, r24	; 23
    2542:	08 95       	ret
					}
					break;

			case PORTC_ID :
					if(PortDirection == INPUT_PORT)
    2544:	61 11       	cpse	r22, r1
    2546:	03 c0       	rjmp	.+6      	; 0x254e <GPIO_SetPortDirection+0x60>
					{
						DDRC = ZEROS_WORD ; // set port input
    2548:	14 ba       	out	0x14, r1	; 20
						PORTC = ZEROS_WORD ; //disable pullup resistor
    254a:	15 ba       	out	0x15, r1	; 21
    254c:	08 95       	ret

					}
					else if(PortDirection == INPUT_PORT_PULLUP)
    254e:	61 30       	cpi	r22, 0x01	; 1
    2550:	21 f4       	brne	.+8      	; 0x255a <GPIO_SetPortDirection+0x6c>
					{
						DDRC = ZEROS_WORD ;// set port input
    2552:	14 ba       	out	0x14, r1	; 20
						PORTC = ONES_WORD ; //enable pullup resistor
    2554:	8f ef       	ldi	r24, 0xFF	; 255
    2556:	85 bb       	out	0x15, r24	; 21
    2558:	08 95       	ret

					}
					else if(PortDirection == OUTPUT_PORT )
    255a:	6f 3f       	cpi	r22, 0xFF	; 255
    255c:	91 f4       	brne	.+36     	; 0x2582 <GPIO_SetPortDirection+0x94>
					{
						DDRC = ONES_WORD ;
    255e:	8f ef       	ldi	r24, 0xFF	; 255
    2560:	84 bb       	out	0x14, r24	; 20
    2562:	08 95       	ret
					}
					break;

			case PORTD_ID :
					if(PortDirection == INPUT_PORT)
    2564:	61 11       	cpse	r22, r1
    2566:	03 c0       	rjmp	.+6      	; 0x256e <GPIO_SetPortDirection+0x80>
					{
						DDRD = ZEROS_WORD ; // set port input
    2568:	11 ba       	out	0x11, r1	; 17
						PORTD = ZEROS_WORD ; //disable pullup resistor
    256a:	12 ba       	out	0x12, r1	; 18
    256c:	08 95       	ret

					}
					else if(PortDirection == INPUT_PORT_PULLUP)
    256e:	61 30       	cpi	r22, 0x01	; 1
    2570:	21 f4       	brne	.+8      	; 0x257a <GPIO_SetPortDirection+0x8c>
					{
						DDRD = ZEROS_WORD ;// set port input
    2572:	11 ba       	out	0x11, r1	; 17
						PORTD = ONES_WORD ; //enable pullup resistor
    2574:	8f ef       	ldi	r24, 0xFF	; 255
    2576:	82 bb       	out	0x12, r24	; 18
    2578:	08 95       	ret

					}
					else if(PortDirection == OUTPUT_PORT )
    257a:	6f 3f       	cpi	r22, 0xFF	; 255
    257c:	11 f4       	brne	.+4      	; 0x2582 <GPIO_SetPortDirection+0x94>
					{
						DDRD = ONES_WORD ;
    257e:	8f ef       	ldi	r24, 0xFF	; 255
    2580:	81 bb       	out	0x11, r24	; 17
    2582:	08 95       	ret

00002584 <GPIO_init>:

/**************************                   Functions Definition                   **************************/


void GPIO_init(void)
{
    2584:	cf 93       	push	r28
#if (Param_Disable_All_PULLUP_resistor == Disable_PullUp_resistor)
	SET_BIT(SFIOR,PUD);
#endif
	for(uint8 it = 0 ; it < Configuration_NUM ; it++)
    2586:	c0 e0       	ldi	r28, 0x00	; 0
    2588:	26 c0       	rjmp	.+76     	; 0x25d6 <GPIO_init+0x52>
	{
		if(GPIO_configParam[it].PIN_SELECT == PINS_ALL) // configure all port
    258a:	8c 2f       	mov	r24, r28
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	fc 01       	movw	r30, r24
    2590:	ee 0f       	add	r30, r30
    2592:	ff 1f       	adc	r31, r31
    2594:	e8 0f       	add	r30, r24
    2596:	f9 1f       	adc	r31, r25
    2598:	e7 59       	subi	r30, 0x97	; 151
    259a:	ff 4f       	sbci	r31, 0xFF	; 255
    259c:	61 81       	ldd	r22, Z+1	; 0x01
    259e:	68 30       	cpi	r22, 0x08	; 8
    25a0:	69 f4       	brne	.+26     	; 0x25bc <GPIO_init+0x38>
		{
			GPIO_SetPortDirection(GPIO_configParam[it].PORT_Selected , GPIO_configParam[it].INPUT_OUTPUT);
    25a2:	fc 01       	movw	r30, r24
    25a4:	ee 0f       	add	r30, r30
    25a6:	ff 1f       	adc	r31, r31
    25a8:	8e 0f       	add	r24, r30
    25aa:	9f 1f       	adc	r25, r31
    25ac:	fc 01       	movw	r30, r24
    25ae:	e7 59       	subi	r30, 0x97	; 151
    25b0:	ff 4f       	sbci	r31, 0xFF	; 255
    25b2:	62 81       	ldd	r22, Z+2	; 0x02
    25b4:	80 81       	ld	r24, Z
    25b6:	0e 94 77 12 	call	0x24ee	; 0x24ee <GPIO_SetPortDirection>
    25ba:	0c c0       	rjmp	.+24     	; 0x25d4 <GPIO_init+0x50>
		}
		else  // configure pin from port
		{
			GPIO_SetPinDirection(GPIO_configParam[it].PORT_Selected , GPIO_configParam[it].PIN_SELECT , GPIO_configParam[it].INPUT_OUTPUT);
    25bc:	fc 01       	movw	r30, r24
    25be:	ee 0f       	add	r30, r30
    25c0:	ff 1f       	adc	r31, r31
    25c2:	8e 0f       	add	r24, r30
    25c4:	9f 1f       	adc	r25, r31
    25c6:	fc 01       	movw	r30, r24
    25c8:	e7 59       	subi	r30, 0x97	; 151
    25ca:	ff 4f       	sbci	r31, 0xFF	; 255
    25cc:	42 81       	ldd	r20, Z+2	; 0x02
    25ce:	80 81       	ld	r24, Z
    25d0:	0e 94 26 11 	call	0x224c	; 0x224c <GPIO_SetPinDirection>
void GPIO_init(void)
{
#if (Param_Disable_All_PULLUP_resistor == Disable_PullUp_resistor)
	SET_BIT(SFIOR,PUD);
#endif
	for(uint8 it = 0 ; it < Configuration_NUM ; it++)
    25d4:	cf 5f       	subi	r28, 0xFF	; 255
    25d6:	cc 23       	and	r28, r28
    25d8:	c1 f2       	breq	.-80     	; 0x258a <GPIO_init+0x6>
		{
			GPIO_SetPinDirection(GPIO_configParam[it].PORT_Selected , GPIO_configParam[it].PIN_SELECT , GPIO_configParam[it].INPUT_OUTPUT);
		}
	}

}
    25da:	cf 91       	pop	r28
    25dc:	08 95       	ret

000025de <__vector_13>:
    uint16 Returned_value = 0;
    /*  Should read 9th bit of data if use 9 bit data before UDR*/
    Returned_value = ( (UCSRB & 0x02) << 7) ;
    Returned_value |= UDR ;
    return Returned_value;
}
    25de:	1f 92       	push	r1
    25e0:	0f 92       	push	r0
    25e2:	0f b6       	in	r0, 0x3f	; 63
    25e4:	0f 92       	push	r0
    25e6:	11 24       	eor	r1, r1
    25e8:	2f 93       	push	r18
    25ea:	3f 93       	push	r19
    25ec:	4f 93       	push	r20
    25ee:	5f 93       	push	r21
    25f0:	6f 93       	push	r22
    25f2:	7f 93       	push	r23
    25f4:	8f 93       	push	r24
    25f6:	9f 93       	push	r25
    25f8:	af 93       	push	r26
    25fa:	bf 93       	push	r27
    25fc:	ef 93       	push	r30
    25fe:	ff 93       	push	r31
    2600:	e0 91 3d 06 	lds	r30, 0x063D	; 0x80063d <g_CallBackPtr_Receive_USART>
    2604:	f0 91 3e 06 	lds	r31, 0x063E	; 0x80063e <g_CallBackPtr_Receive_USART+0x1>
    2608:	30 97       	sbiw	r30, 0x00	; 0
    260a:	09 f0       	breq	.+2      	; 0x260e <__vector_13+0x30>
    260c:	09 95       	icall
    260e:	ff 91       	pop	r31
    2610:	ef 91       	pop	r30
    2612:	bf 91       	pop	r27
    2614:	af 91       	pop	r26
    2616:	9f 91       	pop	r25
    2618:	8f 91       	pop	r24
    261a:	7f 91       	pop	r23
    261c:	6f 91       	pop	r22
    261e:	5f 91       	pop	r21
    2620:	4f 91       	pop	r20
    2622:	3f 91       	pop	r19
    2624:	2f 91       	pop	r18
    2626:	0f 90       	pop	r0
    2628:	0f be       	out	0x3f, r0	; 63
    262a:	0f 90       	pop	r0
    262c:	1f 90       	pop	r1
    262e:	18 95       	reti

00002630 <USART_Init>:
    2630:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <USART_ConfigTypeParam+0x3>
    2634:	81 11       	cpse	r24, r1
    2636:	04 c0       	rjmp	.+8      	; 0x2640 <USART_Init+0x10>
    2638:	8a b1       	in	r24, 0x0a	; 10
    263a:	88 60       	ori	r24, 0x08	; 8
    263c:	8a b9       	out	0x0a, r24	; 10
    263e:	0e c0       	rjmp	.+28     	; 0x265c <USART_Init+0x2c>
    2640:	81 30       	cpi	r24, 0x01	; 1
    2642:	21 f4       	brne	.+8      	; 0x264c <USART_Init+0x1c>
    2644:	8a b1       	in	r24, 0x0a	; 10
    2646:	80 61       	ori	r24, 0x10	; 16
    2648:	8a b9       	out	0x0a, r24	; 10
    264a:	08 c0       	rjmp	.+16     	; 0x265c <USART_Init+0x2c>
    264c:	82 30       	cpi	r24, 0x02	; 2
    264e:	31 f4       	brne	.+12     	; 0x265c <USART_Init+0x2c>
    2650:	8a b1       	in	r24, 0x0a	; 10
    2652:	80 61       	ori	r24, 0x10	; 16
    2654:	8a b9       	out	0x0a, r24	; 10
    2656:	8a b1       	in	r24, 0x0a	; 10
    2658:	88 60       	ori	r24, 0x08	; 8
    265a:	8a b9       	out	0x0a, r24	; 10
    265c:	ec e6       	ldi	r30, 0x6C	; 108
    265e:	f0 e0       	ldi	r31, 0x00	; 0
    2660:	41 81       	ldd	r20, Z+1	; 0x01
    2662:	80 e1       	ldi	r24, 0x10	; 16
    2664:	48 9f       	mul	r20, r24
    2666:	a0 01       	movw	r20, r0
    2668:	11 24       	eor	r1, r1
    266a:	92 81       	ldd	r25, Z+2	; 0x02
    266c:	29 2f       	mov	r18, r25
    266e:	30 e0       	ldi	r19, 0x00	; 0
    2670:	22 0f       	add	r18, r18
    2672:	33 1f       	adc	r19, r19
    2674:	22 0f       	add	r18, r18
    2676:	33 1f       	adc	r19, r19
    2678:	22 0f       	add	r18, r18
    267a:	33 1f       	adc	r19, r19
    267c:	90 81       	ld	r25, Z
    267e:	89 2f       	mov	r24, r25
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	88 0f       	add	r24, r24
    2684:	99 1f       	adc	r25, r25
    2686:	40 68       	ori	r20, 0x80	; 128
    2688:	24 2b       	or	r18, r20
    268a:	82 2b       	or	r24, r18
    268c:	80 bd       	out	0x20, r24	; 32
    268e:	2a b1       	in	r18, 0x0a	; 10
    2690:	90 81       	ld	r25, Z
    2692:	94 70       	andi	r25, 0x04	; 4
    2694:	89 2f       	mov	r24, r25
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	88 0f       	add	r24, r24
    269a:	99 1f       	adc	r25, r25
    269c:	88 0f       	add	r24, r24
    269e:	99 1f       	adc	r25, r25
    26a0:	92 2f       	mov	r25, r18
    26a2:	9b 7f       	andi	r25, 0xFB	; 251
    26a4:	89 2b       	or	r24, r25
    26a6:	8a b9       	out	0x0a, r24	; 10
    26a8:	85 81       	ldd	r24, Z+5	; 0x05
    26aa:	80 bd       	out	0x20, r24	; 32
    26ac:	84 81       	ldd	r24, Z+4	; 0x04
    26ae:	89 b9       	out	0x09, r24	; 9
    26b0:	08 95       	ret

000026b2 <USART_SendBytePolling>:
    26b2:	5d 9b       	sbis	0x0b, 5	; 11
    26b4:	fe cf       	rjmp	.-4      	; 0x26b2 <USART_SendBytePolling>
    26b6:	90 ff       	sbrs	r25, 0
    26b8:	04 c0       	rjmp	.+8      	; 0x26c2 <USART_SendBytePolling+0x10>
    26ba:	2a b1       	in	r18, 0x0a	; 10
    26bc:	21 60       	ori	r18, 0x01	; 1
    26be:	2a b9       	out	0x0a, r18	; 10
    26c0:	03 c0       	rjmp	.+6      	; 0x26c8 <USART_SendBytePolling+0x16>
    26c2:	2a b1       	in	r18, 0x0a	; 10
    26c4:	2e 7f       	andi	r18, 0xFE	; 254
    26c6:	2a b9       	out	0x0a, r18	; 10
    26c8:	8c b9       	out	0x0c, r24	; 12
    26ca:	08 95       	ret

000026cc <USART_SendStringPolling>:
    26cc:	0f 93       	push	r16
    26ce:	1f 93       	push	r17
    26d0:	cf 93       	push	r28
    26d2:	8c 01       	movw	r16, r24
    26d4:	c0 e0       	ldi	r28, 0x00	; 0
    26d6:	04 c0       	rjmp	.+8      	; 0x26e0 <USART_SendStringPolling+0x14>
    26d8:	90 e0       	ldi	r25, 0x00	; 0
    26da:	0e 94 59 13 	call	0x26b2	; 0x26b2 <USART_SendBytePolling>
    26de:	cf 5f       	subi	r28, 0xFF	; 255
    26e0:	f8 01       	movw	r30, r16
    26e2:	ec 0f       	add	r30, r28
    26e4:	f1 1d       	adc	r31, r1
    26e6:	80 81       	ld	r24, Z
    26e8:	81 11       	cpse	r24, r1
    26ea:	f6 cf       	rjmp	.-20     	; 0x26d8 <USART_SendStringPolling+0xc>
    26ec:	cf 91       	pop	r28
    26ee:	1f 91       	pop	r17
    26f0:	0f 91       	pop	r16
    26f2:	08 95       	ret

000026f4 <UART_receiveByteUnblocking>:


boolean UART_receiveByteUnblocking(uint8 * Data)
{
    boolean result = FALSE;
	if ( UCSRA & (1<<RXC) ){
    26f4:	5f 9b       	sbis	0x0b, 7	; 11
    26f6:	05 c0       	rjmp	.+10     	; 0x2702 <UART_receiveByteUnblocking+0xe>
		(*Data) = UDR;
    26f8:	2c b1       	in	r18, 0x0c	; 12
    26fa:	fc 01       	movw	r30, r24
    26fc:	20 83       	st	Z, r18
		result =  TRUE;		
    26fe:	81 e0       	ldi	r24, 0x01	; 1
    2700:	08 95       	ret
	}
	else{
		result = FALSE;
    2702:	80 e0       	ldi	r24, 0x00	; 0
	}
	return result;
    2704:	08 95       	ret

00002706 <__subsf3>:
    2706:	50 58       	subi	r21, 0x80	; 128

00002708 <__addsf3>:
    2708:	bb 27       	eor	r27, r27
    270a:	aa 27       	eor	r26, r26
    270c:	0e 94 9b 13 	call	0x2736	; 0x2736 <__addsf3x>
    2710:	0c 94 e5 14 	jmp	0x29ca	; 0x29ca <__fp_round>
    2714:	0e 94 d7 14 	call	0x29ae	; 0x29ae <__fp_pscA>
    2718:	38 f0       	brcs	.+14     	; 0x2728 <__addsf3+0x20>
    271a:	0e 94 de 14 	call	0x29bc	; 0x29bc <__fp_pscB>
    271e:	20 f0       	brcs	.+8      	; 0x2728 <__addsf3+0x20>
    2720:	39 f4       	brne	.+14     	; 0x2730 <__addsf3+0x28>
    2722:	9f 3f       	cpi	r25, 0xFF	; 255
    2724:	19 f4       	brne	.+6      	; 0x272c <__addsf3+0x24>
    2726:	26 f4       	brtc	.+8      	; 0x2730 <__addsf3+0x28>
    2728:	0c 94 d4 14 	jmp	0x29a8	; 0x29a8 <__fp_nan>
    272c:	0e f4       	brtc	.+2      	; 0x2730 <__addsf3+0x28>
    272e:	e0 95       	com	r30
    2730:	e7 fb       	bst	r30, 7
    2732:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__fp_inf>

00002736 <__addsf3x>:
    2736:	e9 2f       	mov	r30, r25
    2738:	0e 94 f6 14 	call	0x29ec	; 0x29ec <__fp_split3>
    273c:	58 f3       	brcs	.-42     	; 0x2714 <__addsf3+0xc>
    273e:	ba 17       	cp	r27, r26
    2740:	62 07       	cpc	r22, r18
    2742:	73 07       	cpc	r23, r19
    2744:	84 07       	cpc	r24, r20
    2746:	95 07       	cpc	r25, r21
    2748:	20 f0       	brcs	.+8      	; 0x2752 <__addsf3x+0x1c>
    274a:	79 f4       	brne	.+30     	; 0x276a <__addsf3x+0x34>
    274c:	a6 f5       	brtc	.+104    	; 0x27b6 <__addsf3x+0x80>
    274e:	0c 94 18 15 	jmp	0x2a30	; 0x2a30 <__fp_zero>
    2752:	0e f4       	brtc	.+2      	; 0x2756 <__addsf3x+0x20>
    2754:	e0 95       	com	r30
    2756:	0b 2e       	mov	r0, r27
    2758:	ba 2f       	mov	r27, r26
    275a:	a0 2d       	mov	r26, r0
    275c:	0b 01       	movw	r0, r22
    275e:	b9 01       	movw	r22, r18
    2760:	90 01       	movw	r18, r0
    2762:	0c 01       	movw	r0, r24
    2764:	ca 01       	movw	r24, r20
    2766:	a0 01       	movw	r20, r0
    2768:	11 24       	eor	r1, r1
    276a:	ff 27       	eor	r31, r31
    276c:	59 1b       	sub	r21, r25
    276e:	99 f0       	breq	.+38     	; 0x2796 <__addsf3x+0x60>
    2770:	59 3f       	cpi	r21, 0xF9	; 249
    2772:	50 f4       	brcc	.+20     	; 0x2788 <__addsf3x+0x52>
    2774:	50 3e       	cpi	r21, 0xE0	; 224
    2776:	68 f1       	brcs	.+90     	; 0x27d2 <__addsf3x+0x9c>
    2778:	1a 16       	cp	r1, r26
    277a:	f0 40       	sbci	r31, 0x00	; 0
    277c:	a2 2f       	mov	r26, r18
    277e:	23 2f       	mov	r18, r19
    2780:	34 2f       	mov	r19, r20
    2782:	44 27       	eor	r20, r20
    2784:	58 5f       	subi	r21, 0xF8	; 248
    2786:	f3 cf       	rjmp	.-26     	; 0x276e <__addsf3x+0x38>
    2788:	46 95       	lsr	r20
    278a:	37 95       	ror	r19
    278c:	27 95       	ror	r18
    278e:	a7 95       	ror	r26
    2790:	f0 40       	sbci	r31, 0x00	; 0
    2792:	53 95       	inc	r21
    2794:	c9 f7       	brne	.-14     	; 0x2788 <__addsf3x+0x52>
    2796:	7e f4       	brtc	.+30     	; 0x27b6 <__addsf3x+0x80>
    2798:	1f 16       	cp	r1, r31
    279a:	ba 0b       	sbc	r27, r26
    279c:	62 0b       	sbc	r22, r18
    279e:	73 0b       	sbc	r23, r19
    27a0:	84 0b       	sbc	r24, r20
    27a2:	ba f0       	brmi	.+46     	; 0x27d2 <__addsf3x+0x9c>
    27a4:	91 50       	subi	r25, 0x01	; 1
    27a6:	a1 f0       	breq	.+40     	; 0x27d0 <__addsf3x+0x9a>
    27a8:	ff 0f       	add	r31, r31
    27aa:	bb 1f       	adc	r27, r27
    27ac:	66 1f       	adc	r22, r22
    27ae:	77 1f       	adc	r23, r23
    27b0:	88 1f       	adc	r24, r24
    27b2:	c2 f7       	brpl	.-16     	; 0x27a4 <__addsf3x+0x6e>
    27b4:	0e c0       	rjmp	.+28     	; 0x27d2 <__addsf3x+0x9c>
    27b6:	ba 0f       	add	r27, r26
    27b8:	62 1f       	adc	r22, r18
    27ba:	73 1f       	adc	r23, r19
    27bc:	84 1f       	adc	r24, r20
    27be:	48 f4       	brcc	.+18     	; 0x27d2 <__addsf3x+0x9c>
    27c0:	87 95       	ror	r24
    27c2:	77 95       	ror	r23
    27c4:	67 95       	ror	r22
    27c6:	b7 95       	ror	r27
    27c8:	f7 95       	ror	r31
    27ca:	9e 3f       	cpi	r25, 0xFE	; 254
    27cc:	08 f0       	brcs	.+2      	; 0x27d0 <__addsf3x+0x9a>
    27ce:	b0 cf       	rjmp	.-160    	; 0x2730 <__addsf3+0x28>
    27d0:	93 95       	inc	r25
    27d2:	88 0f       	add	r24, r24
    27d4:	08 f0       	brcs	.+2      	; 0x27d8 <__addsf3x+0xa2>
    27d6:	99 27       	eor	r25, r25
    27d8:	ee 0f       	add	r30, r30
    27da:	97 95       	ror	r25
    27dc:	87 95       	ror	r24
    27de:	08 95       	ret

000027e0 <__divsf3>:
    27e0:	0e 94 04 14 	call	0x2808	; 0x2808 <__divsf3x>
    27e4:	0c 94 e5 14 	jmp	0x29ca	; 0x29ca <__fp_round>
    27e8:	0e 94 de 14 	call	0x29bc	; 0x29bc <__fp_pscB>
    27ec:	58 f0       	brcs	.+22     	; 0x2804 <__divsf3+0x24>
    27ee:	0e 94 d7 14 	call	0x29ae	; 0x29ae <__fp_pscA>
    27f2:	40 f0       	brcs	.+16     	; 0x2804 <__divsf3+0x24>
    27f4:	29 f4       	brne	.+10     	; 0x2800 <__divsf3+0x20>
    27f6:	5f 3f       	cpi	r21, 0xFF	; 255
    27f8:	29 f0       	breq	.+10     	; 0x2804 <__divsf3+0x24>
    27fa:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__fp_inf>
    27fe:	51 11       	cpse	r21, r1
    2800:	0c 94 19 15 	jmp	0x2a32	; 0x2a32 <__fp_szero>
    2804:	0c 94 d4 14 	jmp	0x29a8	; 0x29a8 <__fp_nan>

00002808 <__divsf3x>:
    2808:	0e 94 f6 14 	call	0x29ec	; 0x29ec <__fp_split3>
    280c:	68 f3       	brcs	.-38     	; 0x27e8 <__divsf3+0x8>

0000280e <__divsf3_pse>:
    280e:	99 23       	and	r25, r25
    2810:	b1 f3       	breq	.-20     	; 0x27fe <__divsf3+0x1e>
    2812:	55 23       	and	r21, r21
    2814:	91 f3       	breq	.-28     	; 0x27fa <__divsf3+0x1a>
    2816:	95 1b       	sub	r25, r21
    2818:	55 0b       	sbc	r21, r21
    281a:	bb 27       	eor	r27, r27
    281c:	aa 27       	eor	r26, r26
    281e:	62 17       	cp	r22, r18
    2820:	73 07       	cpc	r23, r19
    2822:	84 07       	cpc	r24, r20
    2824:	38 f0       	brcs	.+14     	; 0x2834 <__divsf3_pse+0x26>
    2826:	9f 5f       	subi	r25, 0xFF	; 255
    2828:	5f 4f       	sbci	r21, 0xFF	; 255
    282a:	22 0f       	add	r18, r18
    282c:	33 1f       	adc	r19, r19
    282e:	44 1f       	adc	r20, r20
    2830:	aa 1f       	adc	r26, r26
    2832:	a9 f3       	breq	.-22     	; 0x281e <__divsf3_pse+0x10>
    2834:	35 d0       	rcall	.+106    	; 0x28a0 <__divsf3_pse+0x92>
    2836:	0e 2e       	mov	r0, r30
    2838:	3a f0       	brmi	.+14     	; 0x2848 <__divsf3_pse+0x3a>
    283a:	e0 e8       	ldi	r30, 0x80	; 128
    283c:	32 d0       	rcall	.+100    	; 0x28a2 <__divsf3_pse+0x94>
    283e:	91 50       	subi	r25, 0x01	; 1
    2840:	50 40       	sbci	r21, 0x00	; 0
    2842:	e6 95       	lsr	r30
    2844:	00 1c       	adc	r0, r0
    2846:	ca f7       	brpl	.-14     	; 0x283a <__divsf3_pse+0x2c>
    2848:	2b d0       	rcall	.+86     	; 0x28a0 <__divsf3_pse+0x92>
    284a:	fe 2f       	mov	r31, r30
    284c:	29 d0       	rcall	.+82     	; 0x28a0 <__divsf3_pse+0x92>
    284e:	66 0f       	add	r22, r22
    2850:	77 1f       	adc	r23, r23
    2852:	88 1f       	adc	r24, r24
    2854:	bb 1f       	adc	r27, r27
    2856:	26 17       	cp	r18, r22
    2858:	37 07       	cpc	r19, r23
    285a:	48 07       	cpc	r20, r24
    285c:	ab 07       	cpc	r26, r27
    285e:	b0 e8       	ldi	r27, 0x80	; 128
    2860:	09 f0       	breq	.+2      	; 0x2864 <__divsf3_pse+0x56>
    2862:	bb 0b       	sbc	r27, r27
    2864:	80 2d       	mov	r24, r0
    2866:	bf 01       	movw	r22, r30
    2868:	ff 27       	eor	r31, r31
    286a:	93 58       	subi	r25, 0x83	; 131
    286c:	5f 4f       	sbci	r21, 0xFF	; 255
    286e:	3a f0       	brmi	.+14     	; 0x287e <__divsf3_pse+0x70>
    2870:	9e 3f       	cpi	r25, 0xFE	; 254
    2872:	51 05       	cpc	r21, r1
    2874:	78 f0       	brcs	.+30     	; 0x2894 <__divsf3_pse+0x86>
    2876:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__fp_inf>
    287a:	0c 94 19 15 	jmp	0x2a32	; 0x2a32 <__fp_szero>
    287e:	5f 3f       	cpi	r21, 0xFF	; 255
    2880:	e4 f3       	brlt	.-8      	; 0x287a <__divsf3_pse+0x6c>
    2882:	98 3e       	cpi	r25, 0xE8	; 232
    2884:	d4 f3       	brlt	.-12     	; 0x287a <__divsf3_pse+0x6c>
    2886:	86 95       	lsr	r24
    2888:	77 95       	ror	r23
    288a:	67 95       	ror	r22
    288c:	b7 95       	ror	r27
    288e:	f7 95       	ror	r31
    2890:	9f 5f       	subi	r25, 0xFF	; 255
    2892:	c9 f7       	brne	.-14     	; 0x2886 <__divsf3_pse+0x78>
    2894:	88 0f       	add	r24, r24
    2896:	91 1d       	adc	r25, r1
    2898:	96 95       	lsr	r25
    289a:	87 95       	ror	r24
    289c:	97 f9       	bld	r25, 7
    289e:	08 95       	ret
    28a0:	e1 e0       	ldi	r30, 0x01	; 1
    28a2:	66 0f       	add	r22, r22
    28a4:	77 1f       	adc	r23, r23
    28a6:	88 1f       	adc	r24, r24
    28a8:	bb 1f       	adc	r27, r27
    28aa:	62 17       	cp	r22, r18
    28ac:	73 07       	cpc	r23, r19
    28ae:	84 07       	cpc	r24, r20
    28b0:	ba 07       	cpc	r27, r26
    28b2:	20 f0       	brcs	.+8      	; 0x28bc <__divsf3_pse+0xae>
    28b4:	62 1b       	sub	r22, r18
    28b6:	73 0b       	sbc	r23, r19
    28b8:	84 0b       	sbc	r24, r20
    28ba:	ba 0b       	sbc	r27, r26
    28bc:	ee 1f       	adc	r30, r30
    28be:	88 f7       	brcc	.-30     	; 0x28a2 <__divsf3_pse+0x94>
    28c0:	e0 95       	com	r30
    28c2:	08 95       	ret

000028c4 <__fixunssfsi>:
    28c4:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__fp_splitA>
    28c8:	88 f0       	brcs	.+34     	; 0x28ec <__fixunssfsi+0x28>
    28ca:	9f 57       	subi	r25, 0x7F	; 127
    28cc:	98 f0       	brcs	.+38     	; 0x28f4 <__fixunssfsi+0x30>
    28ce:	b9 2f       	mov	r27, r25
    28d0:	99 27       	eor	r25, r25
    28d2:	b7 51       	subi	r27, 0x17	; 23
    28d4:	b0 f0       	brcs	.+44     	; 0x2902 <__fixunssfsi+0x3e>
    28d6:	e1 f0       	breq	.+56     	; 0x2910 <__fixunssfsi+0x4c>
    28d8:	66 0f       	add	r22, r22
    28da:	77 1f       	adc	r23, r23
    28dc:	88 1f       	adc	r24, r24
    28de:	99 1f       	adc	r25, r25
    28e0:	1a f0       	brmi	.+6      	; 0x28e8 <__fixunssfsi+0x24>
    28e2:	ba 95       	dec	r27
    28e4:	c9 f7       	brne	.-14     	; 0x28d8 <__fixunssfsi+0x14>
    28e6:	14 c0       	rjmp	.+40     	; 0x2910 <__fixunssfsi+0x4c>
    28e8:	b1 30       	cpi	r27, 0x01	; 1
    28ea:	91 f0       	breq	.+36     	; 0x2910 <__fixunssfsi+0x4c>
    28ec:	0e 94 18 15 	call	0x2a30	; 0x2a30 <__fp_zero>
    28f0:	b1 e0       	ldi	r27, 0x01	; 1
    28f2:	08 95       	ret
    28f4:	0c 94 18 15 	jmp	0x2a30	; 0x2a30 <__fp_zero>
    28f8:	67 2f       	mov	r22, r23
    28fa:	78 2f       	mov	r23, r24
    28fc:	88 27       	eor	r24, r24
    28fe:	b8 5f       	subi	r27, 0xF8	; 248
    2900:	39 f0       	breq	.+14     	; 0x2910 <__fixunssfsi+0x4c>
    2902:	b9 3f       	cpi	r27, 0xF9	; 249
    2904:	cc f3       	brlt	.-14     	; 0x28f8 <__fixunssfsi+0x34>
    2906:	86 95       	lsr	r24
    2908:	77 95       	ror	r23
    290a:	67 95       	ror	r22
    290c:	b3 95       	inc	r27
    290e:	d9 f7       	brne	.-10     	; 0x2906 <__fixunssfsi+0x42>
    2910:	3e f4       	brtc	.+14     	; 0x2920 <__fixunssfsi+0x5c>
    2912:	90 95       	com	r25
    2914:	80 95       	com	r24
    2916:	70 95       	com	r23
    2918:	61 95       	neg	r22
    291a:	7f 4f       	sbci	r23, 0xFF	; 255
    291c:	8f 4f       	sbci	r24, 0xFF	; 255
    291e:	9f 4f       	sbci	r25, 0xFF	; 255
    2920:	08 95       	ret

00002922 <__floatunsisf>:
    2922:	e8 94       	clt
    2924:	09 c0       	rjmp	.+18     	; 0x2938 <__floatsisf+0x12>

00002926 <__floatsisf>:
    2926:	97 fb       	bst	r25, 7
    2928:	3e f4       	brtc	.+14     	; 0x2938 <__floatsisf+0x12>
    292a:	90 95       	com	r25
    292c:	80 95       	com	r24
    292e:	70 95       	com	r23
    2930:	61 95       	neg	r22
    2932:	7f 4f       	sbci	r23, 0xFF	; 255
    2934:	8f 4f       	sbci	r24, 0xFF	; 255
    2936:	9f 4f       	sbci	r25, 0xFF	; 255
    2938:	99 23       	and	r25, r25
    293a:	a9 f0       	breq	.+42     	; 0x2966 <__floatsisf+0x40>
    293c:	f9 2f       	mov	r31, r25
    293e:	96 e9       	ldi	r25, 0x96	; 150
    2940:	bb 27       	eor	r27, r27
    2942:	93 95       	inc	r25
    2944:	f6 95       	lsr	r31
    2946:	87 95       	ror	r24
    2948:	77 95       	ror	r23
    294a:	67 95       	ror	r22
    294c:	b7 95       	ror	r27
    294e:	f1 11       	cpse	r31, r1
    2950:	f8 cf       	rjmp	.-16     	; 0x2942 <__floatsisf+0x1c>
    2952:	fa f4       	brpl	.+62     	; 0x2992 <__floatsisf+0x6c>
    2954:	bb 0f       	add	r27, r27
    2956:	11 f4       	brne	.+4      	; 0x295c <__floatsisf+0x36>
    2958:	60 ff       	sbrs	r22, 0
    295a:	1b c0       	rjmp	.+54     	; 0x2992 <__floatsisf+0x6c>
    295c:	6f 5f       	subi	r22, 0xFF	; 255
    295e:	7f 4f       	sbci	r23, 0xFF	; 255
    2960:	8f 4f       	sbci	r24, 0xFF	; 255
    2962:	9f 4f       	sbci	r25, 0xFF	; 255
    2964:	16 c0       	rjmp	.+44     	; 0x2992 <__floatsisf+0x6c>
    2966:	88 23       	and	r24, r24
    2968:	11 f0       	breq	.+4      	; 0x296e <__floatsisf+0x48>
    296a:	96 e9       	ldi	r25, 0x96	; 150
    296c:	11 c0       	rjmp	.+34     	; 0x2990 <__floatsisf+0x6a>
    296e:	77 23       	and	r23, r23
    2970:	21 f0       	breq	.+8      	; 0x297a <__floatsisf+0x54>
    2972:	9e e8       	ldi	r25, 0x8E	; 142
    2974:	87 2f       	mov	r24, r23
    2976:	76 2f       	mov	r23, r22
    2978:	05 c0       	rjmp	.+10     	; 0x2984 <__floatsisf+0x5e>
    297a:	66 23       	and	r22, r22
    297c:	71 f0       	breq	.+28     	; 0x299a <__floatsisf+0x74>
    297e:	96 e8       	ldi	r25, 0x86	; 134
    2980:	86 2f       	mov	r24, r22
    2982:	70 e0       	ldi	r23, 0x00	; 0
    2984:	60 e0       	ldi	r22, 0x00	; 0
    2986:	2a f0       	brmi	.+10     	; 0x2992 <__floatsisf+0x6c>
    2988:	9a 95       	dec	r25
    298a:	66 0f       	add	r22, r22
    298c:	77 1f       	adc	r23, r23
    298e:	88 1f       	adc	r24, r24
    2990:	da f7       	brpl	.-10     	; 0x2988 <__floatsisf+0x62>
    2992:	88 0f       	add	r24, r24
    2994:	96 95       	lsr	r25
    2996:	87 95       	ror	r24
    2998:	97 f9       	bld	r25, 7
    299a:	08 95       	ret

0000299c <__fp_inf>:
    299c:	97 f9       	bld	r25, 7
    299e:	9f 67       	ori	r25, 0x7F	; 127
    29a0:	80 e8       	ldi	r24, 0x80	; 128
    29a2:	70 e0       	ldi	r23, 0x00	; 0
    29a4:	60 e0       	ldi	r22, 0x00	; 0
    29a6:	08 95       	ret

000029a8 <__fp_nan>:
    29a8:	9f ef       	ldi	r25, 0xFF	; 255
    29aa:	80 ec       	ldi	r24, 0xC0	; 192
    29ac:	08 95       	ret

000029ae <__fp_pscA>:
    29ae:	00 24       	eor	r0, r0
    29b0:	0a 94       	dec	r0
    29b2:	16 16       	cp	r1, r22
    29b4:	17 06       	cpc	r1, r23
    29b6:	18 06       	cpc	r1, r24
    29b8:	09 06       	cpc	r0, r25
    29ba:	08 95       	ret

000029bc <__fp_pscB>:
    29bc:	00 24       	eor	r0, r0
    29be:	0a 94       	dec	r0
    29c0:	12 16       	cp	r1, r18
    29c2:	13 06       	cpc	r1, r19
    29c4:	14 06       	cpc	r1, r20
    29c6:	05 06       	cpc	r0, r21
    29c8:	08 95       	ret

000029ca <__fp_round>:
    29ca:	09 2e       	mov	r0, r25
    29cc:	03 94       	inc	r0
    29ce:	00 0c       	add	r0, r0
    29d0:	11 f4       	brne	.+4      	; 0x29d6 <__fp_round+0xc>
    29d2:	88 23       	and	r24, r24
    29d4:	52 f0       	brmi	.+20     	; 0x29ea <__fp_round+0x20>
    29d6:	bb 0f       	add	r27, r27
    29d8:	40 f4       	brcc	.+16     	; 0x29ea <__fp_round+0x20>
    29da:	bf 2b       	or	r27, r31
    29dc:	11 f4       	brne	.+4      	; 0x29e2 <__fp_round+0x18>
    29de:	60 ff       	sbrs	r22, 0
    29e0:	04 c0       	rjmp	.+8      	; 0x29ea <__fp_round+0x20>
    29e2:	6f 5f       	subi	r22, 0xFF	; 255
    29e4:	7f 4f       	sbci	r23, 0xFF	; 255
    29e6:	8f 4f       	sbci	r24, 0xFF	; 255
    29e8:	9f 4f       	sbci	r25, 0xFF	; 255
    29ea:	08 95       	ret

000029ec <__fp_split3>:
    29ec:	57 fd       	sbrc	r21, 7
    29ee:	90 58       	subi	r25, 0x80	; 128
    29f0:	44 0f       	add	r20, r20
    29f2:	55 1f       	adc	r21, r21
    29f4:	59 f0       	breq	.+22     	; 0x2a0c <__fp_splitA+0x10>
    29f6:	5f 3f       	cpi	r21, 0xFF	; 255
    29f8:	71 f0       	breq	.+28     	; 0x2a16 <__fp_splitA+0x1a>
    29fa:	47 95       	ror	r20

000029fc <__fp_splitA>:
    29fc:	88 0f       	add	r24, r24
    29fe:	97 fb       	bst	r25, 7
    2a00:	99 1f       	adc	r25, r25
    2a02:	61 f0       	breq	.+24     	; 0x2a1c <__fp_splitA+0x20>
    2a04:	9f 3f       	cpi	r25, 0xFF	; 255
    2a06:	79 f0       	breq	.+30     	; 0x2a26 <__fp_splitA+0x2a>
    2a08:	87 95       	ror	r24
    2a0a:	08 95       	ret
    2a0c:	12 16       	cp	r1, r18
    2a0e:	13 06       	cpc	r1, r19
    2a10:	14 06       	cpc	r1, r20
    2a12:	55 1f       	adc	r21, r21
    2a14:	f2 cf       	rjmp	.-28     	; 0x29fa <__fp_split3+0xe>
    2a16:	46 95       	lsr	r20
    2a18:	f1 df       	rcall	.-30     	; 0x29fc <__fp_splitA>
    2a1a:	08 c0       	rjmp	.+16     	; 0x2a2c <__fp_splitA+0x30>
    2a1c:	16 16       	cp	r1, r22
    2a1e:	17 06       	cpc	r1, r23
    2a20:	18 06       	cpc	r1, r24
    2a22:	99 1f       	adc	r25, r25
    2a24:	f1 cf       	rjmp	.-30     	; 0x2a08 <__fp_splitA+0xc>
    2a26:	86 95       	lsr	r24
    2a28:	71 05       	cpc	r23, r1
    2a2a:	61 05       	cpc	r22, r1
    2a2c:	08 94       	sec
    2a2e:	08 95       	ret

00002a30 <__fp_zero>:
    2a30:	e8 94       	clt

00002a32 <__fp_szero>:
    2a32:	bb 27       	eor	r27, r27
    2a34:	66 27       	eor	r22, r22
    2a36:	77 27       	eor	r23, r23
    2a38:	cb 01       	movw	r24, r22
    2a3a:	97 f9       	bld	r25, 7
    2a3c:	08 95       	ret
    2a3e:	16 f0       	brts	.+4      	; 0x2a44 <__fp_szero+0x12>
    2a40:	0c 94 dc 15 	jmp	0x2bb8	; 0x2bb8 <__fp_mpack>
    2a44:	0c 94 d4 14 	jmp	0x29a8	; 0x29a8 <__fp_nan>
    2a48:	68 94       	set
    2a4a:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__fp_inf>

00002a4e <log>:
    2a4e:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__fp_splitA>
    2a52:	a8 f3       	brcs	.-22     	; 0x2a3e <__fp_szero+0xc>
    2a54:	99 23       	and	r25, r25
    2a56:	c1 f3       	breq	.-16     	; 0x2a48 <__fp_szero+0x16>
    2a58:	ae f3       	brts	.-22     	; 0x2a44 <__fp_szero+0x12>
    2a5a:	df 93       	push	r29
    2a5c:	cf 93       	push	r28
    2a5e:	1f 93       	push	r17
    2a60:	0f 93       	push	r16
    2a62:	ff 92       	push	r15
    2a64:	c9 2f       	mov	r28, r25
    2a66:	dd 27       	eor	r29, r29
    2a68:	88 23       	and	r24, r24
    2a6a:	2a f0       	brmi	.+10     	; 0x2a76 <log+0x28>
    2a6c:	21 97       	sbiw	r28, 0x01	; 1
    2a6e:	66 0f       	add	r22, r22
    2a70:	77 1f       	adc	r23, r23
    2a72:	88 1f       	adc	r24, r24
    2a74:	da f7       	brpl	.-10     	; 0x2a6c <log+0x1e>
    2a76:	20 e0       	ldi	r18, 0x00	; 0
    2a78:	30 e0       	ldi	r19, 0x00	; 0
    2a7a:	40 e8       	ldi	r20, 0x80	; 128
    2a7c:	5f eb       	ldi	r21, 0xBF	; 191
    2a7e:	9f e3       	ldi	r25, 0x3F	; 63
    2a80:	88 39       	cpi	r24, 0x98	; 152
    2a82:	20 f0       	brcs	.+8      	; 0x2a8c <log+0x3e>
    2a84:	80 3e       	cpi	r24, 0xE0	; 224
    2a86:	38 f0       	brcs	.+14     	; 0x2a96 <log+0x48>
    2a88:	21 96       	adiw	r28, 0x01	; 1
    2a8a:	8f 77       	andi	r24, 0x7F	; 127
    2a8c:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    2a90:	e4 e5       	ldi	r30, 0x54	; 84
    2a92:	f0 e0       	ldi	r31, 0x00	; 0
    2a94:	04 c0       	rjmp	.+8      	; 0x2a9e <log+0x50>
    2a96:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    2a9a:	e1 e8       	ldi	r30, 0x81	; 129
    2a9c:	f0 e0       	ldi	r31, 0x00	; 0
    2a9e:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <__fp_powser>
    2aa2:	8b 01       	movw	r16, r22
    2aa4:	be 01       	movw	r22, r28
    2aa6:	ec 01       	movw	r28, r24
    2aa8:	fb 2e       	mov	r15, r27
    2aaa:	6f 57       	subi	r22, 0x7F	; 127
    2aac:	71 09       	sbc	r23, r1
    2aae:	75 95       	asr	r23
    2ab0:	77 1f       	adc	r23, r23
    2ab2:	88 0b       	sbc	r24, r24
    2ab4:	99 0b       	sbc	r25, r25
    2ab6:	0e 94 93 14 	call	0x2926	; 0x2926 <__floatsisf>
    2aba:	28 e1       	ldi	r18, 0x18	; 24
    2abc:	32 e7       	ldi	r19, 0x72	; 114
    2abe:	41 e3       	ldi	r20, 0x31	; 49
    2ac0:	5f e3       	ldi	r21, 0x3F	; 63
    2ac2:	0e 94 82 15 	call	0x2b04	; 0x2b04 <__mulsf3x>
    2ac6:	af 2d       	mov	r26, r15
    2ac8:	98 01       	movw	r18, r16
    2aca:	ae 01       	movw	r20, r28
    2acc:	ff 90       	pop	r15
    2ace:	0f 91       	pop	r16
    2ad0:	1f 91       	pop	r17
    2ad2:	cf 91       	pop	r28
    2ad4:	df 91       	pop	r29
    2ad6:	0e 94 9b 13 	call	0x2736	; 0x2736 <__addsf3x>
    2ada:	0c 94 e5 14 	jmp	0x29ca	; 0x29ca <__fp_round>

00002ade <__mulsf3>:
    2ade:	0e 94 82 15 	call	0x2b04	; 0x2b04 <__mulsf3x>
    2ae2:	0c 94 e5 14 	jmp	0x29ca	; 0x29ca <__fp_round>
    2ae6:	0e 94 d7 14 	call	0x29ae	; 0x29ae <__fp_pscA>
    2aea:	38 f0       	brcs	.+14     	; 0x2afa <__mulsf3+0x1c>
    2aec:	0e 94 de 14 	call	0x29bc	; 0x29bc <__fp_pscB>
    2af0:	20 f0       	brcs	.+8      	; 0x2afa <__mulsf3+0x1c>
    2af2:	95 23       	and	r25, r21
    2af4:	11 f0       	breq	.+4      	; 0x2afa <__mulsf3+0x1c>
    2af6:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__fp_inf>
    2afa:	0c 94 d4 14 	jmp	0x29a8	; 0x29a8 <__fp_nan>
    2afe:	11 24       	eor	r1, r1
    2b00:	0c 94 19 15 	jmp	0x2a32	; 0x2a32 <__fp_szero>

00002b04 <__mulsf3x>:
    2b04:	0e 94 f6 14 	call	0x29ec	; 0x29ec <__fp_split3>
    2b08:	70 f3       	brcs	.-36     	; 0x2ae6 <__mulsf3+0x8>

00002b0a <__mulsf3_pse>:
    2b0a:	95 9f       	mul	r25, r21
    2b0c:	c1 f3       	breq	.-16     	; 0x2afe <__mulsf3+0x20>
    2b0e:	95 0f       	add	r25, r21
    2b10:	50 e0       	ldi	r21, 0x00	; 0
    2b12:	55 1f       	adc	r21, r21
    2b14:	62 9f       	mul	r22, r18
    2b16:	f0 01       	movw	r30, r0
    2b18:	72 9f       	mul	r23, r18
    2b1a:	bb 27       	eor	r27, r27
    2b1c:	f0 0d       	add	r31, r0
    2b1e:	b1 1d       	adc	r27, r1
    2b20:	63 9f       	mul	r22, r19
    2b22:	aa 27       	eor	r26, r26
    2b24:	f0 0d       	add	r31, r0
    2b26:	b1 1d       	adc	r27, r1
    2b28:	aa 1f       	adc	r26, r26
    2b2a:	64 9f       	mul	r22, r20
    2b2c:	66 27       	eor	r22, r22
    2b2e:	b0 0d       	add	r27, r0
    2b30:	a1 1d       	adc	r26, r1
    2b32:	66 1f       	adc	r22, r22
    2b34:	82 9f       	mul	r24, r18
    2b36:	22 27       	eor	r18, r18
    2b38:	b0 0d       	add	r27, r0
    2b3a:	a1 1d       	adc	r26, r1
    2b3c:	62 1f       	adc	r22, r18
    2b3e:	73 9f       	mul	r23, r19
    2b40:	b0 0d       	add	r27, r0
    2b42:	a1 1d       	adc	r26, r1
    2b44:	62 1f       	adc	r22, r18
    2b46:	83 9f       	mul	r24, r19
    2b48:	a0 0d       	add	r26, r0
    2b4a:	61 1d       	adc	r22, r1
    2b4c:	22 1f       	adc	r18, r18
    2b4e:	74 9f       	mul	r23, r20
    2b50:	33 27       	eor	r19, r19
    2b52:	a0 0d       	add	r26, r0
    2b54:	61 1d       	adc	r22, r1
    2b56:	23 1f       	adc	r18, r19
    2b58:	84 9f       	mul	r24, r20
    2b5a:	60 0d       	add	r22, r0
    2b5c:	21 1d       	adc	r18, r1
    2b5e:	82 2f       	mov	r24, r18
    2b60:	76 2f       	mov	r23, r22
    2b62:	6a 2f       	mov	r22, r26
    2b64:	11 24       	eor	r1, r1
    2b66:	9f 57       	subi	r25, 0x7F	; 127
    2b68:	50 40       	sbci	r21, 0x00	; 0
    2b6a:	9a f0       	brmi	.+38     	; 0x2b92 <__mulsf3_pse+0x88>
    2b6c:	f1 f0       	breq	.+60     	; 0x2baa <__mulsf3_pse+0xa0>
    2b6e:	88 23       	and	r24, r24
    2b70:	4a f0       	brmi	.+18     	; 0x2b84 <__mulsf3_pse+0x7a>
    2b72:	ee 0f       	add	r30, r30
    2b74:	ff 1f       	adc	r31, r31
    2b76:	bb 1f       	adc	r27, r27
    2b78:	66 1f       	adc	r22, r22
    2b7a:	77 1f       	adc	r23, r23
    2b7c:	88 1f       	adc	r24, r24
    2b7e:	91 50       	subi	r25, 0x01	; 1
    2b80:	50 40       	sbci	r21, 0x00	; 0
    2b82:	a9 f7       	brne	.-22     	; 0x2b6e <__mulsf3_pse+0x64>
    2b84:	9e 3f       	cpi	r25, 0xFE	; 254
    2b86:	51 05       	cpc	r21, r1
    2b88:	80 f0       	brcs	.+32     	; 0x2baa <__mulsf3_pse+0xa0>
    2b8a:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__fp_inf>
    2b8e:	0c 94 19 15 	jmp	0x2a32	; 0x2a32 <__fp_szero>
    2b92:	5f 3f       	cpi	r21, 0xFF	; 255
    2b94:	e4 f3       	brlt	.-8      	; 0x2b8e <__mulsf3_pse+0x84>
    2b96:	98 3e       	cpi	r25, 0xE8	; 232
    2b98:	d4 f3       	brlt	.-12     	; 0x2b8e <__mulsf3_pse+0x84>
    2b9a:	86 95       	lsr	r24
    2b9c:	77 95       	ror	r23
    2b9e:	67 95       	ror	r22
    2ba0:	b7 95       	ror	r27
    2ba2:	f7 95       	ror	r31
    2ba4:	e7 95       	ror	r30
    2ba6:	9f 5f       	subi	r25, 0xFF	; 255
    2ba8:	c1 f7       	brne	.-16     	; 0x2b9a <__mulsf3_pse+0x90>
    2baa:	fe 2b       	or	r31, r30
    2bac:	88 0f       	add	r24, r24
    2bae:	91 1d       	adc	r25, r1
    2bb0:	96 95       	lsr	r25
    2bb2:	87 95       	ror	r24
    2bb4:	97 f9       	bld	r25, 7
    2bb6:	08 95       	ret

00002bb8 <__fp_mpack>:
    2bb8:	9f 3f       	cpi	r25, 0xFF	; 255
    2bba:	31 f0       	breq	.+12     	; 0x2bc8 <__fp_mpack_finite+0xc>

00002bbc <__fp_mpack_finite>:
    2bbc:	91 50       	subi	r25, 0x01	; 1
    2bbe:	20 f4       	brcc	.+8      	; 0x2bc8 <__fp_mpack_finite+0xc>
    2bc0:	87 95       	ror	r24
    2bc2:	77 95       	ror	r23
    2bc4:	67 95       	ror	r22
    2bc6:	b7 95       	ror	r27
    2bc8:	88 0f       	add	r24, r24
    2bca:	91 1d       	adc	r25, r1
    2bcc:	96 95       	lsr	r25
    2bce:	87 95       	ror	r24
    2bd0:	97 f9       	bld	r25, 7
    2bd2:	08 95       	ret

00002bd4 <__fp_powser>:
    2bd4:	df 93       	push	r29
    2bd6:	cf 93       	push	r28
    2bd8:	1f 93       	push	r17
    2bda:	0f 93       	push	r16
    2bdc:	ff 92       	push	r15
    2bde:	ef 92       	push	r14
    2be0:	df 92       	push	r13
    2be2:	7b 01       	movw	r14, r22
    2be4:	8c 01       	movw	r16, r24
    2be6:	68 94       	set
    2be8:	06 c0       	rjmp	.+12     	; 0x2bf6 <__fp_powser+0x22>
    2bea:	da 2e       	mov	r13, r26
    2bec:	ef 01       	movw	r28, r30
    2bee:	0e 94 82 15 	call	0x2b04	; 0x2b04 <__mulsf3x>
    2bf2:	fe 01       	movw	r30, r28
    2bf4:	e8 94       	clt
    2bf6:	a5 91       	lpm	r26, Z+
    2bf8:	25 91       	lpm	r18, Z+
    2bfa:	35 91       	lpm	r19, Z+
    2bfc:	45 91       	lpm	r20, Z+
    2bfe:	55 91       	lpm	r21, Z+
    2c00:	a6 f3       	brts	.-24     	; 0x2bea <__fp_powser+0x16>
    2c02:	ef 01       	movw	r28, r30
    2c04:	0e 94 9b 13 	call	0x2736	; 0x2736 <__addsf3x>
    2c08:	fe 01       	movw	r30, r28
    2c0a:	97 01       	movw	r18, r14
    2c0c:	a8 01       	movw	r20, r16
    2c0e:	da 94       	dec	r13
    2c10:	69 f7       	brne	.-38     	; 0x2bec <__fp_powser+0x18>
    2c12:	df 90       	pop	r13
    2c14:	ef 90       	pop	r14
    2c16:	ff 90       	pop	r15
    2c18:	0f 91       	pop	r16
    2c1a:	1f 91       	pop	r17
    2c1c:	cf 91       	pop	r28
    2c1e:	df 91       	pop	r29
    2c20:	08 95       	ret

00002c22 <memcpy>:
    2c22:	fb 01       	movw	r30, r22
    2c24:	dc 01       	movw	r26, r24
    2c26:	02 c0       	rjmp	.+4      	; 0x2c2c <memcpy+0xa>
    2c28:	01 90       	ld	r0, Z+
    2c2a:	0d 92       	st	X+, r0
    2c2c:	41 50       	subi	r20, 0x01	; 1
    2c2e:	50 40       	sbci	r21, 0x00	; 0
    2c30:	d8 f7       	brcc	.-10     	; 0x2c28 <memcpy+0x6>
    2c32:	08 95       	ret

00002c34 <__itoa_ncheck>:
    2c34:	bb 27       	eor	r27, r27
    2c36:	4a 30       	cpi	r20, 0x0A	; 10
    2c38:	31 f4       	brne	.+12     	; 0x2c46 <__itoa_ncheck+0x12>
    2c3a:	99 23       	and	r25, r25
    2c3c:	22 f4       	brpl	.+8      	; 0x2c46 <__itoa_ncheck+0x12>
    2c3e:	bd e2       	ldi	r27, 0x2D	; 45
    2c40:	90 95       	com	r25
    2c42:	81 95       	neg	r24
    2c44:	9f 4f       	sbci	r25, 0xFF	; 255
    2c46:	0c 94 26 16 	jmp	0x2c4c	; 0x2c4c <__utoa_common>

00002c4a <__utoa_ncheck>:
    2c4a:	bb 27       	eor	r27, r27

00002c4c <__utoa_common>:
    2c4c:	fb 01       	movw	r30, r22
    2c4e:	55 27       	eor	r21, r21
    2c50:	aa 27       	eor	r26, r26
    2c52:	88 0f       	add	r24, r24
    2c54:	99 1f       	adc	r25, r25
    2c56:	aa 1f       	adc	r26, r26
    2c58:	a4 17       	cp	r26, r20
    2c5a:	10 f0       	brcs	.+4      	; 0x2c60 <__utoa_common+0x14>
    2c5c:	a4 1b       	sub	r26, r20
    2c5e:	83 95       	inc	r24
    2c60:	50 51       	subi	r21, 0x10	; 16
    2c62:	b9 f7       	brne	.-18     	; 0x2c52 <__utoa_common+0x6>
    2c64:	a0 5d       	subi	r26, 0xD0	; 208
    2c66:	aa 33       	cpi	r26, 0x3A	; 58
    2c68:	08 f0       	brcs	.+2      	; 0x2c6c <__utoa_common+0x20>
    2c6a:	a9 5d       	subi	r26, 0xD9	; 217
    2c6c:	a1 93       	st	Z+, r26
    2c6e:	00 97       	sbiw	r24, 0x00	; 0
    2c70:	79 f7       	brne	.-34     	; 0x2c50 <__utoa_common+0x4>
    2c72:	b1 11       	cpse	r27, r1
    2c74:	b1 93       	st	Z+, r27
    2c76:	11 92       	st	Z+, r1
    2c78:	cb 01       	movw	r24, r22
    2c7a:	0c 94 3f 16 	jmp	0x2c7e	; 0x2c7e <strrev>

00002c7e <strrev>:
    2c7e:	dc 01       	movw	r26, r24
    2c80:	fc 01       	movw	r30, r24
    2c82:	67 2f       	mov	r22, r23
    2c84:	71 91       	ld	r23, Z+
    2c86:	77 23       	and	r23, r23
    2c88:	e1 f7       	brne	.-8      	; 0x2c82 <strrev+0x4>
    2c8a:	32 97       	sbiw	r30, 0x02	; 2
    2c8c:	04 c0       	rjmp	.+8      	; 0x2c96 <strrev+0x18>
    2c8e:	7c 91       	ld	r23, X
    2c90:	6d 93       	st	X+, r22
    2c92:	70 83       	st	Z, r23
    2c94:	62 91       	ld	r22, -Z
    2c96:	ae 17       	cp	r26, r30
    2c98:	bf 07       	cpc	r27, r31
    2c9a:	c8 f3       	brcs	.-14     	; 0x2c8e <strrev+0x10>
    2c9c:	08 95       	ret

00002c9e <_exit>:
    2c9e:	f8 94       	cli

00002ca0 <__stop_program>:
    2ca0:	ff cf       	rjmp	.-2      	; 0x2ca0 <__stop_program>
