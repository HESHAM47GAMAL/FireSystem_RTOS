
FireAlarm_System.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002c2c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000172  00800060  00002c2c  00002cc0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004fc  008001d2  008001d2  00002e32  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002e32  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002e64  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b8  00000000  00000000  00002ea0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006a0d  00000000  00000000  00003458  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001930  00000000  00000000  00009e65  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000039f3  00000000  00000000  0000b795  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ee8  00000000  00000000  0000f188  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021db  00000000  00000000  00010070  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000558a  00000000  00000000  0001224b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000508  00000000  00000000  000177d5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       8:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      10:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      14:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      18:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      24:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      28:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      2c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      30:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      34:	0c 94 b4 12 	jmp	0x2568	; 0x2568 <__vector_13>
      38:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      3c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      40:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      44:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      48:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      4c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      50:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      54:	08 00       	.word	0x0008	; ????
      56:	00 00       	nop
      58:	be 92       	st	-X, r11
      5a:	24 49       	sbci	r18, 0x94	; 148
      5c:	12 3e       	cpi	r17, 0xE2	; 226
      5e:	ab aa       	std	Y+51, r10	; 0x33
      60:	aa 2a       	or	r10, r26
      62:	be cd       	rjmp	.-1156   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
      64:	cc cc       	rjmp	.-1640   	; 0xfffff9fe <__eeprom_end+0xff7ef9fe>
      66:	4c 3e       	cpi	r20, 0xEC	; 236
      68:	00 00       	nop
      6a:	00 80       	ld	r0, Z
      6c:	be ab       	std	Y+54, r27	; 0x36
      6e:	aa aa       	std	Y+50, r10	; 0x32
      70:	aa 3e       	cpi	r26, 0xEA	; 234
      72:	00 00       	nop
      74:	00 00       	nop
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	00 00       	nop
      7e:	00 00       	nop
      80:	00 08       	sbc	r0, r0
      82:	41 78       	andi	r20, 0x81	; 129
      84:	d3 bb       	out	0x13, r29	; 19
      86:	43 87       	std	Z+11, r20	; 0x0b
      88:	d1 13       	cpse	r29, r17
      8a:	3d 19       	sub	r19, r13
      8c:	0e 3c       	cpi	r16, 0xCE	; 206
      8e:	c3 bd       	out	0x23, r28	; 35
      90:	42 82       	std	Z+2, r4	; 0x02
      92:	ad 2b       	or	r26, r29
      94:	3e 68       	ori	r19, 0x8E	; 142
      96:	ec 82       	std	Y+4, r14	; 0x04
      98:	76 be       	out	0x36, r7	; 54
      9a:	d9 8f       	std	Y+25, r29	; 0x19
      9c:	e1 a9       	ldd	r30, Z+49	; 0x31
      9e:	3e 4c       	sbci	r19, 0xCE	; 206
      a0:	80 ef       	ldi	r24, 0xF0	; 240
      a2:	ff be       	out	0x3f, r15	; 63
      a4:	01 c4       	rjmp	.+2050   	; 0x8a8 <prvUnlockQueue+0x44>
      a6:	ff 7f       	andi	r31, 0xFF	; 255
      a8:	3f 00       	.word	0x003f	; ????
      aa:	00 00       	nop
	...

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf e5       	ldi	r28, 0x5F	; 95
      b4:	d8 e0       	ldi	r29, 0x08	; 8
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_copy_data>:
      ba:	11 e0       	ldi	r17, 0x01	; 1
      bc:	a0 e6       	ldi	r26, 0x60	; 96
      be:	b0 e0       	ldi	r27, 0x00	; 0
      c0:	ec e2       	ldi	r30, 0x2C	; 44
      c2:	fc e2       	ldi	r31, 0x2C	; 44
      c4:	02 c0       	rjmp	.+4      	; 0xca <__do_copy_data+0x10>
      c6:	05 90       	lpm	r0, Z+
      c8:	0d 92       	st	X+, r0
      ca:	a2 3d       	cpi	r26, 0xD2	; 210
      cc:	b1 07       	cpc	r27, r17
      ce:	d9 f7       	brne	.-10     	; 0xc6 <__do_copy_data+0xc>

000000d0 <__do_clear_bss>:
      d0:	26 e0       	ldi	r18, 0x06	; 6
      d2:	a2 ed       	ldi	r26, 0xD2	; 210
      d4:	b1 e0       	ldi	r27, 0x01	; 1
      d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
      d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
      da:	ae 3c       	cpi	r26, 0xCE	; 206
      dc:	b2 07       	cpc	r27, r18
      de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>
      e0:	0e 94 2d 10 	call	0x205a	; 0x205a <main>
      e4:	0c 94 14 16 	jmp	0x2c28	; 0x2c28 <_exit>

000000e8 <__bad_interrupt>:
      e8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ec <prvTestWaitCondition>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
      ec:	41 11       	cpse	r20, r1
      ee:	06 c0       	rjmp	.+12     	; 0xfc <prvTestWaitCondition+0x10>
      f0:	68 23       	and	r22, r24
      f2:	79 23       	and	r23, r25
      f4:	67 2b       	or	r22, r23
      f6:	49 f4       	brne	.+18     	; 0x10a <prvTestWaitCondition+0x1e>
      f8:	80 e0       	ldi	r24, 0x00	; 0
      fa:	08 95       	ret
      fc:	86 23       	and	r24, r22
      fe:	97 23       	and	r25, r23
     100:	68 17       	cp	r22, r24
     102:	79 07       	cpc	r23, r25
     104:	21 f0       	breq	.+8      	; 0x10e <prvTestWaitCondition+0x22>
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	08 95       	ret
     10e:	81 e0       	ldi	r24, 0x01	; 1
     110:	08 95       	ret

00000112 <xEventGroupCreate>:
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	8b e0       	ldi	r24, 0x0B	; 11
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     11e:	ec 01       	movw	r28, r24
     120:	00 97       	sbiw	r24, 0x00	; 0
     122:	31 f0       	breq	.+12     	; 0x130 <xEventGroupCreate+0x1e>
     124:	fc 01       	movw	r30, r24
     126:	11 92       	st	Z+, r1
     128:	11 92       	st	Z+, r1
     12a:	cf 01       	movw	r24, r30
     12c:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     130:	ce 01       	movw	r24, r28
     132:	df 91       	pop	r29
     134:	cf 91       	pop	r28
     136:	08 95       	ret

00000138 <xEventGroupWaitBits>:
     138:	af 92       	push	r10
     13a:	bf 92       	push	r11
     13c:	cf 92       	push	r12
     13e:	df 92       	push	r13
     140:	ef 92       	push	r14
     142:	ff 92       	push	r15
     144:	0f 93       	push	r16
     146:	1f 93       	push	r17
     148:	cf 93       	push	r28
     14a:	df 93       	push	r29
     14c:	7c 01       	movw	r14, r24
     14e:	5b 01       	movw	r10, r22
     150:	c4 2e       	mov	r12, r20
     152:	d2 2e       	mov	r13, r18
     154:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
     158:	f7 01       	movw	r30, r14
     15a:	c0 81       	ld	r28, Z
     15c:	d1 81       	ldd	r29, Z+1	; 0x01
     15e:	4d 2d       	mov	r20, r13
     160:	b5 01       	movw	r22, r10
     162:	ce 01       	movw	r24, r28
     164:	0e 94 76 00 	call	0xec	; 0xec <prvTestWaitCondition>
     168:	88 23       	and	r24, r24
     16a:	69 f0       	breq	.+26     	; 0x186 <xEventGroupWaitBits+0x4e>
     16c:	cc 20       	and	r12, r12
     16e:	09 f1       	breq	.+66     	; 0x1b2 <xEventGroupWaitBits+0x7a>
     170:	c5 01       	movw	r24, r10
     172:	80 95       	com	r24
     174:	90 95       	com	r25
     176:	8c 23       	and	r24, r28
     178:	9d 23       	and	r25, r29
     17a:	f7 01       	movw	r30, r14
     17c:	91 83       	std	Z+1, r25	; 0x01
     17e:	80 83       	st	Z, r24
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	10 e0       	ldi	r17, 0x00	; 0
     184:	18 c0       	rjmp	.+48     	; 0x1b6 <xEventGroupWaitBits+0x7e>
     186:	01 15       	cp	r16, r1
     188:	11 05       	cpc	r17, r1
     18a:	a9 f0       	breq	.+42     	; 0x1b6 <xEventGroupWaitBits+0x7e>
     18c:	c1 10       	cpse	r12, r1
     18e:	03 c0       	rjmp	.+6      	; 0x196 <xEventGroupWaitBits+0x5e>
     190:	60 e0       	ldi	r22, 0x00	; 0
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	02 c0       	rjmp	.+4      	; 0x19a <xEventGroupWaitBits+0x62>
     196:	60 e0       	ldi	r22, 0x00	; 0
     198:	71 e0       	ldi	r23, 0x01	; 1
     19a:	d1 10       	cpse	r13, r1
     19c:	74 60       	ori	r23, 0x04	; 4
     19e:	6a 29       	or	r22, r10
     1a0:	7b 29       	or	r23, r11
     1a2:	a8 01       	movw	r20, r16
     1a4:	c7 01       	movw	r24, r14
     1a6:	02 96       	adiw	r24, 0x02	; 2
     1a8:	0e 94 2f 0a 	call	0x145e	; 0x145e <vTaskPlaceOnUnorderedEventList>
     1ac:	c0 e0       	ldi	r28, 0x00	; 0
     1ae:	d0 e0       	ldi	r29, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <xEventGroupWaitBits+0x7e>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
     1b6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     1ba:	01 2b       	or	r16, r17
     1bc:	19 f1       	breq	.+70     	; 0x204 <xEventGroupWaitBits+0xcc>
     1be:	81 11       	cpse	r24, r1
     1c0:	02 c0       	rjmp	.+4      	; 0x1c6 <xEventGroupWaitBits+0x8e>
     1c2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     1c6:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxTaskResetEventItemValue>
     1ca:	ec 01       	movw	r28, r24
     1cc:	91 fd       	sbrc	r25, 1
     1ce:	19 c0       	rjmp	.+50     	; 0x202 <xEventGroupWaitBits+0xca>
     1d0:	0f b6       	in	r0, 0x3f	; 63
     1d2:	f8 94       	cli
     1d4:	0f 92       	push	r0
     1d6:	f7 01       	movw	r30, r14
     1d8:	c0 81       	ld	r28, Z
     1da:	d1 81       	ldd	r29, Z+1	; 0x01
     1dc:	4d 2d       	mov	r20, r13
     1de:	b5 01       	movw	r22, r10
     1e0:	ce 01       	movw	r24, r28
     1e2:	0e 94 76 00 	call	0xec	; 0xec <prvTestWaitCondition>
     1e6:	88 23       	and	r24, r24
     1e8:	51 f0       	breq	.+20     	; 0x1fe <xEventGroupWaitBits+0xc6>
     1ea:	cc 20       	and	r12, r12
     1ec:	41 f0       	breq	.+16     	; 0x1fe <xEventGroupWaitBits+0xc6>
     1ee:	b5 01       	movw	r22, r10
     1f0:	60 95       	com	r22
     1f2:	70 95       	com	r23
     1f4:	6c 23       	and	r22, r28
     1f6:	7d 23       	and	r23, r29
     1f8:	f7 01       	movw	r30, r14
     1fa:	71 83       	std	Z+1, r23	; 0x01
     1fc:	60 83       	st	Z, r22
     1fe:	0f 90       	pop	r0
     200:	0f be       	out	0x3f, r0	; 63
     202:	dd 27       	eor	r29, r29
     204:	ce 01       	movw	r24, r28
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	1f 91       	pop	r17
     20c:	0f 91       	pop	r16
     20e:	ff 90       	pop	r15
     210:	ef 90       	pop	r14
     212:	df 90       	pop	r13
     214:	cf 90       	pop	r12
     216:	bf 90       	pop	r11
     218:	af 90       	pop	r10
     21a:	08 95       	ret

0000021c <xEventGroupClearBits>:
     21c:	fc 01       	movw	r30, r24
     21e:	0f b6       	in	r0, 0x3f	; 63
     220:	f8 94       	cli
     222:	0f 92       	push	r0
     224:	80 81       	ld	r24, Z
     226:	91 81       	ldd	r25, Z+1	; 0x01
     228:	60 95       	com	r22
     22a:	70 95       	com	r23
     22c:	68 23       	and	r22, r24
     22e:	79 23       	and	r23, r25
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	0f 90       	pop	r0
     236:	0f be       	out	0x3f, r0	; 63
     238:	08 95       	ret

0000023a <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     23a:	cf 92       	push	r12
     23c:	df 92       	push	r13
     23e:	ef 92       	push	r14
     240:	ff 92       	push	r15
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	cf 93       	push	r28
     248:	df 93       	push	r29
     24a:	7c 01       	movw	r14, r24
     24c:	8b 01       	movw	r16, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     24e:	ec 01       	movw	r28, r24
     250:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     252:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     256:	d7 01       	movw	r26, r14
     258:	17 96       	adiw	r26, 0x07	; 7
     25a:	ed 91       	ld	r30, X+
     25c:	fc 91       	ld	r31, X
     25e:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     260:	8d 91       	ld	r24, X+
     262:	9c 91       	ld	r25, X
     264:	11 97       	sbiw	r26, 0x01	; 1
     266:	08 2b       	or	r16, r24
     268:	19 2b       	or	r17, r25
     26a:	0d 93       	st	X+, r16
     26c:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     272:	2d c0       	rjmp	.+90     	; 0x2ce <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     274:	c2 80       	ldd	r12, Z+2	; 0x02
     276:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     278:	80 81       	ld	r24, Z
     27a:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     27c:	9c 01       	movw	r18, r24
     27e:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     280:	92 fd       	sbrc	r25, 2
     282:	09 c0       	rjmp	.+18     	; 0x296 <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     284:	d7 01       	movw	r26, r14
     286:	4d 91       	ld	r20, X+
     288:	5c 91       	ld	r21, X
     28a:	42 23       	and	r20, r18
     28c:	53 23       	and	r21, r19
     28e:	45 2b       	or	r20, r21
     290:	61 f4       	brne	.+24     	; 0x2aa <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     292:	40 e0       	ldi	r20, 0x00	; 0
     294:	0d c0       	rjmp	.+26     	; 0x2b0 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     296:	d7 01       	movw	r26, r14
     298:	4d 91       	ld	r20, X+
     29a:	5c 91       	ld	r21, X
     29c:	42 23       	and	r20, r18
     29e:	53 23       	and	r21, r19
     2a0:	24 17       	cp	r18, r20
     2a2:	35 07       	cpc	r19, r21
     2a4:	21 f0       	breq	.+8      	; 0x2ae <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     2a6:	40 e0       	ldi	r20, 0x00	; 0
     2a8:	03 c0       	rjmp	.+6      	; 0x2b0 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     2aa:	41 e0       	ldi	r20, 0x01	; 1
     2ac:	01 c0       	rjmp	.+2      	; 0x2b0 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     2ae:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     2b0:	44 23       	and	r20, r20
     2b2:	59 f0       	breq	.+22     	; 0x2ca <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     2b4:	90 ff       	sbrs	r25, 0
     2b6:	02 c0       	rjmp	.+4      	; 0x2bc <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     2b8:	02 2b       	or	r16, r18
     2ba:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     2bc:	d7 01       	movw	r26, r14
     2be:	6d 91       	ld	r22, X+
     2c0:	7c 91       	ld	r23, X
     2c2:	72 60       	ori	r23, 0x02	; 2
     2c4:	cf 01       	movw	r24, r30
     2c6:	0e 94 9b 0a 	call	0x1536	; 0x1536 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     2ca:	ec 2d       	mov	r30, r12
     2cc:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     2ce:	ec 17       	cp	r30, r28
     2d0:	fd 07       	cpc	r31, r29
     2d2:	81 f6       	brne	.-96     	; 0x274 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     2d4:	00 95       	com	r16
     2d6:	10 95       	com	r17
     2d8:	f7 01       	movw	r30, r14
     2da:	80 81       	ld	r24, Z
     2dc:	91 81       	ldd	r25, Z+1	; 0x01
     2de:	08 23       	and	r16, r24
     2e0:	19 23       	and	r17, r25
     2e2:	11 83       	std	Z+1, r17	; 0x01
     2e4:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     2e6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     2ea:	d7 01       	movw	r26, r14
     2ec:	8d 91       	ld	r24, X+
     2ee:	9c 91       	ld	r25, X
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	1f 91       	pop	r17
     2f6:	0f 91       	pop	r16
     2f8:	ff 90       	pop	r15
     2fa:	ef 90       	pop	r14
     2fc:	df 90       	pop	r13
     2fe:	cf 90       	pop	r12
     300:	08 95       	ret

00000302 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     308:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     30c:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <__data_end>
     310:	90 91 d3 01 	lds	r25, 0x01D3	; 0x8001d3 <__data_end+0x1>
     314:	89 2b       	or	r24, r25
     316:	31 f4       	brne	.+12     	; 0x324 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     318:	87 ed       	ldi	r24, 0xD7	; 215
     31a:	91 e0       	ldi	r25, 0x01	; 1
     31c:	90 93 d3 01 	sts	0x01D3, r25	; 0x8001d3 <__data_end+0x1>
     320:	80 93 d2 01 	sts	0x01D2, r24	; 0x8001d2 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     324:	20 91 d4 01 	lds	r18, 0x01D4	; 0x8001d4 <xNextFreeByte>
     328:	30 91 d5 01 	lds	r19, 0x01D5	; 0x8001d5 <xNextFreeByte+0x1>
     32c:	c9 01       	movw	r24, r18
     32e:	8c 0f       	add	r24, r28
     330:	9d 1f       	adc	r25, r29
     332:	8d 37       	cpi	r24, 0x7D	; 125
     334:	44 e0       	ldi	r20, 0x04	; 4
     336:	94 07       	cpc	r25, r20
     338:	70 f4       	brcc	.+28     	; 0x356 <pvPortMalloc+0x54>
     33a:	28 17       	cp	r18, r24
     33c:	39 07       	cpc	r19, r25
     33e:	70 f4       	brcc	.+28     	; 0x35c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     340:	c0 91 d2 01 	lds	r28, 0x01D2	; 0x8001d2 <__data_end>
     344:	d0 91 d3 01 	lds	r29, 0x01D3	; 0x8001d3 <__data_end+0x1>
     348:	c2 0f       	add	r28, r18
     34a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     34c:	90 93 d5 01 	sts	0x01D5, r25	; 0x8001d5 <xNextFreeByte+0x1>
     350:	80 93 d4 01 	sts	0x01D4, r24	; 0x8001d4 <xNextFreeByte>
     354:	05 c0       	rjmp	.+10     	; 0x360 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     356:	c0 e0       	ldi	r28, 0x00	; 0
     358:	d0 e0       	ldi	r29, 0x00	; 0
     35a:	02 c0       	rjmp	.+4      	; 0x360 <pvPortMalloc+0x5e>
     35c:	c0 e0       	ldi	r28, 0x00	; 0
     35e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     360:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     364:	ce 01       	movw	r24, r28
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     36c:	08 95       	ret

0000036e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     36e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     370:	03 96       	adiw	r24, 0x03	; 3
     372:	92 83       	std	Z+2, r25	; 0x02
     374:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     376:	2f ef       	ldi	r18, 0xFF	; 255
     378:	3f ef       	ldi	r19, 0xFF	; 255
     37a:	34 83       	std	Z+4, r19	; 0x04
     37c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     37e:	96 83       	std	Z+6, r25	; 0x06
     380:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     382:	90 87       	std	Z+8, r25	; 0x08
     384:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     386:	10 82       	st	Z, r1
     388:	08 95       	ret

0000038a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     38a:	fc 01       	movw	r30, r24
     38c:	11 86       	std	Z+9, r1	; 0x09
     38e:	10 86       	std	Z+8, r1	; 0x08
     390:	08 95       	ret

00000392 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	9c 01       	movw	r18, r24
     398:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     39a:	dc 01       	movw	r26, r24
     39c:	11 96       	adiw	r26, 0x01	; 1
     39e:	cd 91       	ld	r28, X+
     3a0:	dc 91       	ld	r29, X
     3a2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3a4:	d3 83       	std	Z+3, r29	; 0x03
     3a6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3a8:	8c 81       	ldd	r24, Y+4	; 0x04
     3aa:	9d 81       	ldd	r25, Y+5	; 0x05
     3ac:	95 83       	std	Z+5, r25	; 0x05
     3ae:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3b0:	8c 81       	ldd	r24, Y+4	; 0x04
     3b2:	9d 81       	ldd	r25, Y+5	; 0x05
     3b4:	dc 01       	movw	r26, r24
     3b6:	13 96       	adiw	r26, 0x03	; 3
     3b8:	7c 93       	st	X, r23
     3ba:	6e 93       	st	-X, r22
     3bc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3be:	7d 83       	std	Y+5, r23	; 0x05
     3c0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3c2:	31 87       	std	Z+9, r19	; 0x09
     3c4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3c6:	f9 01       	movw	r30, r18
     3c8:	80 81       	ld	r24, Z
     3ca:	8f 5f       	subi	r24, 0xFF	; 255
     3cc:	80 83       	st	Z, r24
}
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	08 95       	ret

000003d4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3d4:	cf 93       	push	r28
     3d6:	df 93       	push	r29
     3d8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3da:	48 81       	ld	r20, Y
     3dc:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3de:	4f 3f       	cpi	r20, 0xFF	; 255
     3e0:	2f ef       	ldi	r18, 0xFF	; 255
     3e2:	52 07       	cpc	r21, r18
     3e4:	21 f4       	brne	.+8      	; 0x3ee <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3e6:	fc 01       	movw	r30, r24
     3e8:	a7 81       	ldd	r26, Z+7	; 0x07
     3ea:	b0 85       	ldd	r27, Z+8	; 0x08
     3ec:	0d c0       	rjmp	.+26     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3ee:	dc 01       	movw	r26, r24
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <vListInsert+0x22>
     3f4:	df 01       	movw	r26, r30
     3f6:	12 96       	adiw	r26, 0x02	; 2
     3f8:	ed 91       	ld	r30, X+
     3fa:	fc 91       	ld	r31, X
     3fc:	13 97       	sbiw	r26, 0x03	; 3
     3fe:	20 81       	ld	r18, Z
     400:	31 81       	ldd	r19, Z+1	; 0x01
     402:	42 17       	cp	r20, r18
     404:	53 07       	cpc	r21, r19
     406:	b0 f7       	brcc	.-20     	; 0x3f4 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     408:	12 96       	adiw	r26, 0x02	; 2
     40a:	ed 91       	ld	r30, X+
     40c:	fc 91       	ld	r31, X
     40e:	13 97       	sbiw	r26, 0x03	; 3
     410:	fb 83       	std	Y+3, r31	; 0x03
     412:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     414:	d5 83       	std	Z+5, r29	; 0x05
     416:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     418:	bd 83       	std	Y+5, r27	; 0x05
     41a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     41c:	13 96       	adiw	r26, 0x03	; 3
     41e:	dc 93       	st	X, r29
     420:	ce 93       	st	-X, r28
     422:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     424:	99 87       	std	Y+9, r25	; 0x09
     426:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     428:	fc 01       	movw	r30, r24
     42a:	20 81       	ld	r18, Z
     42c:	2f 5f       	subi	r18, 0xFF	; 255
     42e:	20 83       	st	Z, r18
}
     430:	df 91       	pop	r29
     432:	cf 91       	pop	r28
     434:	08 95       	ret

00000436 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     43c:	a0 85       	ldd	r26, Z+8	; 0x08
     43e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     440:	c2 81       	ldd	r28, Z+2	; 0x02
     442:	d3 81       	ldd	r29, Z+3	; 0x03
     444:	84 81       	ldd	r24, Z+4	; 0x04
     446:	95 81       	ldd	r25, Z+5	; 0x05
     448:	9d 83       	std	Y+5, r25	; 0x05
     44a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     44c:	c4 81       	ldd	r28, Z+4	; 0x04
     44e:	d5 81       	ldd	r29, Z+5	; 0x05
     450:	82 81       	ldd	r24, Z+2	; 0x02
     452:	93 81       	ldd	r25, Z+3	; 0x03
     454:	9b 83       	std	Y+3, r25	; 0x03
     456:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     458:	11 96       	adiw	r26, 0x01	; 1
     45a:	8d 91       	ld	r24, X+
     45c:	9c 91       	ld	r25, X
     45e:	12 97       	sbiw	r26, 0x02	; 2
     460:	e8 17       	cp	r30, r24
     462:	f9 07       	cpc	r31, r25
     464:	31 f4       	brne	.+12     	; 0x472 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     466:	84 81       	ldd	r24, Z+4	; 0x04
     468:	95 81       	ldd	r25, Z+5	; 0x05
     46a:	12 96       	adiw	r26, 0x02	; 2
     46c:	9c 93       	st	X, r25
     46e:	8e 93       	st	-X, r24
     470:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     472:	11 86       	std	Z+9, r1	; 0x09
     474:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     476:	8c 91       	ld	r24, X
     478:	81 50       	subi	r24, 0x01	; 1
     47a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     482:	1b bc       	out	0x2b, r1	; 43
     484:	8c e7       	ldi	r24, 0x7C	; 124
     486:	8a bd       	out	0x2a, r24	; 42
     488:	8b e0       	ldi	r24, 0x0B	; 11
     48a:	8e bd       	out	0x2e, r24	; 46
     48c:	89 b7       	in	r24, 0x39	; 57
     48e:	80 61       	ori	r24, 0x10	; 16
     490:	89 bf       	out	0x39, r24	; 57
     492:	08 95       	ret

00000494 <pxPortInitialiseStack>:
     494:	31 e1       	ldi	r19, 0x11	; 17
     496:	fc 01       	movw	r30, r24
     498:	30 83       	st	Z, r19
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	22 e2       	ldi	r18, 0x22	; 34
     49e:	20 83       	st	Z, r18
     4a0:	31 97       	sbiw	r30, 0x01	; 1
     4a2:	a3 e3       	ldi	r26, 0x33	; 51
     4a4:	a0 83       	st	Z, r26
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	60 83       	st	Z, r22
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	70 83       	st	Z, r23
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	10 82       	st	Z, r1
     4b2:	31 97       	sbiw	r30, 0x01	; 1
     4b4:	60 e8       	ldi	r22, 0x80	; 128
     4b6:	60 83       	st	Z, r22
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	10 82       	st	Z, r1
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	62 e0       	ldi	r22, 0x02	; 2
     4c0:	60 83       	st	Z, r22
     4c2:	31 97       	sbiw	r30, 0x01	; 1
     4c4:	63 e0       	ldi	r22, 0x03	; 3
     4c6:	60 83       	st	Z, r22
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	64 e0       	ldi	r22, 0x04	; 4
     4cc:	60 83       	st	Z, r22
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	65 e0       	ldi	r22, 0x05	; 5
     4d2:	60 83       	st	Z, r22
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	66 e0       	ldi	r22, 0x06	; 6
     4d8:	60 83       	st	Z, r22
     4da:	31 97       	sbiw	r30, 0x01	; 1
     4dc:	67 e0       	ldi	r22, 0x07	; 7
     4de:	60 83       	st	Z, r22
     4e0:	31 97       	sbiw	r30, 0x01	; 1
     4e2:	68 e0       	ldi	r22, 0x08	; 8
     4e4:	60 83       	st	Z, r22
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	69 e0       	ldi	r22, 0x09	; 9
     4ea:	60 83       	st	Z, r22
     4ec:	31 97       	sbiw	r30, 0x01	; 1
     4ee:	60 e1       	ldi	r22, 0x10	; 16
     4f0:	60 83       	st	Z, r22
     4f2:	31 97       	sbiw	r30, 0x01	; 1
     4f4:	30 83       	st	Z, r19
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	32 e1       	ldi	r19, 0x12	; 18
     4fa:	30 83       	st	Z, r19
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	33 e1       	ldi	r19, 0x13	; 19
     500:	30 83       	st	Z, r19
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	34 e1       	ldi	r19, 0x14	; 20
     506:	30 83       	st	Z, r19
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	35 e1       	ldi	r19, 0x15	; 21
     50c:	30 83       	st	Z, r19
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	36 e1       	ldi	r19, 0x16	; 22
     512:	30 83       	st	Z, r19
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	37 e1       	ldi	r19, 0x17	; 23
     518:	30 83       	st	Z, r19
     51a:	31 97       	sbiw	r30, 0x01	; 1
     51c:	38 e1       	ldi	r19, 0x18	; 24
     51e:	30 83       	st	Z, r19
     520:	31 97       	sbiw	r30, 0x01	; 1
     522:	39 e1       	ldi	r19, 0x19	; 25
     524:	30 83       	st	Z, r19
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	30 e2       	ldi	r19, 0x20	; 32
     52a:	30 83       	st	Z, r19
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	31 e2       	ldi	r19, 0x21	; 33
     530:	30 83       	st	Z, r19
     532:	31 97       	sbiw	r30, 0x01	; 1
     534:	20 83       	st	Z, r18
     536:	31 97       	sbiw	r30, 0x01	; 1
     538:	23 e2       	ldi	r18, 0x23	; 35
     53a:	20 83       	st	Z, r18
     53c:	31 97       	sbiw	r30, 0x01	; 1
     53e:	40 83       	st	Z, r20
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	50 83       	st	Z, r21
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	26 e2       	ldi	r18, 0x26	; 38
     548:	20 83       	st	Z, r18
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	27 e2       	ldi	r18, 0x27	; 39
     54e:	20 83       	st	Z, r18
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	28 e2       	ldi	r18, 0x28	; 40
     554:	20 83       	st	Z, r18
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	29 e2       	ldi	r18, 0x29	; 41
     55a:	20 83       	st	Z, r18
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	20 e3       	ldi	r18, 0x30	; 48
     560:	20 83       	st	Z, r18
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	21 e3       	ldi	r18, 0x31	; 49
     566:	20 83       	st	Z, r18
     568:	86 97       	sbiw	r24, 0x26	; 38
     56a:	08 95       	ret

0000056c <xPortStartScheduler>:
     56c:	0e 94 41 02 	call	0x482	; 0x482 <prvSetupTimerInterrupt>
     570:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
     574:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     578:	cd 91       	ld	r28, X+
     57a:	cd bf       	out	0x3d, r28	; 61
     57c:	dd 91       	ld	r29, X+
     57e:	de bf       	out	0x3e, r29	; 62
     580:	ff 91       	pop	r31
     582:	ef 91       	pop	r30
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	bf 91       	pop	r27
     58a:	af 91       	pop	r26
     58c:	9f 91       	pop	r25
     58e:	8f 91       	pop	r24
     590:	7f 91       	pop	r23
     592:	6f 91       	pop	r22
     594:	5f 91       	pop	r21
     596:	4f 91       	pop	r20
     598:	3f 91       	pop	r19
     59a:	2f 91       	pop	r18
     59c:	1f 91       	pop	r17
     59e:	0f 91       	pop	r16
     5a0:	ff 90       	pop	r15
     5a2:	ef 90       	pop	r14
     5a4:	df 90       	pop	r13
     5a6:	cf 90       	pop	r12
     5a8:	bf 90       	pop	r11
     5aa:	af 90       	pop	r10
     5ac:	9f 90       	pop	r9
     5ae:	8f 90       	pop	r8
     5b0:	7f 90       	pop	r7
     5b2:	6f 90       	pop	r6
     5b4:	5f 90       	pop	r5
     5b6:	4f 90       	pop	r4
     5b8:	3f 90       	pop	r3
     5ba:	2f 90       	pop	r2
     5bc:	1f 90       	pop	r1
     5be:	0f 90       	pop	r0
     5c0:	0f be       	out	0x3f, r0	; 63
     5c2:	0f 90       	pop	r0
     5c4:	08 95       	ret
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	08 95       	ret

000005ca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5ca:	0f 92       	push	r0
     5cc:	0f b6       	in	r0, 0x3f	; 63
     5ce:	f8 94       	cli
     5d0:	0f 92       	push	r0
     5d2:	1f 92       	push	r1
     5d4:	11 24       	eor	r1, r1
     5d6:	2f 92       	push	r2
     5d8:	3f 92       	push	r3
     5da:	4f 92       	push	r4
     5dc:	5f 92       	push	r5
     5de:	6f 92       	push	r6
     5e0:	7f 92       	push	r7
     5e2:	8f 92       	push	r8
     5e4:	9f 92       	push	r9
     5e6:	af 92       	push	r10
     5e8:	bf 92       	push	r11
     5ea:	cf 92       	push	r12
     5ec:	df 92       	push	r13
     5ee:	ef 92       	push	r14
     5f0:	ff 92       	push	r15
     5f2:	0f 93       	push	r16
     5f4:	1f 93       	push	r17
     5f6:	2f 93       	push	r18
     5f8:	3f 93       	push	r19
     5fa:	4f 93       	push	r20
     5fc:	5f 93       	push	r21
     5fe:	6f 93       	push	r22
     600:	7f 93       	push	r23
     602:	8f 93       	push	r24
     604:	9f 93       	push	r25
     606:	af 93       	push	r26
     608:	bf 93       	push	r27
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	ef 93       	push	r30
     610:	ff 93       	push	r31
     612:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
     616:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     61a:	0d b6       	in	r0, 0x3d	; 61
     61c:	0d 92       	st	X+, r0
     61e:	0e b6       	in	r0, 0x3e	; 62
     620:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     622:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     626:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
     62a:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     67c:	0f 92       	push	r0
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	0f 92       	push	r0
     684:	1f 92       	push	r1
     686:	11 24       	eor	r1, r1
     688:	2f 92       	push	r2
     68a:	3f 92       	push	r3
     68c:	4f 92       	push	r4
     68e:	5f 92       	push	r5
     690:	6f 92       	push	r6
     692:	7f 92       	push	r7
     694:	8f 92       	push	r8
     696:	9f 92       	push	r9
     698:	af 92       	push	r10
     69a:	bf 92       	push	r11
     69c:	cf 92       	push	r12
     69e:	df 92       	push	r13
     6a0:	ef 92       	push	r14
     6a2:	ff 92       	push	r15
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	2f 93       	push	r18
     6aa:	3f 93       	push	r19
     6ac:	4f 93       	push	r20
     6ae:	5f 93       	push	r21
     6b0:	6f 93       	push	r22
     6b2:	7f 93       	push	r23
     6b4:	8f 93       	push	r24
     6b6:	9f 93       	push	r25
     6b8:	af 93       	push	r26
     6ba:	bf 93       	push	r27
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	ef 93       	push	r30
     6c2:	ff 93       	push	r31
     6c4:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
     6c8:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     6cc:	0d b6       	in	r0, 0x3d	; 61
     6ce:	0d 92       	st	X+, r0
     6d0:	0e b6       	in	r0, 0x3e	; 62
     6d2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6d4:	0e 94 30 08 	call	0x1060	; 0x1060 <xTaskIncrementTick>
     6d8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6da:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6de:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
     6e2:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     6e6:	cd 91       	ld	r28, X+
     6e8:	cd bf       	out	0x3d, r28	; 61
     6ea:	dd 91       	ld	r29, X+
     6ec:	de bf       	out	0x3e, r29	; 62
     6ee:	ff 91       	pop	r31
     6f0:	ef 91       	pop	r30
     6f2:	df 91       	pop	r29
     6f4:	cf 91       	pop	r28
     6f6:	bf 91       	pop	r27
     6f8:	af 91       	pop	r26
     6fa:	9f 91       	pop	r25
     6fc:	8f 91       	pop	r24
     6fe:	7f 91       	pop	r23
     700:	6f 91       	pop	r22
     702:	5f 91       	pop	r21
     704:	4f 91       	pop	r20
     706:	3f 91       	pop	r19
     708:	2f 91       	pop	r18
     70a:	1f 91       	pop	r17
     70c:	0f 91       	pop	r16
     70e:	ff 90       	pop	r15
     710:	ef 90       	pop	r14
     712:	df 90       	pop	r13
     714:	cf 90       	pop	r12
     716:	bf 90       	pop	r11
     718:	af 90       	pop	r10
     71a:	9f 90       	pop	r9
     71c:	8f 90       	pop	r8
     71e:	7f 90       	pop	r7
     720:	6f 90       	pop	r6
     722:	5f 90       	pop	r5
     724:	4f 90       	pop	r4
     726:	3f 90       	pop	r3
     728:	2f 90       	pop	r2
     72a:	1f 90       	pop	r1
     72c:	0f 90       	pop	r0
     72e:	0f be       	out	0x3f, r0	; 63
     730:	0f 90       	pop	r0

	asm volatile ( "ret" );
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     73a:	0f b6       	in	r0, 0x3f	; 63
     73c:	f8 94       	cli
     73e:	0f 92       	push	r0
     740:	fc 01       	movw	r30, r24
     742:	82 8d       	ldd	r24, Z+26	; 0x1a
     744:	81 11       	cpse	r24, r1
     746:	02 c0       	rjmp	.+4      	; 0x74c <prvIsQueueEmpty+0x12>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	01 c0       	rjmp	.+2      	; 0x74e <prvIsQueueEmpty+0x14>
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	0f 90       	pop	r0
     750:	0f be       	out	0x3f, r0	; 63
     752:	08 95       	ret

00000754 <prvIsQueueFull>:
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	f8 94       	cli
     758:	0f 92       	push	r0
     75a:	fc 01       	movw	r30, r24
     75c:	22 8d       	ldd	r18, Z+26	; 0x1a
     75e:	83 8d       	ldd	r24, Z+27	; 0x1b
     760:	28 13       	cpse	r18, r24
     762:	02 c0       	rjmp	.+4      	; 0x768 <prvIsQueueFull+0x14>
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	01 c0       	rjmp	.+2      	; 0x76a <prvIsQueueFull+0x16>
     768:	80 e0       	ldi	r24, 0x00	; 0
     76a:	0f 90       	pop	r0
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	08 95       	ret

00000770 <prvCopyDataToQueue>:
     770:	1f 93       	push	r17
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	ec 01       	movw	r28, r24
     778:	14 2f       	mov	r17, r20
     77a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     77c:	41 11       	cpse	r20, r1
     77e:	0c c0       	rjmp	.+24     	; 0x798 <prvCopyDataToQueue+0x28>
     780:	88 81       	ld	r24, Y
     782:	99 81       	ldd	r25, Y+1	; 0x01
     784:	89 2b       	or	r24, r25
     786:	09 f0       	breq	.+2      	; 0x78a <prvCopyDataToQueue+0x1a>
     788:	45 c0       	rjmp	.+138    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     78a:	8a 81       	ldd	r24, Y+2	; 0x02
     78c:	9b 81       	ldd	r25, Y+3	; 0x03
     78e:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <xTaskPriorityDisinherit>
     792:	1b 82       	std	Y+3, r1	; 0x03
     794:	1a 82       	std	Y+2, r1	; 0x02
     796:	45 c0       	rjmp	.+138    	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     798:	11 11       	cpse	r17, r1
     79a:	17 c0       	rjmp	.+46     	; 0x7ca <prvCopyDataToQueue+0x5a>
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	8c 81       	ldd	r24, Y+4	; 0x04
     7a0:	9d 81       	ldd	r25, Y+5	; 0x05
     7a2:	0e 94 d6 15 	call	0x2bac	; 0x2bac <memcpy>
     7a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7a8:	8c 81       	ldd	r24, Y+4	; 0x04
     7aa:	9d 81       	ldd	r25, Y+5	; 0x05
     7ac:	82 0f       	add	r24, r18
     7ae:	91 1d       	adc	r25, r1
     7b0:	9d 83       	std	Y+5, r25	; 0x05
     7b2:	8c 83       	std	Y+4, r24	; 0x04
     7b4:	2a 81       	ldd	r18, Y+2	; 0x02
     7b6:	3b 81       	ldd	r19, Y+3	; 0x03
     7b8:	82 17       	cp	r24, r18
     7ba:	93 07       	cpc	r25, r19
     7bc:	68 f1       	brcs	.+90     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
     7be:	88 81       	ld	r24, Y
     7c0:	99 81       	ldd	r25, Y+1	; 0x01
     7c2:	9d 83       	std	Y+5, r25	; 0x05
     7c4:	8c 83       	std	Y+4, r24	; 0x04
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	2c c0       	rjmp	.+88     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	8e 81       	ldd	r24, Y+6	; 0x06
     7ce:	9f 81       	ldd	r25, Y+7	; 0x07
     7d0:	0e 94 d6 15 	call	0x2bac	; 0x2bac <memcpy>
     7d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	91 95       	neg	r25
     7da:	81 95       	neg	r24
     7dc:	91 09       	sbc	r25, r1
     7de:	2e 81       	ldd	r18, Y+6	; 0x06
     7e0:	3f 81       	ldd	r19, Y+7	; 0x07
     7e2:	28 0f       	add	r18, r24
     7e4:	39 1f       	adc	r19, r25
     7e6:	3f 83       	std	Y+7, r19	; 0x07
     7e8:	2e 83       	std	Y+6, r18	; 0x06
     7ea:	48 81       	ld	r20, Y
     7ec:	59 81       	ldd	r21, Y+1	; 0x01
     7ee:	24 17       	cp	r18, r20
     7f0:	35 07       	cpc	r19, r21
     7f2:	30 f4       	brcc	.+12     	; 0x800 <__DATA_REGION_LENGTH__>
     7f4:	2a 81       	ldd	r18, Y+2	; 0x02
     7f6:	3b 81       	ldd	r19, Y+3	; 0x03
     7f8:	82 0f       	add	r24, r18
     7fa:	93 1f       	adc	r25, r19
     7fc:	9f 83       	std	Y+7, r25	; 0x07
     7fe:	8e 83       	std	Y+6, r24	; 0x06
     800:	12 30       	cpi	r17, 0x02	; 2
     802:	61 f4       	brne	.+24     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     804:	8a 8d       	ldd	r24, Y+26	; 0x1a
     806:	88 23       	and	r24, r24
     808:	59 f0       	breq	.+22     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     80a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     80c:	81 50       	subi	r24, 0x01	; 1
     80e:	8a 8f       	std	Y+26, r24	; 0x1a
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	07 c0       	rjmp	.+14     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	05 c0       	rjmp	.+10     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	03 c0       	rjmp	.+6      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	01 c0       	rjmp	.+2      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     820:	80 e0       	ldi	r24, 0x00	; 0
     822:	9a 8d       	ldd	r25, Y+26	; 0x1a
     824:	9f 5f       	subi	r25, 0xFF	; 255
     826:	9a 8f       	std	Y+26, r25	; 0x1a
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	1f 91       	pop	r17
     82e:	08 95       	ret

00000830 <prvCopyDataFromQueue>:
     830:	fc 01       	movw	r30, r24
     832:	44 8d       	ldd	r20, Z+28	; 0x1c
     834:	44 23       	and	r20, r20
     836:	a9 f0       	breq	.+42     	; 0x862 <__stack+0x3>
     838:	50 e0       	ldi	r21, 0x00	; 0
     83a:	26 81       	ldd	r18, Z+6	; 0x06
     83c:	37 81       	ldd	r19, Z+7	; 0x07
     83e:	24 0f       	add	r18, r20
     840:	35 1f       	adc	r19, r21
     842:	37 83       	std	Z+7, r19	; 0x07
     844:	26 83       	std	Z+6, r18	; 0x06
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	28 17       	cp	r18, r24
     84c:	39 07       	cpc	r19, r25
     84e:	20 f0       	brcs	.+8      	; 0x858 <prvCopyDataFromQueue+0x28>
     850:	80 81       	ld	r24, Z
     852:	91 81       	ldd	r25, Z+1	; 0x01
     854:	97 83       	std	Z+7, r25	; 0x07
     856:	86 83       	std	Z+6, r24	; 0x06
     858:	cb 01       	movw	r24, r22
     85a:	66 81       	ldd	r22, Z+6	; 0x06
     85c:	77 81       	ldd	r23, Z+7	; 0x07
     85e:	0e 94 d6 15 	call	0x2bac	; 0x2bac <memcpy>
     862:	08 95       	ret

00000864 <prvUnlockQueue>:
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	ec 01       	movw	r28, r24
     86a:	0f b6       	in	r0, 0x3f	; 63
     86c:	f8 94       	cli
     86e:	0f 92       	push	r0
     870:	0d c0       	rjmp	.+26     	; 0x88c <prvUnlockQueue+0x28>
     872:	89 89       	ldd	r24, Y+17	; 0x11
     874:	88 23       	and	r24, r24
     876:	69 f0       	breq	.+26     	; 0x892 <prvUnlockQueue+0x2e>
     878:	ce 01       	movw	r24, r28
     87a:	41 96       	adiw	r24, 0x11	; 17
     87c:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     880:	81 11       	cpse	r24, r1
     882:	0e 94 12 0b 	call	0x1624	; 0x1624 <vTaskMissedYield>
     886:	8e 8d       	ldd	r24, Y+30	; 0x1e
     888:	81 50       	subi	r24, 0x01	; 1
     88a:	8e 8f       	std	Y+30, r24	; 0x1e
     88c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     88e:	18 16       	cp	r1, r24
     890:	84 f3       	brlt	.-32     	; 0x872 <prvUnlockQueue+0xe>
     892:	8f ef       	ldi	r24, 0xFF	; 255
     894:	8e 8f       	std	Y+30, r24	; 0x1e
     896:	0f 90       	pop	r0
     898:	0f be       	out	0x3f, r0	; 63
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	0f 92       	push	r0
     8a0:	0d c0       	rjmp	.+26     	; 0x8bc <prvUnlockQueue+0x58>
     8a2:	88 85       	ldd	r24, Y+8	; 0x08
     8a4:	88 23       	and	r24, r24
     8a6:	69 f0       	breq	.+26     	; 0x8c2 <prvUnlockQueue+0x5e>
     8a8:	ce 01       	movw	r24, r28
     8aa:	08 96       	adiw	r24, 0x08	; 8
     8ac:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     8b0:	81 11       	cpse	r24, r1
     8b2:	0e 94 12 0b 	call	0x1624	; 0x1624 <vTaskMissedYield>
     8b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8b8:	81 50       	subi	r24, 0x01	; 1
     8ba:	8d 8f       	std	Y+29, r24	; 0x1d
     8bc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8be:	18 16       	cp	r1, r24
     8c0:	84 f3       	brlt	.-32     	; 0x8a2 <prvUnlockQueue+0x3e>
     8c2:	8f ef       	ldi	r24, 0xFF	; 255
     8c4:	8d 8f       	std	Y+29, r24	; 0x1d
     8c6:	0f 90       	pop	r0
     8c8:	0f be       	out	0x3f, r0	; 63
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <xQueueGenericReset>:
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	ec 01       	movw	r28, r24
     8d6:	0f b6       	in	r0, 0x3f	; 63
     8d8:	f8 94       	cli
     8da:	0f 92       	push	r0
     8dc:	e8 81       	ld	r30, Y
     8de:	f9 81       	ldd	r31, Y+1	; 0x01
     8e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	82 9f       	mul	r24, r18
     8ea:	a0 01       	movw	r20, r0
     8ec:	83 9f       	mul	r24, r19
     8ee:	50 0d       	add	r21, r0
     8f0:	92 9f       	mul	r25, r18
     8f2:	50 0d       	add	r21, r0
     8f4:	11 24       	eor	r1, r1
     8f6:	4e 0f       	add	r20, r30
     8f8:	5f 1f       	adc	r21, r31
     8fa:	5b 83       	std	Y+3, r21	; 0x03
     8fc:	4a 83       	std	Y+2, r20	; 0x02
     8fe:	1a 8e       	std	Y+26, r1	; 0x1a
     900:	fd 83       	std	Y+5, r31	; 0x05
     902:	ec 83       	std	Y+4, r30	; 0x04
     904:	01 97       	sbiw	r24, 0x01	; 1
     906:	28 9f       	mul	r18, r24
     908:	a0 01       	movw	r20, r0
     90a:	29 9f       	mul	r18, r25
     90c:	50 0d       	add	r21, r0
     90e:	38 9f       	mul	r19, r24
     910:	50 0d       	add	r21, r0
     912:	11 24       	eor	r1, r1
     914:	cf 01       	movw	r24, r30
     916:	84 0f       	add	r24, r20
     918:	95 1f       	adc	r25, r21
     91a:	9f 83       	std	Y+7, r25	; 0x07
     91c:	8e 83       	std	Y+6, r24	; 0x06
     91e:	8f ef       	ldi	r24, 0xFF	; 255
     920:	8d 8f       	std	Y+29, r24	; 0x1d
     922:	8e 8f       	std	Y+30, r24	; 0x1e
     924:	61 11       	cpse	r22, r1
     926:	0c c0       	rjmp	.+24     	; 0x940 <xQueueGenericReset+0x70>
     928:	88 85       	ldd	r24, Y+8	; 0x08
     92a:	88 23       	and	r24, r24
     92c:	89 f0       	breq	.+34     	; 0x950 <xQueueGenericReset+0x80>
     92e:	ce 01       	movw	r24, r28
     930:	08 96       	adiw	r24, 0x08	; 8
     932:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     936:	81 30       	cpi	r24, 0x01	; 1
     938:	59 f4       	brne	.+22     	; 0x950 <xQueueGenericReset+0x80>
     93a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     93e:	08 c0       	rjmp	.+16     	; 0x950 <xQueueGenericReset+0x80>
     940:	ce 01       	movw	r24, r28
     942:	08 96       	adiw	r24, 0x08	; 8
     944:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     948:	ce 01       	movw	r24, r28
     94a:	41 96       	adiw	r24, 0x11	; 17
     94c:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     950:	0f 90       	pop	r0
     952:	0f be       	out	0x3f, r0	; 63
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	08 95       	ret

0000095c <xQueueGenericCreate>:
     95c:	0f 93       	push	r16
     95e:	1f 93       	push	r17
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	88 23       	and	r24, r24
     966:	01 f1       	breq	.+64     	; 0x9a8 <xQueueGenericCreate+0x4c>
     968:	06 2f       	mov	r16, r22
     96a:	18 2f       	mov	r17, r24
     96c:	8f e1       	ldi	r24, 0x1F	; 31
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     974:	ec 01       	movw	r28, r24
     976:	89 2b       	or	r24, r25
     978:	c9 f0       	breq	.+50     	; 0x9ac <xQueueGenericCreate+0x50>
     97a:	10 9f       	mul	r17, r16
     97c:	c0 01       	movw	r24, r0
     97e:	11 24       	eor	r1, r1
     980:	01 96       	adiw	r24, 0x01	; 1
     982:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     986:	99 83       	std	Y+1, r25	; 0x01
     988:	88 83       	st	Y, r24
     98a:	89 2b       	or	r24, r25
     98c:	39 f0       	breq	.+14     	; 0x99c <xQueueGenericCreate+0x40>
     98e:	1b 8f       	std	Y+27, r17	; 0x1b
     990:	0c 8f       	std	Y+28, r16	; 0x1c
     992:	61 e0       	ldi	r22, 0x01	; 1
     994:	ce 01       	movw	r24, r28
     996:	0e 94 68 04 	call	0x8d0	; 0x8d0 <xQueueGenericReset>
     99a:	08 c0       	rjmp	.+16     	; 0x9ac <xQueueGenericCreate+0x50>
     99c:	ce 01       	movw	r24, r28
     99e:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     9a2:	c0 e0       	ldi	r28, 0x00	; 0
     9a4:	d0 e0       	ldi	r29, 0x00	; 0
     9a6:	02 c0       	rjmp	.+4      	; 0x9ac <xQueueGenericCreate+0x50>
     9a8:	c0 e0       	ldi	r28, 0x00	; 0
     9aa:	d0 e0       	ldi	r29, 0x00	; 0
     9ac:	ce 01       	movw	r24, r28
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	1f 91       	pop	r17
     9b4:	0f 91       	pop	r16
     9b6:	08 95       	ret

000009b8 <xQueueGenericSend>:
     9b8:	cf 92       	push	r12
     9ba:	df 92       	push	r13
     9bc:	ef 92       	push	r14
     9be:	ff 92       	push	r15
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	00 d0       	rcall	.+0      	; 0x9ca <xQueueGenericSend+0x12>
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <xQueueGenericSend+0x14>
     9cc:	1f 92       	push	r1
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
     9d2:	8c 01       	movw	r16, r24
     9d4:	7b 01       	movw	r14, r22
     9d6:	5d 83       	std	Y+5, r21	; 0x05
     9d8:	4c 83       	std	Y+4, r20	; 0x04
     9da:	c2 2e       	mov	r12, r18
     9dc:	d1 2c       	mov	r13, r1
     9de:	0f b6       	in	r0, 0x3f	; 63
     9e0:	f8 94       	cli
     9e2:	0f 92       	push	r0
     9e4:	f8 01       	movw	r30, r16
     9e6:	92 8d       	ldd	r25, Z+26	; 0x1a
     9e8:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ea:	98 17       	cp	r25, r24
     9ec:	18 f0       	brcs	.+6      	; 0x9f4 <xQueueGenericSend+0x3c>
     9ee:	f2 e0       	ldi	r31, 0x02	; 2
     9f0:	cf 12       	cpse	r12, r31
     9f2:	19 c0       	rjmp	.+50     	; 0xa26 <xQueueGenericSend+0x6e>
     9f4:	4c 2d       	mov	r20, r12
     9f6:	b7 01       	movw	r22, r14
     9f8:	c8 01       	movw	r24, r16
     9fa:	0e 94 b8 03 	call	0x770	; 0x770 <prvCopyDataToQueue>
     9fe:	f8 01       	movw	r30, r16
     a00:	91 89       	ldd	r25, Z+17	; 0x11
     a02:	99 23       	and	r25, r25
     a04:	49 f0       	breq	.+18     	; 0xa18 <xQueueGenericSend+0x60>
     a06:	c8 01       	movw	r24, r16
     a08:	41 96       	adiw	r24, 0x11	; 17
     a0a:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     a0e:	81 30       	cpi	r24, 0x01	; 1
     a10:	31 f4       	brne	.+12     	; 0xa1e <xQueueGenericSend+0x66>
     a12:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     a16:	03 c0       	rjmp	.+6      	; 0xa1e <xQueueGenericSend+0x66>
     a18:	81 11       	cpse	r24, r1
     a1a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     a1e:	0f 90       	pop	r0
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	4d c0       	rjmp	.+154    	; 0xac0 <xQueueGenericSend+0x108>
     a26:	8c 81       	ldd	r24, Y+4	; 0x04
     a28:	9d 81       	ldd	r25, Y+5	; 0x05
     a2a:	89 2b       	or	r24, r25
     a2c:	21 f4       	brne	.+8      	; 0xa36 <xQueueGenericSend+0x7e>
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	45 c0       	rjmp	.+138    	; 0xac0 <xQueueGenericSend+0x108>
     a36:	d1 10       	cpse	r13, r1
     a38:	06 c0       	rjmp	.+12     	; 0xa46 <xQueueGenericSend+0x8e>
     a3a:	ce 01       	movw	r24, r28
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
     a42:	dd 24       	eor	r13, r13
     a44:	d3 94       	inc	r13
     a46:	0f 90       	pop	r0
     a48:	0f be       	out	0x3f, r0	; 63
     a4a:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
     a4e:	0f b6       	in	r0, 0x3f	; 63
     a50:	f8 94       	cli
     a52:	0f 92       	push	r0
     a54:	f8 01       	movw	r30, r16
     a56:	85 8d       	ldd	r24, Z+29	; 0x1d
     a58:	8f 3f       	cpi	r24, 0xFF	; 255
     a5a:	09 f4       	brne	.+2      	; 0xa5e <xQueueGenericSend+0xa6>
     a5c:	15 8e       	std	Z+29, r1	; 0x1d
     a5e:	f8 01       	movw	r30, r16
     a60:	86 8d       	ldd	r24, Z+30	; 0x1e
     a62:	8f 3f       	cpi	r24, 0xFF	; 255
     a64:	09 f4       	brne	.+2      	; 0xa68 <xQueueGenericSend+0xb0>
     a66:	16 8e       	std	Z+30, r1	; 0x1e
     a68:	0f 90       	pop	r0
     a6a:	0f be       	out	0x3f, r0	; 63
     a6c:	be 01       	movw	r22, r28
     a6e:	6c 5f       	subi	r22, 0xFC	; 252
     a70:	7f 4f       	sbci	r23, 0xFF	; 255
     a72:	ce 01       	movw	r24, r28
     a74:	01 96       	adiw	r24, 0x01	; 1
     a76:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskCheckForTimeOut>
     a7a:	81 11       	cpse	r24, r1
     a7c:	1b c0       	rjmp	.+54     	; 0xab4 <xQueueGenericSend+0xfc>
     a7e:	c8 01       	movw	r24, r16
     a80:	0e 94 aa 03 	call	0x754	; 0x754 <prvIsQueueFull>
     a84:	88 23       	and	r24, r24
     a86:	81 f0       	breq	.+32     	; 0xaa8 <xQueueGenericSend+0xf0>
     a88:	6c 81       	ldd	r22, Y+4	; 0x04
     a8a:	7d 81       	ldd	r23, Y+5	; 0x05
     a8c:	c8 01       	movw	r24, r16
     a8e:	08 96       	adiw	r24, 0x08	; 8
     a90:	0e 94 12 0a 	call	0x1424	; 0x1424 <vTaskPlaceOnEventList>
     a94:	c8 01       	movw	r24, r16
     a96:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     a9a:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     a9e:	81 11       	cpse	r24, r1
     aa0:	9e cf       	rjmp	.-196    	; 0x9de <xQueueGenericSend+0x26>
     aa2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     aa6:	9b cf       	rjmp	.-202    	; 0x9de <xQueueGenericSend+0x26>
     aa8:	c8 01       	movw	r24, r16
     aaa:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     aae:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     ab2:	95 cf       	rjmp	.-214    	; 0x9de <xQueueGenericSend+0x26>
     ab4:	c8 01       	movw	r24, r16
     ab6:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     aba:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     abe:	80 e0       	ldi	r24, 0x00	; 0
     ac0:	0f 90       	pop	r0
     ac2:	0f 90       	pop	r0
     ac4:	0f 90       	pop	r0
     ac6:	0f 90       	pop	r0
     ac8:	0f 90       	pop	r0
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	ff 90       	pop	r15
     ad4:	ef 90       	pop	r14
     ad6:	df 90       	pop	r13
     ad8:	cf 90       	pop	r12
     ada:	08 95       	ret

00000adc <xQueueCreateMutex>:
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29
     ae0:	8f e1       	ldi	r24, 0x1F	; 31
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     ae8:	ec 01       	movw	r28, r24
     aea:	89 2b       	or	r24, r25
     aec:	f9 f0       	breq	.+62     	; 0xb2c <xQueueCreateMutex+0x50>
     aee:	1b 82       	std	Y+3, r1	; 0x03
     af0:	1a 82       	std	Y+2, r1	; 0x02
     af2:	19 82       	std	Y+1, r1	; 0x01
     af4:	18 82       	st	Y, r1
     af6:	1d 82       	std	Y+5, r1	; 0x05
     af8:	1c 82       	std	Y+4, r1	; 0x04
     afa:	1f 82       	std	Y+7, r1	; 0x07
     afc:	1e 82       	std	Y+6, r1	; 0x06
     afe:	1a 8e       	std	Y+26, r1	; 0x1a
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	8b 8f       	std	Y+27, r24	; 0x1b
     b04:	1c 8e       	std	Y+28, r1	; 0x1c
     b06:	8f ef       	ldi	r24, 0xFF	; 255
     b08:	8d 8f       	std	Y+29, r24	; 0x1d
     b0a:	8e 8f       	std	Y+30, r24	; 0x1e
     b0c:	ce 01       	movw	r24, r28
     b0e:	08 96       	adiw	r24, 0x08	; 8
     b10:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     b14:	ce 01       	movw	r24, r28
     b16:	41 96       	adiw	r24, 0x11	; 17
     b18:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     b1c:	20 e0       	ldi	r18, 0x00	; 0
     b1e:	40 e0       	ldi	r20, 0x00	; 0
     b20:	50 e0       	ldi	r21, 0x00	; 0
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	70 e0       	ldi	r23, 0x00	; 0
     b26:	ce 01       	movw	r24, r28
     b28:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
     b2c:	ce 01       	movw	r24, r28
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	08 95       	ret

00000b34 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     b34:	af 92       	push	r10
     b36:	bf 92       	push	r11
     b38:	cf 92       	push	r12
     b3a:	df 92       	push	r13
     b3c:	ef 92       	push	r14
     b3e:	ff 92       	push	r15
     b40:	0f 93       	push	r16
     b42:	1f 93       	push	r17
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <xQueueGenericReceive+0x16>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <xQueueGenericReceive+0x18>
     b4c:	1f 92       	push	r1
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
     b52:	8c 01       	movw	r16, r24
     b54:	6b 01       	movw	r12, r22
     b56:	5d 83       	std	Y+5, r21	; 0x05
     b58:	4c 83       	std	Y+4, r20	; 0x04
     b5a:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     b5c:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     b64:	f8 01       	movw	r30, r16
     b66:	82 8d       	ldd	r24, Z+26	; 0x1a
     b68:	88 23       	and	r24, r24
     b6a:	99 f1       	breq	.+102    	; 0xbd2 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     b6c:	a6 80       	ldd	r10, Z+6	; 0x06
     b6e:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     b70:	b6 01       	movw	r22, r12
     b72:	c8 01       	movw	r24, r16
     b74:	0e 94 18 04 	call	0x830	; 0x830 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     b78:	e1 10       	cpse	r14, r1
     b7a:	1a c0       	rjmp	.+52     	; 0xbb0 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     b7c:	f8 01       	movw	r30, r16
     b7e:	82 8d       	ldd	r24, Z+26	; 0x1a
     b80:	81 50       	subi	r24, 0x01	; 1
     b82:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b84:	80 81       	ld	r24, Z
     b86:	91 81       	ldd	r25, Z+1	; 0x01
     b88:	89 2b       	or	r24, r25
     b8a:	29 f4       	brne	.+10     	; 0xb96 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     b8c:	0e 94 cf 0b 	call	0x179e	; 0x179e <pvTaskIncrementMutexHeldCount>
     b90:	f8 01       	movw	r30, r16
     b92:	93 83       	std	Z+3, r25	; 0x03
     b94:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b96:	f8 01       	movw	r30, r16
     b98:	80 85       	ldd	r24, Z+8	; 0x08
     b9a:	88 23       	and	r24, r24
     b9c:	b1 f0       	breq	.+44     	; 0xbca <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     b9e:	c8 01       	movw	r24, r16
     ba0:	08 96       	adiw	r24, 0x08	; 8
     ba2:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     ba6:	81 30       	cpi	r24, 0x01	; 1
     ba8:	81 f4       	brne	.+32     	; 0xbca <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     baa:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     bae:	0d c0       	rjmp	.+26     	; 0xbca <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     bb0:	f8 01       	movw	r30, r16
     bb2:	b7 82       	std	Z+7, r11	; 0x07
     bb4:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bb6:	81 89       	ldd	r24, Z+17	; 0x11
     bb8:	88 23       	and	r24, r24
     bba:	39 f0       	breq	.+14     	; 0xbca <xQueueGenericReceive+0x96>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bbc:	c8 01       	movw	r24, r16
     bbe:	41 96       	adiw	r24, 0x11	; 17
     bc0:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     bc4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     bc6:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	5b c0       	rjmp	.+182    	; 0xc88 <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     bd2:	8c 81       	ldd	r24, Y+4	; 0x04
     bd4:	9d 81       	ldd	r25, Y+5	; 0x05
     bd6:	89 2b       	or	r24, r25
     bd8:	21 f4       	brne	.+8      	; 0xbe2 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     bda:	0f 90       	pop	r0
     bdc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	53 c0       	rjmp	.+166    	; 0xc88 <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
     be2:	f1 10       	cpse	r15, r1
     be4:	06 c0       	rjmp	.+12     	; 0xbf2 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     bee:	ff 24       	eor	r15, r15
     bf0:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     bf2:	0f 90       	pop	r0
     bf4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     bf6:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	0f 92       	push	r0
     c00:	f8 01       	movw	r30, r16
     c02:	85 8d       	ldd	r24, Z+29	; 0x1d
     c04:	8f 3f       	cpi	r24, 0xFF	; 255
     c06:	09 f4       	brne	.+2      	; 0xc0a <xQueueGenericReceive+0xd6>
     c08:	15 8e       	std	Z+29, r1	; 0x1d
     c0a:	f8 01       	movw	r30, r16
     c0c:	86 8d       	ldd	r24, Z+30	; 0x1e
     c0e:	8f 3f       	cpi	r24, 0xFF	; 255
     c10:	09 f4       	brne	.+2      	; 0xc14 <xQueueGenericReceive+0xe0>
     c12:	16 8e       	std	Z+30, r1	; 0x1e
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c18:	be 01       	movw	r22, r28
     c1a:	6c 5f       	subi	r22, 0xFC	; 252
     c1c:	7f 4f       	sbci	r23, 0xFF	; 255
     c1e:	ce 01       	movw	r24, r28
     c20:	01 96       	adiw	r24, 0x01	; 1
     c22:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskCheckForTimeOut>
     c26:	81 11       	cpse	r24, r1
     c28:	29 c0       	rjmp	.+82     	; 0xc7c <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 9d 03 	call	0x73a	; 0x73a <prvIsQueueEmpty>
     c30:	88 23       	and	r24, r24
     c32:	f1 f0       	breq	.+60     	; 0xc70 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c34:	f8 01       	movw	r30, r16
     c36:	80 81       	ld	r24, Z
     c38:	91 81       	ldd	r25, Z+1	; 0x01
     c3a:	89 2b       	or	r24, r25
     c3c:	49 f4       	brne	.+18     	; 0xc50 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     c3e:	0f b6       	in	r0, 0x3f	; 63
     c40:	f8 94       	cli
     c42:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     c44:	82 81       	ldd	r24, Z+2	; 0x02
     c46:	93 81       	ldd	r25, Z+3	; 0x03
     c48:	0e 94 16 0b 	call	0x162c	; 0x162c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     c4c:	0f 90       	pop	r0
     c4e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c50:	6c 81       	ldd	r22, Y+4	; 0x04
     c52:	7d 81       	ldd	r23, Y+5	; 0x05
     c54:	c8 01       	movw	r24, r16
     c56:	41 96       	adiw	r24, 0x11	; 17
     c58:	0e 94 12 0a 	call	0x1424	; 0x1424 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     c5c:	c8 01       	movw	r24, r16
     c5e:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     c62:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     c66:	81 11       	cpse	r24, r1
     c68:	7a cf       	rjmp	.-268    	; 0xb5e <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     c6a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     c6e:	77 cf       	rjmp	.-274    	; 0xb5e <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c70:	c8 01       	movw	r24, r16
     c72:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c76:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     c7a:	71 cf       	rjmp	.-286    	; 0xb5e <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c82:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     c86:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     c88:	0f 90       	pop	r0
     c8a:	0f 90       	pop	r0
     c8c:	0f 90       	pop	r0
     c8e:	0f 90       	pop	r0
     c90:	0f 90       	pop	r0
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	ff 90       	pop	r15
     c9c:	ef 90       	pop	r14
     c9e:	df 90       	pop	r13
     ca0:	cf 90       	pop	r12
     ca2:	bf 90       	pop	r11
     ca4:	af 90       	pop	r10
     ca6:	08 95       	ret

00000ca8 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
     ca8:	e0 91 73 06 	lds	r30, 0x0673	; 0x800673 <pxDelayedTaskList>
     cac:	f0 91 74 06 	lds	r31, 0x0674	; 0x800674 <pxDelayedTaskList+0x1>
     cb0:	80 81       	ld	r24, Z
     cb2:	81 11       	cpse	r24, r1
     cb4:	07 c0       	rjmp	.+14     	; 0xcc4 <prvResetNextTaskUnblockTime+0x1c>
     cb6:	8f ef       	ldi	r24, 0xFF	; 255
     cb8:	9f ef       	ldi	r25, 0xFF	; 255
     cba:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     cbe:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     cc2:	08 95       	ret
     cc4:	e0 91 73 06 	lds	r30, 0x0673	; 0x800673 <pxDelayedTaskList>
     cc8:	f0 91 74 06 	lds	r31, 0x0674	; 0x800674 <pxDelayedTaskList+0x1>
     ccc:	05 80       	ldd	r0, Z+5	; 0x05
     cce:	f6 81       	ldd	r31, Z+6	; 0x06
     cd0:	e0 2d       	mov	r30, r0
     cd2:	06 80       	ldd	r0, Z+6	; 0x06
     cd4:	f7 81       	ldd	r31, Z+7	; 0x07
     cd6:	e0 2d       	mov	r30, r0
     cd8:	82 81       	ldd	r24, Z+2	; 0x02
     cda:	93 81       	ldd	r25, Z+3	; 0x03
     cdc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     ce0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     ce4:	08 95       	ret

00000ce6 <prvAllocateTCBAndStack>:
     ce6:	ef 92       	push	r14
     ce8:	ff 92       	push	r15
     cea:	0f 93       	push	r16
     cec:	1f 93       	push	r17
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	7c 01       	movw	r14, r24
     cf4:	eb 01       	movw	r28, r22
     cf6:	84 e3       	ldi	r24, 0x34	; 52
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     cfe:	8c 01       	movw	r16, r24
     d00:	89 2b       	or	r24, r25
     d02:	89 f0       	breq	.+34     	; 0xd26 <prvAllocateTCBAndStack+0x40>
     d04:	20 97       	sbiw	r28, 0x00	; 0
     d06:	21 f4       	brne	.+8      	; 0xd10 <prvAllocateTCBAndStack+0x2a>
     d08:	c7 01       	movw	r24, r14
     d0a:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     d0e:	01 c0       	rjmp	.+2      	; 0xd12 <prvAllocateTCBAndStack+0x2c>
     d10:	ce 01       	movw	r24, r28
     d12:	f8 01       	movw	r30, r16
     d14:	90 8f       	std	Z+24, r25	; 0x18
     d16:	87 8b       	std	Z+23, r24	; 0x17
     d18:	89 2b       	or	r24, r25
     d1a:	29 f4       	brne	.+10     	; 0xd26 <prvAllocateTCBAndStack+0x40>
     d1c:	c8 01       	movw	r24, r16
     d1e:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d22:	00 e0       	ldi	r16, 0x00	; 0
     d24:	10 e0       	ldi	r17, 0x00	; 0
     d26:	c8 01       	movw	r24, r16
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	08 95       	ret

00000d36 <prvDeleteTCB>:
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	ec 01       	movw	r28, r24
     d3c:	8f 89       	ldd	r24, Y+23	; 0x17
     d3e:	98 8d       	ldd	r25, Y+24	; 0x18
     d40:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d44:	ce 01       	movw	r24, r28
     d46:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d4a:	df 91       	pop	r29
     d4c:	cf 91       	pop	r28
     d4e:	08 95       	ret

00000d50 <prvInitialiseTCBVariables>:
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	ec 01       	movw	r28, r24
     d58:	14 2f       	mov	r17, r20
     d5a:	20 e0       	ldi	r18, 0x00	; 0
     d5c:	0f c0       	rjmp	.+30     	; 0xd7c <prvInitialiseTCBVariables+0x2c>
     d5e:	82 2f       	mov	r24, r18
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	fb 01       	movw	r30, r22
     d64:	e8 0f       	add	r30, r24
     d66:	f9 1f       	adc	r31, r25
     d68:	30 81       	ld	r19, Z
     d6a:	de 01       	movw	r26, r28
     d6c:	a8 0f       	add	r26, r24
     d6e:	b9 1f       	adc	r27, r25
     d70:	59 96       	adiw	r26, 0x19	; 25
     d72:	3c 93       	st	X, r19
     d74:	80 81       	ld	r24, Z
     d76:	88 23       	and	r24, r24
     d78:	19 f0       	breq	.+6      	; 0xd80 <prvInitialiseTCBVariables+0x30>
     d7a:	2f 5f       	subi	r18, 0xFF	; 255
     d7c:	29 31       	cpi	r18, 0x19	; 25
     d7e:	78 f3       	brcs	.-34     	; 0xd5e <prvInitialiseTCBVariables+0xe>
     d80:	19 aa       	std	Y+49, r1	; 0x31
     d82:	16 30       	cpi	r17, 0x06	; 6
     d84:	08 f0       	brcs	.+2      	; 0xd88 <prvInitialiseTCBVariables+0x38>
     d86:	15 e0       	ldi	r17, 0x05	; 5
     d88:	1e 8b       	std	Y+22, r17	; 0x16
     d8a:	1a ab       	std	Y+50, r17	; 0x32
     d8c:	1b aa       	std	Y+51, r1	; 0x33
     d8e:	ce 01       	movw	r24, r28
     d90:	02 96       	adiw	r24, 0x02	; 2
     d92:	0e 94 c5 01 	call	0x38a	; 0x38a <vListInitialiseItem>
     d96:	ce 01       	movw	r24, r28
     d98:	0c 96       	adiw	r24, 0x0c	; 12
     d9a:	0e 94 c5 01 	call	0x38a	; 0x38a <vListInitialiseItem>
     d9e:	d9 87       	std	Y+9, r29	; 0x09
     da0:	c8 87       	std	Y+8, r28	; 0x08
     da2:	86 e0       	ldi	r24, 0x06	; 6
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	81 1b       	sub	r24, r17
     da8:	91 09       	sbc	r25, r1
     daa:	9d 87       	std	Y+13, r25	; 0x0d
     dac:	8c 87       	std	Y+12, r24	; 0x0c
     dae:	db 8b       	std	Y+19, r29	; 0x13
     db0:	ca 8b       	std	Y+18, r28	; 0x12
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	08 95       	ret

00000dba <prvInitialiseTaskLists>:
     dba:	cf 93       	push	r28
     dbc:	c0 e0       	ldi	r28, 0x00	; 0
     dbe:	10 c0       	rjmp	.+32     	; 0xde0 <prvInitialiseTaskLists+0x26>
     dc0:	8c 2f       	mov	r24, r28
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	9c 01       	movw	r18, r24
     dc6:	22 0f       	add	r18, r18
     dc8:	33 1f       	adc	r19, r19
     dca:	22 0f       	add	r18, r18
     dcc:	33 1f       	adc	r19, r19
     dce:	22 0f       	add	r18, r18
     dd0:	33 1f       	adc	r19, r19
     dd2:	82 0f       	add	r24, r18
     dd4:	93 1f       	adc	r25, r19
     dd6:	89 57       	subi	r24, 0x79	; 121
     dd8:	99 4f       	sbci	r25, 0xF9	; 249
     dda:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dde:	cf 5f       	subi	r28, 0xFF	; 255
     de0:	c6 30       	cpi	r28, 0x06	; 6
     de2:	70 f3       	brcs	.-36     	; 0xdc0 <prvInitialiseTaskLists+0x6>
     de4:	8e e7       	ldi	r24, 0x7E	; 126
     de6:	96 e0       	ldi	r25, 0x06	; 6
     de8:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dec:	85 e7       	ldi	r24, 0x75	; 117
     dee:	96 e0       	ldi	r25, 0x06	; 6
     df0:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     df4:	88 e6       	ldi	r24, 0x68	; 104
     df6:	96 e0       	ldi	r25, 0x06	; 6
     df8:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dfc:	8f e5       	ldi	r24, 0x5F	; 95
     dfe:	96 e0       	ldi	r25, 0x06	; 6
     e00:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     e04:	8e e7       	ldi	r24, 0x7E	; 126
     e06:	96 e0       	ldi	r25, 0x06	; 6
     e08:	90 93 74 06 	sts	0x0674, r25	; 0x800674 <pxDelayedTaskList+0x1>
     e0c:	80 93 73 06 	sts	0x0673, r24	; 0x800673 <pxDelayedTaskList>
     e10:	85 e7       	ldi	r24, 0x75	; 117
     e12:	96 e0       	ldi	r25, 0x06	; 6
     e14:	90 93 72 06 	sts	0x0672, r25	; 0x800672 <pxOverflowDelayedTaskList+0x1>
     e18:	80 93 71 06 	sts	0x0671, r24	; 0x800671 <pxOverflowDelayedTaskList>
     e1c:	cf 91       	pop	r28
     e1e:	08 95       	ret

00000e20 <prvAddCurrentTaskToDelayedList>:
     e20:	cf 93       	push	r28
     e22:	df 93       	push	r29
     e24:	ec 01       	movw	r28, r24
     e26:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
     e2a:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     e2e:	93 83       	std	Z+3, r25	; 0x03
     e30:	82 83       	std	Z+2, r24	; 0x02
     e32:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xTickCount>
     e36:	90 91 5c 06 	lds	r25, 0x065C	; 0x80065c <xTickCount+0x1>
     e3a:	c8 17       	cp	r28, r24
     e3c:	d9 07       	cpc	r29, r25
     e3e:	68 f4       	brcc	.+26     	; 0xe5a <prvAddCurrentTaskToDelayedList+0x3a>
     e40:	60 91 bd 06 	lds	r22, 0x06BD	; 0x8006bd <pxCurrentTCB>
     e44:	70 91 be 06 	lds	r23, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     e48:	80 91 71 06 	lds	r24, 0x0671	; 0x800671 <pxOverflowDelayedTaskList>
     e4c:	90 91 72 06 	lds	r25, 0x0672	; 0x800672 <pxOverflowDelayedTaskList+0x1>
     e50:	6e 5f       	subi	r22, 0xFE	; 254
     e52:	7f 4f       	sbci	r23, 0xFF	; 255
     e54:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
     e58:	17 c0       	rjmp	.+46     	; 0xe88 <prvAddCurrentTaskToDelayedList+0x68>
     e5a:	60 91 bd 06 	lds	r22, 0x06BD	; 0x8006bd <pxCurrentTCB>
     e5e:	70 91 be 06 	lds	r23, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     e62:	80 91 73 06 	lds	r24, 0x0673	; 0x800673 <pxDelayedTaskList>
     e66:	90 91 74 06 	lds	r25, 0x0674	; 0x800674 <pxDelayedTaskList+0x1>
     e6a:	6e 5f       	subi	r22, 0xFE	; 254
     e6c:	7f 4f       	sbci	r23, 0xFF	; 255
     e6e:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
     e72:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     e76:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     e7a:	c8 17       	cp	r28, r24
     e7c:	d9 07       	cpc	r29, r25
     e7e:	20 f4       	brcc	.+8      	; 0xe88 <prvAddCurrentTaskToDelayedList+0x68>
     e80:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     e84:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	08 95       	ret

00000e8e <xTaskGenericCreate>:
     e8e:	2f 92       	push	r2
     e90:	3f 92       	push	r3
     e92:	4f 92       	push	r4
     e94:	5f 92       	push	r5
     e96:	7f 92       	push	r7
     e98:	8f 92       	push	r8
     e9a:	9f 92       	push	r9
     e9c:	af 92       	push	r10
     e9e:	bf 92       	push	r11
     ea0:	cf 92       	push	r12
     ea2:	df 92       	push	r13
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <xTaskGenericCreate+0x24>
     eb2:	00 d0       	rcall	.+0      	; 0xeb4 <xTaskGenericCreate+0x26>
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	9a 83       	std	Y+2, r25	; 0x02
     eba:	89 83       	std	Y+1, r24	; 0x01
     ebc:	4b 01       	movw	r8, r22
     ebe:	5c 83       	std	Y+4, r21	; 0x04
     ec0:	4b 83       	std	Y+3, r20	; 0x03
     ec2:	19 01       	movw	r2, r18
     ec4:	70 2e       	mov	r7, r16
     ec6:	b6 01       	movw	r22, r12
     ec8:	25 01       	movw	r4, r10
     eca:	ca 01       	movw	r24, r20
     ecc:	0e 94 73 06 	call	0xce6	; 0xce6 <prvAllocateTCBAndStack>
     ed0:	5c 01       	movw	r10, r24
     ed2:	00 97       	sbiw	r24, 0x00	; 0
     ed4:	09 f4       	brne	.+2      	; 0xed8 <xTaskGenericCreate+0x4a>
     ed6:	6a c0       	rjmp	.+212    	; 0xfac <xTaskGenericCreate+0x11e>
     ed8:	fc 01       	movw	r30, r24
     eda:	c7 88       	ldd	r12, Z+23	; 0x17
     edc:	d0 8c       	ldd	r13, Z+24	; 0x18
     ede:	8b 81       	ldd	r24, Y+3	; 0x03
     ee0:	9c 81       	ldd	r25, Y+4	; 0x04
     ee2:	01 97       	sbiw	r24, 0x01	; 1
     ee4:	c8 0e       	add	r12, r24
     ee6:	d9 1e       	adc	r13, r25
     ee8:	0b 81       	ldd	r16, Y+3	; 0x03
     eea:	1c 81       	ldd	r17, Y+4	; 0x04
     eec:	92 01       	movw	r18, r4
     eee:	47 2d       	mov	r20, r7
     ef0:	b4 01       	movw	r22, r8
     ef2:	c5 01       	movw	r24, r10
     ef4:	0e 94 a8 06 	call	0xd50	; 0xd50 <prvInitialiseTCBVariables>
     ef8:	a1 01       	movw	r20, r2
     efa:	69 81       	ldd	r22, Y+1	; 0x01
     efc:	7a 81       	ldd	r23, Y+2	; 0x02
     efe:	c6 01       	movw	r24, r12
     f00:	0e 94 4a 02 	call	0x494	; 0x494 <pxPortInitialiseStack>
     f04:	f5 01       	movw	r30, r10
     f06:	91 83       	std	Z+1, r25	; 0x01
     f08:	80 83       	st	Z, r24
     f0a:	e1 14       	cp	r14, r1
     f0c:	f1 04       	cpc	r15, r1
     f0e:	19 f0       	breq	.+6      	; 0xf16 <xTaskGenericCreate+0x88>
     f10:	f7 01       	movw	r30, r14
     f12:	b1 82       	std	Z+1, r11	; 0x01
     f14:	a0 82       	st	Z, r10
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	f8 94       	cli
     f1a:	0f 92       	push	r0
     f1c:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <uxCurrentNumberOfTasks>
     f20:	8f 5f       	subi	r24, 0xFF	; 255
     f22:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <uxCurrentNumberOfTasks>
     f26:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxCurrentTCB>
     f2a:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     f2e:	89 2b       	or	r24, r25
     f30:	59 f4       	brne	.+22     	; 0xf48 <xTaskGenericCreate+0xba>
     f32:	b0 92 be 06 	sts	0x06BE, r11	; 0x8006be <pxCurrentTCB+0x1>
     f36:	a0 92 bd 06 	sts	0x06BD, r10	; 0x8006bd <pxCurrentTCB>
     f3a:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <uxCurrentNumberOfTasks>
     f3e:	81 30       	cpi	r24, 0x01	; 1
     f40:	91 f4       	brne	.+36     	; 0xf66 <xTaskGenericCreate+0xd8>
     f42:	0e 94 dd 06 	call	0xdba	; 0xdba <prvInitialiseTaskLists>
     f46:	0f c0       	rjmp	.+30     	; 0xf66 <xTaskGenericCreate+0xd8>
     f48:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <xSchedulerRunning>
     f4c:	81 11       	cpse	r24, r1
     f4e:	0b c0       	rjmp	.+22     	; 0xf66 <xTaskGenericCreate+0xd8>
     f50:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
     f54:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     f58:	86 89       	ldd	r24, Z+22	; 0x16
     f5a:	78 16       	cp	r7, r24
     f5c:	20 f0       	brcs	.+8      	; 0xf66 <xTaskGenericCreate+0xd8>
     f5e:	b0 92 be 06 	sts	0x06BE, r11	; 0x8006be <pxCurrentTCB+0x1>
     f62:	a0 92 bd 06 	sts	0x06BD, r10	; 0x8006bd <pxCurrentTCB>
     f66:	80 91 55 06 	lds	r24, 0x0655	; 0x800655 <uxTaskNumber>
     f6a:	8f 5f       	subi	r24, 0xFF	; 255
     f6c:	80 93 55 06 	sts	0x0655, r24	; 0x800655 <uxTaskNumber>
     f70:	f5 01       	movw	r30, r10
     f72:	86 89       	ldd	r24, Z+22	; 0x16
     f74:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
     f78:	98 17       	cp	r25, r24
     f7a:	10 f4       	brcc	.+4      	; 0xf80 <xTaskGenericCreate+0xf2>
     f7c:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	b5 01       	movw	r22, r10
     f84:	6e 5f       	subi	r22, 0xFE	; 254
     f86:	7f 4f       	sbci	r23, 0xFF	; 255
     f88:	9c 01       	movw	r18, r24
     f8a:	22 0f       	add	r18, r18
     f8c:	33 1f       	adc	r19, r19
     f8e:	22 0f       	add	r18, r18
     f90:	33 1f       	adc	r19, r19
     f92:	22 0f       	add	r18, r18
     f94:	33 1f       	adc	r19, r19
     f96:	82 0f       	add	r24, r18
     f98:	93 1f       	adc	r25, r19
     f9a:	89 57       	subi	r24, 0x79	; 121
     f9c:	99 4f       	sbci	r25, 0xF9	; 249
     f9e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
     fa2:	0f 90       	pop	r0
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	f1 e0       	ldi	r31, 0x01	; 1
     fa8:	f9 83       	std	Y+1, r31	; 0x01
     faa:	02 c0       	rjmp	.+4      	; 0xfb0 <xTaskGenericCreate+0x122>
     fac:	8f ef       	ldi	r24, 0xFF	; 255
     fae:	89 83       	std	Y+1, r24	; 0x01
     fb0:	e9 81       	ldd	r30, Y+1	; 0x01
     fb2:	e1 30       	cpi	r30, 0x01	; 1
     fb4:	69 f4       	brne	.+26     	; 0xfd0 <xTaskGenericCreate+0x142>
     fb6:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <xSchedulerRunning>
     fba:	88 23       	and	r24, r24
     fbc:	49 f0       	breq	.+18     	; 0xfd0 <xTaskGenericCreate+0x142>
     fbe:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
     fc2:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
     fc6:	86 89       	ldd	r24, Z+22	; 0x16
     fc8:	87 15       	cp	r24, r7
     fca:	10 f4       	brcc	.+4      	; 0xfd0 <xTaskGenericCreate+0x142>
     fcc:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     fd0:	89 81       	ldd	r24, Y+1	; 0x01
     fd2:	0f 90       	pop	r0
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	df 91       	pop	r29
     fdc:	cf 91       	pop	r28
     fde:	1f 91       	pop	r17
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	bf 90       	pop	r11
     fec:	af 90       	pop	r10
     fee:	9f 90       	pop	r9
     ff0:	8f 90       	pop	r8
     ff2:	7f 90       	pop	r7
     ff4:	5f 90       	pop	r5
     ff6:	4f 90       	pop	r4
     ff8:	3f 90       	pop	r3
     ffa:	2f 90       	pop	r2
     ffc:	08 95       	ret

00000ffe <vTaskStartScheduler>:
     ffe:	af 92       	push	r10
    1000:	bf 92       	push	r11
    1002:	cf 92       	push	r12
    1004:	df 92       	push	r13
    1006:	ef 92       	push	r14
    1008:	ff 92       	push	r15
    100a:	0f 93       	push	r16
    100c:	a1 2c       	mov	r10, r1
    100e:	b1 2c       	mov	r11, r1
    1010:	c1 2c       	mov	r12, r1
    1012:	d1 2c       	mov	r13, r1
    1014:	e1 2c       	mov	r14, r1
    1016:	f1 2c       	mov	r15, r1
    1018:	00 e0       	ldi	r16, 0x00	; 0
    101a:	20 e0       	ldi	r18, 0x00	; 0
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	45 e5       	ldi	r20, 0x55	; 85
    1020:	50 e0       	ldi	r21, 0x00	; 0
    1022:	6f e6       	ldi	r22, 0x6F	; 111
    1024:	70 e0       	ldi	r23, 0x00	; 0
    1026:	8d ea       	ldi	r24, 0xAD	; 173
    1028:	99 e0       	ldi	r25, 0x09	; 9
    102a:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	49 f4       	brne	.+18     	; 0x1044 <vTaskStartScheduler+0x46>
    1032:	f8 94       	cli
    1034:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xSchedulerRunning>
    1038:	10 92 5c 06 	sts	0x065C, r1	; 0x80065c <xTickCount+0x1>
    103c:	10 92 5b 06 	sts	0x065B, r1	; 0x80065b <xTickCount>
    1040:	0e 94 b6 02 	call	0x56c	; 0x56c <xPortStartScheduler>
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	08 95       	ret

00001054 <vTaskSuspendAll>:
    1054:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
    1058:	8f 5f       	subi	r24, 0xFF	; 255
    105a:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <uxSchedulerSuspended>
    105e:	08 95       	ret

00001060 <xTaskIncrementTick>:
    1060:	df 92       	push	r13
    1062:	ef 92       	push	r14
    1064:	ff 92       	push	r15
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
    1072:	81 11       	cpse	r24, r1
    1074:	99 c0       	rjmp	.+306    	; 0x11a8 <xTaskIncrementTick+0x148>
    1076:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xTickCount>
    107a:	90 91 5c 06 	lds	r25, 0x065C	; 0x80065c <xTickCount+0x1>
    107e:	01 96       	adiw	r24, 0x01	; 1
    1080:	90 93 5c 06 	sts	0x065C, r25	; 0x80065c <xTickCount+0x1>
    1084:	80 93 5b 06 	sts	0x065B, r24	; 0x80065b <xTickCount>
    1088:	e0 90 5b 06 	lds	r14, 0x065B	; 0x80065b <xTickCount>
    108c:	f0 90 5c 06 	lds	r15, 0x065C	; 0x80065c <xTickCount+0x1>
    1090:	e1 14       	cp	r14, r1
    1092:	f1 04       	cpc	r15, r1
    1094:	b9 f4       	brne	.+46     	; 0x10c4 <xTaskIncrementTick+0x64>
    1096:	80 91 73 06 	lds	r24, 0x0673	; 0x800673 <pxDelayedTaskList>
    109a:	90 91 74 06 	lds	r25, 0x0674	; 0x800674 <pxDelayedTaskList+0x1>
    109e:	20 91 71 06 	lds	r18, 0x0671	; 0x800671 <pxOverflowDelayedTaskList>
    10a2:	30 91 72 06 	lds	r19, 0x0672	; 0x800672 <pxOverflowDelayedTaskList+0x1>
    10a6:	30 93 74 06 	sts	0x0674, r19	; 0x800674 <pxDelayedTaskList+0x1>
    10aa:	20 93 73 06 	sts	0x0673, r18	; 0x800673 <pxDelayedTaskList>
    10ae:	90 93 72 06 	sts	0x0672, r25	; 0x800672 <pxOverflowDelayedTaskList+0x1>
    10b2:	80 93 71 06 	sts	0x0671, r24	; 0x800671 <pxOverflowDelayedTaskList>
    10b6:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <xNumOfOverflows>
    10ba:	8f 5f       	subi	r24, 0xFF	; 255
    10bc:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <xNumOfOverflows>
    10c0:	0e 94 54 06 	call	0xca8	; 0xca8 <prvResetNextTaskUnblockTime>
    10c4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    10c8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    10cc:	e8 16       	cp	r14, r24
    10ce:	f9 06       	cpc	r15, r25
    10d0:	28 f4       	brcc	.+10     	; 0x10dc <xTaskIncrementTick+0x7c>
    10d2:	d1 2c       	mov	r13, r1
    10d4:	53 c0       	rjmp	.+166    	; 0x117c <xTaskIncrementTick+0x11c>
    10d6:	dd 24       	eor	r13, r13
    10d8:	d3 94       	inc	r13
    10da:	01 c0       	rjmp	.+2      	; 0x10de <xTaskIncrementTick+0x7e>
    10dc:	d1 2c       	mov	r13, r1
    10de:	e0 91 73 06 	lds	r30, 0x0673	; 0x800673 <pxDelayedTaskList>
    10e2:	f0 91 74 06 	lds	r31, 0x0674	; 0x800674 <pxDelayedTaskList+0x1>
    10e6:	80 81       	ld	r24, Z
    10e8:	81 11       	cpse	r24, r1
    10ea:	07 c0       	rjmp	.+14     	; 0x10fa <xTaskIncrementTick+0x9a>
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	9f ef       	ldi	r25, 0xFF	; 255
    10f0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    10f4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    10f8:	41 c0       	rjmp	.+130    	; 0x117c <xTaskIncrementTick+0x11c>
    10fa:	e0 91 73 06 	lds	r30, 0x0673	; 0x800673 <pxDelayedTaskList>
    10fe:	f0 91 74 06 	lds	r31, 0x0674	; 0x800674 <pxDelayedTaskList+0x1>
    1102:	05 80       	ldd	r0, Z+5	; 0x05
    1104:	f6 81       	ldd	r31, Z+6	; 0x06
    1106:	e0 2d       	mov	r30, r0
    1108:	c6 81       	ldd	r28, Z+6	; 0x06
    110a:	d7 81       	ldd	r29, Z+7	; 0x07
    110c:	8a 81       	ldd	r24, Y+2	; 0x02
    110e:	9b 81       	ldd	r25, Y+3	; 0x03
    1110:	e8 16       	cp	r14, r24
    1112:	f9 06       	cpc	r15, r25
    1114:	28 f4       	brcc	.+10     	; 0x1120 <xTaskIncrementTick+0xc0>
    1116:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    111a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    111e:	2e c0       	rjmp	.+92     	; 0x117c <xTaskIncrementTick+0x11c>
    1120:	8e 01       	movw	r16, r28
    1122:	0e 5f       	subi	r16, 0xFE	; 254
    1124:	1f 4f       	sbci	r17, 0xFF	; 255
    1126:	c8 01       	movw	r24, r16
    1128:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    112c:	8c 89       	ldd	r24, Y+20	; 0x14
    112e:	9d 89       	ldd	r25, Y+21	; 0x15
    1130:	89 2b       	or	r24, r25
    1132:	21 f0       	breq	.+8      	; 0x113c <xTaskIncrementTick+0xdc>
    1134:	ce 01       	movw	r24, r28
    1136:	0c 96       	adiw	r24, 0x0c	; 12
    1138:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    113c:	8e 89       	ldd	r24, Y+22	; 0x16
    113e:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
    1142:	98 17       	cp	r25, r24
    1144:	10 f4       	brcc	.+4      	; 0x114a <xTaskIncrementTick+0xea>
    1146:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	9c 01       	movw	r18, r24
    114e:	22 0f       	add	r18, r18
    1150:	33 1f       	adc	r19, r19
    1152:	22 0f       	add	r18, r18
    1154:	33 1f       	adc	r19, r19
    1156:	22 0f       	add	r18, r18
    1158:	33 1f       	adc	r19, r19
    115a:	82 0f       	add	r24, r18
    115c:	93 1f       	adc	r25, r19
    115e:	b8 01       	movw	r22, r16
    1160:	89 57       	subi	r24, 0x79	; 121
    1162:	99 4f       	sbci	r25, 0xF9	; 249
    1164:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1168:	9e 89       	ldd	r25, Y+22	; 0x16
    116a:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    116e:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1172:	86 89       	ldd	r24, Z+22	; 0x16
    1174:	98 17       	cp	r25, r24
    1176:	08 f0       	brcs	.+2      	; 0x117a <xTaskIncrementTick+0x11a>
    1178:	ae cf       	rjmp	.-164    	; 0x10d6 <xTaskIncrementTick+0x76>
    117a:	b1 cf       	rjmp	.-158    	; 0x10de <xTaskIncrementTick+0x7e>
    117c:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1180:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1184:	86 89       	ldd	r24, Z+22	; 0x16
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	fc 01       	movw	r30, r24
    118a:	ee 0f       	add	r30, r30
    118c:	ff 1f       	adc	r31, r31
    118e:	ee 0f       	add	r30, r30
    1190:	ff 1f       	adc	r31, r31
    1192:	ee 0f       	add	r30, r30
    1194:	ff 1f       	adc	r31, r31
    1196:	8e 0f       	add	r24, r30
    1198:	9f 1f       	adc	r25, r31
    119a:	fc 01       	movw	r30, r24
    119c:	e9 57       	subi	r30, 0x79	; 121
    119e:	f9 4f       	sbci	r31, 0xF9	; 249
    11a0:	80 81       	ld	r24, Z
    11a2:	82 30       	cpi	r24, 0x02	; 2
    11a4:	40 f4       	brcc	.+16     	; 0x11b6 <xTaskIncrementTick+0x156>
    11a6:	09 c0       	rjmp	.+18     	; 0x11ba <xTaskIncrementTick+0x15a>
    11a8:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxPendedTicks>
    11ac:	8f 5f       	subi	r24, 0xFF	; 255
    11ae:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <uxPendedTicks>
    11b2:	d1 2c       	mov	r13, r1
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <xTaskIncrementTick+0x15a>
    11b6:	dd 24       	eor	r13, r13
    11b8:	d3 94       	inc	r13
    11ba:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <xYieldPending>
    11be:	88 23       	and	r24, r24
    11c0:	11 f0       	breq	.+4      	; 0x11c6 <xTaskIncrementTick+0x166>
    11c2:	dd 24       	eor	r13, r13
    11c4:	d3 94       	inc	r13
    11c6:	8d 2d       	mov	r24, r13
    11c8:	df 91       	pop	r29
    11ca:	cf 91       	pop	r28
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	ff 90       	pop	r15
    11d2:	ef 90       	pop	r14
    11d4:	df 90       	pop	r13
    11d6:	08 95       	ret

000011d8 <xTaskResumeAll>:
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	0f b6       	in	r0, 0x3f	; 63
    11e2:	f8 94       	cli
    11e4:	0f 92       	push	r0
    11e6:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
    11ea:	81 50       	subi	r24, 0x01	; 1
    11ec:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <uxSchedulerSuspended>
    11f0:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
    11f4:	81 11       	cpse	r24, r1
    11f6:	57 c0       	rjmp	.+174    	; 0x12a6 <xTaskResumeAll+0xce>
    11f8:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <uxCurrentNumberOfTasks>
    11fc:	81 11       	cpse	r24, r1
    11fe:	32 c0       	rjmp	.+100    	; 0x1264 <xTaskResumeAll+0x8c>
    1200:	55 c0       	rjmp	.+170    	; 0x12ac <xTaskResumeAll+0xd4>
    1202:	e0 91 6d 06 	lds	r30, 0x066D	; 0x80066d <xPendingReadyList+0x5>
    1206:	f0 91 6e 06 	lds	r31, 0x066E	; 0x80066e <xPendingReadyList+0x6>
    120a:	c6 81       	ldd	r28, Z+6	; 0x06
    120c:	d7 81       	ldd	r29, Z+7	; 0x07
    120e:	ce 01       	movw	r24, r28
    1210:	0c 96       	adiw	r24, 0x0c	; 12
    1212:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1216:	8e 01       	movw	r16, r28
    1218:	0e 5f       	subi	r16, 0xFE	; 254
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	c8 01       	movw	r24, r16
    121e:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1222:	8e 89       	ldd	r24, Y+22	; 0x16
    1224:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
    1228:	98 17       	cp	r25, r24
    122a:	10 f4       	brcc	.+4      	; 0x1230 <xTaskResumeAll+0x58>
    122c:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	9c 01       	movw	r18, r24
    1234:	22 0f       	add	r18, r18
    1236:	33 1f       	adc	r19, r19
    1238:	22 0f       	add	r18, r18
    123a:	33 1f       	adc	r19, r19
    123c:	22 0f       	add	r18, r18
    123e:	33 1f       	adc	r19, r19
    1240:	82 0f       	add	r24, r18
    1242:	93 1f       	adc	r25, r19
    1244:	b8 01       	movw	r22, r16
    1246:	89 57       	subi	r24, 0x79	; 121
    1248:	99 4f       	sbci	r25, 0xF9	; 249
    124a:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    124e:	9e 89       	ldd	r25, Y+22	; 0x16
    1250:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1254:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1258:	86 89       	ldd	r24, Z+22	; 0x16
    125a:	98 17       	cp	r25, r24
    125c:	18 f0       	brcs	.+6      	; 0x1264 <xTaskResumeAll+0x8c>
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xYieldPending>
    1264:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <xPendingReadyList>
    1268:	81 11       	cpse	r24, r1
    126a:	cb cf       	rjmp	.-106    	; 0x1202 <xTaskResumeAll+0x2a>
    126c:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxPendedTicks>
    1270:	81 11       	cpse	r24, r1
    1272:	0d c0       	rjmp	.+26     	; 0x128e <xTaskResumeAll+0xb6>
    1274:	10 c0       	rjmp	.+32     	; 0x1296 <xTaskResumeAll+0xbe>
    1276:	0e 94 30 08 	call	0x1060	; 0x1060 <xTaskIncrementTick>
    127a:	88 23       	and	r24, r24
    127c:	19 f0       	breq	.+6      	; 0x1284 <xTaskResumeAll+0xac>
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xYieldPending>
    1284:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxPendedTicks>
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <uxPendedTicks>
    128e:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxPendedTicks>
    1292:	81 11       	cpse	r24, r1
    1294:	f0 cf       	rjmp	.-32     	; 0x1276 <xTaskResumeAll+0x9e>
    1296:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <xYieldPending>
    129a:	81 30       	cpi	r24, 0x01	; 1
    129c:	31 f4       	brne	.+12     	; 0x12aa <xTaskResumeAll+0xd2>
    129e:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	03 c0       	rjmp	.+6      	; 0x12ac <xTaskResumeAll+0xd4>
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <xTaskResumeAll+0xd4>
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	0f 90       	pop	r0
    12ae:	0f be       	out	0x3f, r0	; 63
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	08 95       	ret

000012ba <vTaskDelay>:
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ec 01       	movw	r28, r24
    12c0:	89 2b       	or	r24, r25
    12c2:	a9 f0       	breq	.+42     	; 0x12ee <vTaskDelay+0x34>
    12c4:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
    12c8:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xTickCount>
    12cc:	90 91 5c 06 	lds	r25, 0x065C	; 0x80065c <xTickCount+0x1>
    12d0:	c8 0f       	add	r28, r24
    12d2:	d9 1f       	adc	r29, r25
    12d4:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxCurrentTCB>
    12d8:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    12dc:	02 96       	adiw	r24, 0x02	; 2
    12de:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    12e2:	ce 01       	movw	r24, r28
    12e4:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    12e8:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
    12ec:	01 c0       	rjmp	.+2      	; 0x12f0 <vTaskDelay+0x36>
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	81 11       	cpse	r24, r1
    12f2:	02 c0       	rjmp	.+4      	; 0x12f8 <vTaskDelay+0x3e>
    12f4:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
    12fc:	08 95       	ret

000012fe <prvCheckTasksWaitingTermination>:
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	24 c0       	rjmp	.+72     	; 0x134c <prvCheckTasksWaitingTermination+0x4e>
    1304:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
    1308:	c0 91 5f 06 	lds	r28, 0x065F	; 0x80065f <xTasksWaitingTermination>
    130c:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
    1310:	cc 23       	and	r28, r28
    1312:	e1 f0       	breq	.+56     	; 0x134c <prvCheckTasksWaitingTermination+0x4e>
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	0f 92       	push	r0
    131a:	e0 91 64 06 	lds	r30, 0x0664	; 0x800664 <xTasksWaitingTermination+0x5>
    131e:	f0 91 65 06 	lds	r31, 0x0665	; 0x800665 <xTasksWaitingTermination+0x6>
    1322:	c6 81       	ldd	r28, Z+6	; 0x06
    1324:	d7 81       	ldd	r29, Z+7	; 0x07
    1326:	ce 01       	movw	r24, r28
    1328:	02 96       	adiw	r24, 0x02	; 2
    132a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    132e:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <uxCurrentNumberOfTasks>
    1332:	81 50       	subi	r24, 0x01	; 1
    1334:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <uxCurrentNumberOfTasks>
    1338:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxTasksDeleted>
    133c:	81 50       	subi	r24, 0x01	; 1
    133e:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxTasksDeleted>
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	ce 01       	movw	r24, r28
    1348:	0e 94 9b 06 	call	0xd36	; 0xd36 <prvDeleteTCB>
    134c:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxTasksDeleted>
    1350:	81 11       	cpse	r24, r1
    1352:	d8 cf       	rjmp	.-80     	; 0x1304 <prvCheckTasksWaitingTermination+0x6>
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	08 95       	ret

0000135a <prvIdleTask>:
    135a:	0e 94 7f 09 	call	0x12fe	; 0x12fe <prvCheckTasksWaitingTermination>
    135e:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <pxReadyTasksLists>
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	d0 f3       	brcs	.-12     	; 0x135a <prvIdleTask>
    1366:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    136a:	f7 cf       	rjmp	.-18     	; 0x135a <prvIdleTask>

0000136c <vTaskSwitchContext>:
    136c:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
    1370:	88 23       	and	r24, r24
    1372:	21 f0       	breq	.+8      	; 0x137c <vTaskSwitchContext+0x10>
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xYieldPending>
    137a:	08 95       	ret
    137c:	10 92 57 06 	sts	0x0657, r1	; 0x800657 <xYieldPending>
    1380:	05 c0       	rjmp	.+10     	; 0x138c <vTaskSwitchContext+0x20>
    1382:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
    1386:	81 50       	subi	r24, 0x01	; 1
    1388:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    138c:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
    1390:	90 e0       	ldi	r25, 0x00	; 0
    1392:	fc 01       	movw	r30, r24
    1394:	ee 0f       	add	r30, r30
    1396:	ff 1f       	adc	r31, r31
    1398:	ee 0f       	add	r30, r30
    139a:	ff 1f       	adc	r31, r31
    139c:	ee 0f       	add	r30, r30
    139e:	ff 1f       	adc	r31, r31
    13a0:	8e 0f       	add	r24, r30
    13a2:	9f 1f       	adc	r25, r31
    13a4:	fc 01       	movw	r30, r24
    13a6:	e9 57       	subi	r30, 0x79	; 121
    13a8:	f9 4f       	sbci	r31, 0xF9	; 249
    13aa:	80 81       	ld	r24, Z
    13ac:	88 23       	and	r24, r24
    13ae:	49 f3       	breq	.-46     	; 0x1382 <vTaskSwitchContext+0x16>
    13b0:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	9c 01       	movw	r18, r24
    13b8:	22 0f       	add	r18, r18
    13ba:	33 1f       	adc	r19, r19
    13bc:	22 0f       	add	r18, r18
    13be:	33 1f       	adc	r19, r19
    13c0:	22 0f       	add	r18, r18
    13c2:	33 1f       	adc	r19, r19
    13c4:	28 0f       	add	r18, r24
    13c6:	39 1f       	adc	r19, r25
    13c8:	d9 01       	movw	r26, r18
    13ca:	a9 57       	subi	r26, 0x79	; 121
    13cc:	b9 4f       	sbci	r27, 0xF9	; 249
    13ce:	11 96       	adiw	r26, 0x01	; 1
    13d0:	ed 91       	ld	r30, X+
    13d2:	fc 91       	ld	r31, X
    13d4:	12 97       	sbiw	r26, 0x02	; 2
    13d6:	02 80       	ldd	r0, Z+2	; 0x02
    13d8:	f3 81       	ldd	r31, Z+3	; 0x03
    13da:	e0 2d       	mov	r30, r0
    13dc:	12 96       	adiw	r26, 0x02	; 2
    13de:	fc 93       	st	X, r31
    13e0:	ee 93       	st	-X, r30
    13e2:	11 97       	sbiw	r26, 0x01	; 1
    13e4:	26 57       	subi	r18, 0x76	; 118
    13e6:	39 4f       	sbci	r19, 0xF9	; 249
    13e8:	e2 17       	cp	r30, r18
    13ea:	f3 07       	cpc	r31, r19
    13ec:	29 f4       	brne	.+10     	; 0x13f8 <vTaskSwitchContext+0x8c>
    13ee:	22 81       	ldd	r18, Z+2	; 0x02
    13f0:	33 81       	ldd	r19, Z+3	; 0x03
    13f2:	fd 01       	movw	r30, r26
    13f4:	32 83       	std	Z+2, r19	; 0x02
    13f6:	21 83       	std	Z+1, r18	; 0x01
    13f8:	fc 01       	movw	r30, r24
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	ee 0f       	add	r30, r30
    1400:	ff 1f       	adc	r31, r31
    1402:	ee 0f       	add	r30, r30
    1404:	ff 1f       	adc	r31, r31
    1406:	8e 0f       	add	r24, r30
    1408:	9f 1f       	adc	r25, r31
    140a:	fc 01       	movw	r30, r24
    140c:	e9 57       	subi	r30, 0x79	; 121
    140e:	f9 4f       	sbci	r31, 0xF9	; 249
    1410:	01 80       	ldd	r0, Z+1	; 0x01
    1412:	f2 81       	ldd	r31, Z+2	; 0x02
    1414:	e0 2d       	mov	r30, r0
    1416:	86 81       	ldd	r24, Z+6	; 0x06
    1418:	97 81       	ldd	r25, Z+7	; 0x07
    141a:	90 93 be 06 	sts	0x06BE, r25	; 0x8006be <pxCurrentTCB+0x1>
    141e:	80 93 bd 06 	sts	0x06BD, r24	; 0x8006bd <pxCurrentTCB>
    1422:	08 95       	ret

00001424 <vTaskPlaceOnEventList>:
    1424:	cf 93       	push	r28
    1426:	df 93       	push	r29
    1428:	eb 01       	movw	r28, r22
    142a:	60 91 bd 06 	lds	r22, 0x06BD	; 0x8006bd <pxCurrentTCB>
    142e:	70 91 be 06 	lds	r23, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1432:	64 5f       	subi	r22, 0xF4	; 244
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
    143a:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxCurrentTCB>
    143e:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1442:	02 96       	adiw	r24, 0x02	; 2
    1444:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1448:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xTickCount>
    144c:	90 91 5c 06 	lds	r25, 0x065C	; 0x80065c <xTickCount+0x1>
    1450:	8c 0f       	add	r24, r28
    1452:	9d 1f       	adc	r25, r29
    1454:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	08 95       	ret

0000145e <vTaskPlaceOnUnorderedEventList>:
    145e:	cf 93       	push	r28
    1460:	df 93       	push	r29
    1462:	ea 01       	movw	r28, r20
    1464:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1468:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    146c:	70 68       	ori	r23, 0x80	; 128
    146e:	75 87       	std	Z+13, r23	; 0x0d
    1470:	64 87       	std	Z+12, r22	; 0x0c
    1472:	60 91 bd 06 	lds	r22, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1476:	70 91 be 06 	lds	r23, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    147a:	64 5f       	subi	r22, 0xF4	; 244
    147c:	7f 4f       	sbci	r23, 0xFF	; 255
    147e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1482:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1486:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    148a:	02 96       	adiw	r24, 0x02	; 2
    148c:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1490:	80 91 5b 06 	lds	r24, 0x065B	; 0x80065b <xTickCount>
    1494:	90 91 5c 06 	lds	r25, 0x065C	; 0x80065c <xTickCount+0x1>
    1498:	8c 0f       	add	r24, r28
    149a:	9d 1f       	adc	r25, r29
    149c:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	08 95       	ret

000014a6 <xTaskRemoveFromEventList>:
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	dc 01       	movw	r26, r24
    14b0:	15 96       	adiw	r26, 0x05	; 5
    14b2:	ed 91       	ld	r30, X+
    14b4:	fc 91       	ld	r31, X
    14b6:	16 97       	sbiw	r26, 0x06	; 6
    14b8:	c6 81       	ldd	r28, Z+6	; 0x06
    14ba:	d7 81       	ldd	r29, Z+7	; 0x07
    14bc:	8e 01       	movw	r16, r28
    14be:	04 5f       	subi	r16, 0xF4	; 244
    14c0:	1f 4f       	sbci	r17, 0xFF	; 255
    14c2:	c8 01       	movw	r24, r16
    14c4:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    14c8:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
    14cc:	81 11       	cpse	r24, r1
    14ce:	1c c0       	rjmp	.+56     	; 0x1508 <xTaskRemoveFromEventList+0x62>
    14d0:	0a 50       	subi	r16, 0x0A	; 10
    14d2:	11 09       	sbc	r17, r1
    14d4:	c8 01       	movw	r24, r16
    14d6:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    14da:	8e 89       	ldd	r24, Y+22	; 0x16
    14dc:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
    14e0:	98 17       	cp	r25, r24
    14e2:	10 f4       	brcc	.+4      	; 0x14e8 <xTaskRemoveFromEventList+0x42>
    14e4:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    14e8:	90 e0       	ldi	r25, 0x00	; 0
    14ea:	9c 01       	movw	r18, r24
    14ec:	22 0f       	add	r18, r18
    14ee:	33 1f       	adc	r19, r19
    14f0:	22 0f       	add	r18, r18
    14f2:	33 1f       	adc	r19, r19
    14f4:	22 0f       	add	r18, r18
    14f6:	33 1f       	adc	r19, r19
    14f8:	82 0f       	add	r24, r18
    14fa:	93 1f       	adc	r25, r19
    14fc:	b8 01       	movw	r22, r16
    14fe:	89 57       	subi	r24, 0x79	; 121
    1500:	99 4f       	sbci	r25, 0xF9	; 249
    1502:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1506:	05 c0       	rjmp	.+10     	; 0x1512 <xTaskRemoveFromEventList+0x6c>
    1508:	b8 01       	movw	r22, r16
    150a:	88 e6       	ldi	r24, 0x68	; 104
    150c:	96 e0       	ldi	r25, 0x06	; 6
    150e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1512:	9e 89       	ldd	r25, Y+22	; 0x16
    1514:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1518:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    151c:	86 89       	ldd	r24, Z+22	; 0x16
    151e:	89 17       	cp	r24, r25
    1520:	20 f4       	brcc	.+8      	; 0x152a <xTaskRemoveFromEventList+0x84>
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xYieldPending>
    1528:	01 c0       	rjmp	.+2      	; 0x152c <xTaskRemoveFromEventList+0x86>
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	df 91       	pop	r29
    152e:	cf 91       	pop	r28
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	08 95       	ret

00001536 <xTaskRemoveFromUnorderedEventList>:
    1536:	0f 93       	push	r16
    1538:	1f 93       	push	r17
    153a:	cf 93       	push	r28
    153c:	df 93       	push	r29
    153e:	70 68       	ori	r23, 0x80	; 128
    1540:	fc 01       	movw	r30, r24
    1542:	71 83       	std	Z+1, r23	; 0x01
    1544:	60 83       	st	Z, r22
    1546:	c6 81       	ldd	r28, Z+6	; 0x06
    1548:	d7 81       	ldd	r29, Z+7	; 0x07
    154a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    154e:	8e 01       	movw	r16, r28
    1550:	0e 5f       	subi	r16, 0xFE	; 254
    1552:	1f 4f       	sbci	r17, 0xFF	; 255
    1554:	c8 01       	movw	r24, r16
    1556:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    155a:	8e 89       	ldd	r24, Y+22	; 0x16
    155c:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
    1560:	98 17       	cp	r25, r24
    1562:	10 f4       	brcc	.+4      	; 0x1568 <xTaskRemoveFromUnorderedEventList+0x32>
    1564:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	9c 01       	movw	r18, r24
    156c:	22 0f       	add	r18, r18
    156e:	33 1f       	adc	r19, r19
    1570:	22 0f       	add	r18, r18
    1572:	33 1f       	adc	r19, r19
    1574:	22 0f       	add	r18, r18
    1576:	33 1f       	adc	r19, r19
    1578:	82 0f       	add	r24, r18
    157a:	93 1f       	adc	r25, r19
    157c:	b8 01       	movw	r22, r16
    157e:	89 57       	subi	r24, 0x79	; 121
    1580:	99 4f       	sbci	r25, 0xF9	; 249
    1582:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1586:	9e 89       	ldd	r25, Y+22	; 0x16
    1588:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    158c:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1590:	86 89       	ldd	r24, Z+22	; 0x16
    1592:	89 17       	cp	r24, r25
    1594:	20 f4       	brcc	.+8      	; 0x159e <xTaskRemoveFromUnorderedEventList+0x68>
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xYieldPending>
    159c:	01 c0       	rjmp	.+2      	; 0x15a0 <xTaskRemoveFromUnorderedEventList+0x6a>
    159e:	80 e0       	ldi	r24, 0x00	; 0
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	08 95       	ret

000015aa <vTaskSetTimeOutState>:
    15aa:	20 91 56 06 	lds	r18, 0x0656	; 0x800656 <xNumOfOverflows>
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
    15b2:	20 91 5b 06 	lds	r18, 0x065B	; 0x80065b <xTickCount>
    15b6:	30 91 5c 06 	lds	r19, 0x065C	; 0x80065c <xTickCount+0x1>
    15ba:	32 83       	std	Z+2, r19	; 0x02
    15bc:	21 83       	std	Z+1, r18	; 0x01
    15be:	08 95       	ret

000015c0 <xTaskCheckForTimeOut>:
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	fc 01       	movw	r30, r24
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
    15cc:	40 91 5b 06 	lds	r20, 0x065B	; 0x80065b <xTickCount>
    15d0:	50 91 5c 06 	lds	r21, 0x065C	; 0x80065c <xTickCount+0x1>
    15d4:	90 81       	ld	r25, Z
    15d6:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <xNumOfOverflows>
    15da:	98 17       	cp	r25, r24
    15dc:	29 f0       	breq	.+10     	; 0x15e8 <xTaskCheckForTimeOut+0x28>
    15de:	81 81       	ldd	r24, Z+1	; 0x01
    15e0:	92 81       	ldd	r25, Z+2	; 0x02
    15e2:	48 17       	cp	r20, r24
    15e4:	59 07       	cpc	r21, r25
    15e6:	b0 f4       	brcc	.+44     	; 0x1614 <xTaskCheckForTimeOut+0x54>
    15e8:	21 81       	ldd	r18, Z+1	; 0x01
    15ea:	32 81       	ldd	r19, Z+2	; 0x02
    15ec:	ca 01       	movw	r24, r20
    15ee:	82 1b       	sub	r24, r18
    15f0:	93 0b       	sbc	r25, r19
    15f2:	eb 01       	movw	r28, r22
    15f4:	a8 81       	ld	r26, Y
    15f6:	b9 81       	ldd	r27, Y+1	; 0x01
    15f8:	8a 17       	cp	r24, r26
    15fa:	9b 07       	cpc	r25, r27
    15fc:	68 f4       	brcc	.+26     	; 0x1618 <xTaskCheckForTimeOut+0x58>
    15fe:	cf 01       	movw	r24, r30
    1600:	24 1b       	sub	r18, r20
    1602:	35 0b       	sbc	r19, r21
    1604:	2a 0f       	add	r18, r26
    1606:	3b 1f       	adc	r19, r27
    1608:	39 83       	std	Y+1, r19	; 0x01
    160a:	28 83       	st	Y, r18
    160c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	03 c0       	rjmp	.+6      	; 0x161a <xTaskCheckForTimeOut+0x5a>
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	01 c0       	rjmp	.+2      	; 0x161a <xTaskCheckForTimeOut+0x5a>
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	df 91       	pop	r29
    1620:	cf 91       	pop	r28
    1622:	08 95       	ret

00001624 <vTaskMissedYield>:
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <xYieldPending>
    162a:	08 95       	ret

0000162c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1636:	89 2b       	or	r24, r25
    1638:	09 f4       	brne	.+2      	; 0x163c <vTaskPriorityInherit+0x10>
    163a:	55 c0       	rjmp	.+170    	; 0x16e6 <vTaskPriorityInherit+0xba>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    163c:	26 89       	ldd	r18, Z+22	; 0x16
    163e:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1642:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1646:	56 96       	adiw	r26, 0x16	; 22
    1648:	8c 91       	ld	r24, X
    164a:	28 17       	cp	r18, r24
    164c:	08 f0       	brcs	.+2      	; 0x1650 <vTaskPriorityInherit+0x24>
    164e:	4b c0       	rjmp	.+150    	; 0x16e6 <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1650:	84 85       	ldd	r24, Z+12	; 0x0c
    1652:	95 85       	ldd	r25, Z+13	; 0x0d
    1654:	99 23       	and	r25, r25
    1656:	64 f0       	brlt	.+24     	; 0x1670 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1658:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
    165c:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1660:	56 96       	adiw	r26, 0x16	; 22
    1662:	3c 91       	ld	r19, X
    1664:	86 e0       	ldi	r24, 0x06	; 6
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	83 1b       	sub	r24, r19
    166a:	91 09       	sbc	r25, r1
    166c:	95 87       	std	Z+13, r25	; 0x0d
    166e:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1670:	82 85       	ldd	r24, Z+10	; 0x0a
    1672:	93 85       	ldd	r25, Z+11	; 0x0b
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	a9 01       	movw	r20, r18
    1678:	44 0f       	add	r20, r20
    167a:	55 1f       	adc	r21, r21
    167c:	44 0f       	add	r20, r20
    167e:	55 1f       	adc	r21, r21
    1680:	44 0f       	add	r20, r20
    1682:	55 1f       	adc	r21, r21
    1684:	24 0f       	add	r18, r20
    1686:	35 1f       	adc	r19, r21
    1688:	29 57       	subi	r18, 0x79	; 121
    168a:	39 4f       	sbci	r19, 0xF9	; 249
    168c:	82 17       	cp	r24, r18
    168e:	93 07       	cpc	r25, r19
    1690:	19 f5       	brne	.+70     	; 0x16d8 <vTaskPriorityInherit+0xac>
    1692:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1694:	ef 01       	movw	r28, r30
    1696:	22 96       	adiw	r28, 0x02	; 2
    1698:	ce 01       	movw	r24, r28
    169a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    169e:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    16a2:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    16a6:	86 89       	ldd	r24, Z+22	; 0x16
    16a8:	f8 01       	movw	r30, r16
    16aa:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    16ac:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
    16b0:	98 17       	cp	r25, r24
    16b2:	10 f4       	brcc	.+4      	; 0x16b8 <vTaskPriorityInherit+0x8c>
    16b4:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	9c 01       	movw	r18, r24
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	22 0f       	add	r18, r18
    16c2:	33 1f       	adc	r19, r19
    16c4:	22 0f       	add	r18, r18
    16c6:	33 1f       	adc	r19, r19
    16c8:	82 0f       	add	r24, r18
    16ca:	93 1f       	adc	r25, r19
    16cc:	be 01       	movw	r22, r28
    16ce:	89 57       	subi	r24, 0x79	; 121
    16d0:	99 4f       	sbci	r25, 0xF9	; 249
    16d2:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    16d6:	07 c0       	rjmp	.+14     	; 0x16e6 <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    16d8:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
    16dc:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    16e0:	56 96       	adiw	r26, 0x16	; 22
    16e2:	8c 91       	ld	r24, X
    16e4:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    16e6:	df 91       	pop	r29
    16e8:	cf 91       	pop	r28
    16ea:	1f 91       	pop	r17
    16ec:	0f 91       	pop	r16
    16ee:	08 95       	ret

000016f0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    16fa:	89 2b       	or	r24, r25
    16fc:	79 f1       	breq	.+94     	; 0x175c <xTaskPriorityDisinherit+0x6c>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    16fe:	83 a9       	ldd	r24, Z+51	; 0x33
    1700:	81 50       	subi	r24, 0x01	; 1
    1702:	83 ab       	std	Z+51, r24	; 0x33

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1704:	26 89       	ldd	r18, Z+22	; 0x16
    1706:	92 a9       	ldd	r25, Z+50	; 0x32
    1708:	29 17       	cp	r18, r25
    170a:	51 f1       	breq	.+84     	; 0x1760 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    170c:	81 11       	cpse	r24, r1
    170e:	2a c0       	rjmp	.+84     	; 0x1764 <xTaskPriorityDisinherit+0x74>
    1710:	ef 01       	movw	r28, r30
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1712:	8f 01       	movw	r16, r30
    1714:	0e 5f       	subi	r16, 0xFE	; 254
    1716:	1f 4f       	sbci	r17, 0xFF	; 255
    1718:	c8 01       	movw	r24, r16
    171a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    171e:	8a a9       	ldd	r24, Y+50	; 0x32
    1720:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1722:	26 e0       	ldi	r18, 0x06	; 6
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	28 1b       	sub	r18, r24
    1728:	31 09       	sbc	r19, r1
    172a:	3d 87       	std	Y+13, r19	; 0x0d
    172c:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    172e:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
    1732:	98 17       	cp	r25, r24
    1734:	10 f4       	brcc	.+4      	; 0x173a <xTaskPriorityDisinherit+0x4a>
    1736:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
    173a:	90 e0       	ldi	r25, 0x00	; 0
    173c:	9c 01       	movw	r18, r24
    173e:	22 0f       	add	r18, r18
    1740:	33 1f       	adc	r19, r19
    1742:	22 0f       	add	r18, r18
    1744:	33 1f       	adc	r19, r19
    1746:	22 0f       	add	r18, r18
    1748:	33 1f       	adc	r19, r19
    174a:	82 0f       	add	r24, r18
    174c:	93 1f       	adc	r25, r19
    174e:	b8 01       	movw	r22, r16
    1750:	89 57       	subi	r24, 0x79	; 121
    1752:	99 4f       	sbci	r25, 0xF9	; 249
    1754:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	05 c0       	rjmp	.+10     	; 0x1766 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    175c:	80 e0       	ldi	r24, 0x00	; 0
    175e:	03 c0       	rjmp	.+6      	; 0x1766 <xTaskPriorityDisinherit+0x76>
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	01 c0       	rjmp	.+2      	; 0x1766 <xTaskPriorityDisinherit+0x76>
    1764:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	08 95       	ret

00001770 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1770:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1774:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1778:	84 85       	ldd	r24, Z+12	; 0x0c
    177a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    177c:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1780:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    1784:	a0 91 bd 06 	lds	r26, 0x06BD	; 0x8006bd <pxCurrentTCB>
    1788:	b0 91 be 06 	lds	r27, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    178c:	56 96       	adiw	r26, 0x16	; 22
    178e:	4c 91       	ld	r20, X
    1790:	26 e0       	ldi	r18, 0x06	; 6
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	24 1b       	sub	r18, r20
    1796:	31 09       	sbc	r19, r1
    1798:	35 87       	std	Z+13, r19	; 0x0d
    179a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    179c:	08 95       	ret

0000179e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    179e:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxCurrentTCB>
    17a2:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    17a6:	89 2b       	or	r24, r25
    17a8:	39 f0       	breq	.+14     	; 0x17b8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17aa:	e0 91 bd 06 	lds	r30, 0x06BD	; 0x8006bd <pxCurrentTCB>
    17ae:	f0 91 be 06 	lds	r31, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
    17b2:	83 a9       	ldd	r24, Z+51	; 0x33
    17b4:	8f 5f       	subi	r24, 0xFF	; 255
    17b6:	83 ab       	std	Z+51, r24	; 0x33
		}

		return pxCurrentTCB;
    17b8:	80 91 bd 06 	lds	r24, 0x06BD	; 0x8006bd <pxCurrentTCB>
    17bc:	90 91 be 06 	lds	r25, 0x06BE	; 0x8006be <pxCurrentTCB+0x1>
	}
    17c0:	08 95       	ret

000017c2 <LCD_SendCommand>:

void LCD_DisplayCustomCharacterRowCol(uint8 location , uint8 row ,uint8 col)
{
    LCD_MoveCursor(row,col);
    LCD_DisplayCharacter(location);
}
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	c8 2f       	mov	r28, r24
    17c8:	40 e0       	ldi	r20, 0x00	; 0
    17ca:	63 e0       	ldi	r22, 0x03	; 3
    17cc:	80 e0       	ldi	r24, 0x00	; 0
    17ce:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    17d2:	8f ec       	ldi	r24, 0xCF	; 207
    17d4:	97 e0       	ldi	r25, 0x07	; 7
    17d6:	01 97       	sbiw	r24, 0x01	; 1
    17d8:	f1 f7       	brne	.-4      	; 0x17d6 <LCD_SendCommand+0x14>
    17da:	00 c0       	rjmp	.+0      	; 0x17dc <LCD_SendCommand+0x1a>
    17dc:	00 00       	nop
    17de:	41 e0       	ldi	r20, 0x01	; 1
    17e0:	62 e0       	ldi	r22, 0x02	; 2
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    17e8:	8f ec       	ldi	r24, 0xCF	; 207
    17ea:	97 e0       	ldi	r25, 0x07	; 7
    17ec:	01 97       	sbiw	r24, 0x01	; 1
    17ee:	f1 f7       	brne	.-4      	; 0x17ec <LCD_SendCommand+0x2a>
    17f0:	00 c0       	rjmp	.+0      	; 0x17f2 <LCD_SendCommand+0x30>
    17f2:	00 00       	nop
    17f4:	dc 2f       	mov	r29, r28
    17f6:	d2 95       	swap	r29
    17f8:	df 70       	andi	r29, 0x0F	; 15
    17fa:	4d 2f       	mov	r20, r29
    17fc:	41 70       	andi	r20, 0x01	; 1
    17fe:	60 e0       	ldi	r22, 0x00	; 0
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1806:	d1 fb       	bst	r29, 1
    1808:	44 27       	eor	r20, r20
    180a:	40 f9       	bld	r20, 0
    180c:	61 e0       	ldi	r22, 0x01	; 1
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1814:	d2 fb       	bst	r29, 2
    1816:	44 27       	eor	r20, r20
    1818:	40 f9       	bld	r20, 0
    181a:	62 e0       	ldi	r22, 0x02	; 2
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1822:	4c 2f       	mov	r20, r28
    1824:	44 1f       	adc	r20, r20
    1826:	44 27       	eor	r20, r20
    1828:	44 1f       	adc	r20, r20
    182a:	64 e0       	ldi	r22, 0x04	; 4
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1832:	8f ec       	ldi	r24, 0xCF	; 207
    1834:	97 e0       	ldi	r25, 0x07	; 7
    1836:	01 97       	sbiw	r24, 0x01	; 1
    1838:	f1 f7       	brne	.-4      	; 0x1836 <LCD_SendCommand+0x74>
    183a:	00 c0       	rjmp	.+0      	; 0x183c <LCD_SendCommand+0x7a>
    183c:	00 00       	nop
    183e:	40 e0       	ldi	r20, 0x00	; 0
    1840:	62 e0       	ldi	r22, 0x02	; 2
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1848:	8f ec       	ldi	r24, 0xCF	; 207
    184a:	97 e0       	ldi	r25, 0x07	; 7
    184c:	01 97       	sbiw	r24, 0x01	; 1
    184e:	f1 f7       	brne	.-4      	; 0x184c <LCD_SendCommand+0x8a>
    1850:	00 c0       	rjmp	.+0      	; 0x1852 <LCD_SendCommand+0x90>
    1852:	00 00       	nop
    1854:	41 e0       	ldi	r20, 0x01	; 1
    1856:	62 e0       	ldi	r22, 0x02	; 2
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    185e:	8f ec       	ldi	r24, 0xCF	; 207
    1860:	97 e0       	ldi	r25, 0x07	; 7
    1862:	01 97       	sbiw	r24, 0x01	; 1
    1864:	f1 f7       	brne	.-4      	; 0x1862 <LCD_SendCommand+0xa0>
    1866:	00 c0       	rjmp	.+0      	; 0x1868 <LCD_SendCommand+0xa6>
    1868:	00 00       	nop
    186a:	dc 2f       	mov	r29, r28
    186c:	df 70       	andi	r29, 0x0F	; 15
    186e:	4c 2f       	mov	r20, r28
    1870:	41 70       	andi	r20, 0x01	; 1
    1872:	60 e0       	ldi	r22, 0x00	; 0
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    187a:	d1 fb       	bst	r29, 1
    187c:	44 27       	eor	r20, r20
    187e:	40 f9       	bld	r20, 0
    1880:	61 e0       	ldi	r22, 0x01	; 1
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1888:	d2 fb       	bst	r29, 2
    188a:	44 27       	eor	r20, r20
    188c:	40 f9       	bld	r20, 0
    188e:	62 e0       	ldi	r22, 0x02	; 2
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1896:	4d 2f       	mov	r20, r29
    1898:	46 95       	lsr	r20
    189a:	46 95       	lsr	r20
    189c:	46 95       	lsr	r20
    189e:	64 e0       	ldi	r22, 0x04	; 4
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    18a6:	8f ec       	ldi	r24, 0xCF	; 207
    18a8:	97 e0       	ldi	r25, 0x07	; 7
    18aa:	01 97       	sbiw	r24, 0x01	; 1
    18ac:	f1 f7       	brne	.-4      	; 0x18aa <LCD_SendCommand+0xe8>
    18ae:	00 c0       	rjmp	.+0      	; 0x18b0 <LCD_SendCommand+0xee>
    18b0:	00 00       	nop
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	62 e0       	ldi	r22, 0x02	; 2
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    18bc:	8f ec       	ldi	r24, 0xCF	; 207
    18be:	97 e0       	ldi	r25, 0x07	; 7
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	f1 f7       	brne	.-4      	; 0x18c0 <LCD_SendCommand+0xfe>
    18c4:	00 c0       	rjmp	.+0      	; 0x18c6 <LCD_SendCommand+0x104>
    18c6:	00 00       	nop
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <LCD_init>:
    18ce:	42 e0       	ldi	r20, 0x02	; 2
    18d0:	63 e0       	ldi	r22, 0x03	; 3
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    18d8:	42 e0       	ldi	r20, 0x02	; 2
    18da:	62 e0       	ldi	r22, 0x02	; 2
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    18e2:	42 e0       	ldi	r20, 0x02	; 2
    18e4:	60 e0       	ldi	r22, 0x00	; 0
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    18ec:	42 e0       	ldi	r20, 0x02	; 2
    18ee:	61 e0       	ldi	r22, 0x01	; 1
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    18f6:	42 e0       	ldi	r20, 0x02	; 2
    18f8:	62 e0       	ldi	r22, 0x02	; 2
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    1900:	42 e0       	ldi	r20, 0x02	; 2
    1902:	64 e0       	ldi	r22, 0x04	; 4
    1904:	81 e0       	ldi	r24, 0x01	; 1
    1906:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    190a:	82 e0       	ldi	r24, 0x02	; 2
    190c:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1910:	88 e2       	ldi	r24, 0x28	; 40
    1912:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1916:	8c e0       	ldi	r24, 0x0C	; 12
    1918:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1922:	08 95       	ret

00001924 <LCD_DisplayCharacter>:
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	c8 2f       	mov	r28, r24
    192a:	41 e0       	ldi	r20, 0x01	; 1
    192c:	63 e0       	ldi	r22, 0x03	; 3
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1934:	8f ec       	ldi	r24, 0xCF	; 207
    1936:	97 e0       	ldi	r25, 0x07	; 7
    1938:	01 97       	sbiw	r24, 0x01	; 1
    193a:	f1 f7       	brne	.-4      	; 0x1938 <LCD_DisplayCharacter+0x14>
    193c:	00 c0       	rjmp	.+0      	; 0x193e <LCD_DisplayCharacter+0x1a>
    193e:	00 00       	nop
    1940:	41 e0       	ldi	r20, 0x01	; 1
    1942:	62 e0       	ldi	r22, 0x02	; 2
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    194a:	8f ec       	ldi	r24, 0xCF	; 207
    194c:	97 e0       	ldi	r25, 0x07	; 7
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	f1 f7       	brne	.-4      	; 0x194e <LCD_DisplayCharacter+0x2a>
    1952:	00 c0       	rjmp	.+0      	; 0x1954 <LCD_DisplayCharacter+0x30>
    1954:	00 00       	nop
    1956:	dc 2f       	mov	r29, r28
    1958:	d2 95       	swap	r29
    195a:	df 70       	andi	r29, 0x0F	; 15
    195c:	4d 2f       	mov	r20, r29
    195e:	41 70       	andi	r20, 0x01	; 1
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1968:	d1 fb       	bst	r29, 1
    196a:	44 27       	eor	r20, r20
    196c:	40 f9       	bld	r20, 0
    196e:	61 e0       	ldi	r22, 0x01	; 1
    1970:	81 e0       	ldi	r24, 0x01	; 1
    1972:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1976:	d2 fb       	bst	r29, 2
    1978:	44 27       	eor	r20, r20
    197a:	40 f9       	bld	r20, 0
    197c:	62 e0       	ldi	r22, 0x02	; 2
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1984:	4c 2f       	mov	r20, r28
    1986:	44 1f       	adc	r20, r20
    1988:	44 27       	eor	r20, r20
    198a:	44 1f       	adc	r20, r20
    198c:	64 e0       	ldi	r22, 0x04	; 4
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1994:	8f ec       	ldi	r24, 0xCF	; 207
    1996:	97 e0       	ldi	r25, 0x07	; 7
    1998:	01 97       	sbiw	r24, 0x01	; 1
    199a:	f1 f7       	brne	.-4      	; 0x1998 <LCD_DisplayCharacter+0x74>
    199c:	00 c0       	rjmp	.+0      	; 0x199e <LCD_DisplayCharacter+0x7a>
    199e:	00 00       	nop
    19a0:	40 e0       	ldi	r20, 0x00	; 0
    19a2:	62 e0       	ldi	r22, 0x02	; 2
    19a4:	80 e0       	ldi	r24, 0x00	; 0
    19a6:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    19aa:	8f ec       	ldi	r24, 0xCF	; 207
    19ac:	97 e0       	ldi	r25, 0x07	; 7
    19ae:	01 97       	sbiw	r24, 0x01	; 1
    19b0:	f1 f7       	brne	.-4      	; 0x19ae <LCD_DisplayCharacter+0x8a>
    19b2:	00 c0       	rjmp	.+0      	; 0x19b4 <LCD_DisplayCharacter+0x90>
    19b4:	00 00       	nop
    19b6:	41 e0       	ldi	r20, 0x01	; 1
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    19c0:	8f ec       	ldi	r24, 0xCF	; 207
    19c2:	97 e0       	ldi	r25, 0x07	; 7
    19c4:	01 97       	sbiw	r24, 0x01	; 1
    19c6:	f1 f7       	brne	.-4      	; 0x19c4 <LCD_DisplayCharacter+0xa0>
    19c8:	00 c0       	rjmp	.+0      	; 0x19ca <LCD_DisplayCharacter+0xa6>
    19ca:	00 00       	nop
    19cc:	dc 2f       	mov	r29, r28
    19ce:	df 70       	andi	r29, 0x0F	; 15
    19d0:	4c 2f       	mov	r20, r28
    19d2:	41 70       	andi	r20, 0x01	; 1
    19d4:	60 e0       	ldi	r22, 0x00	; 0
    19d6:	81 e0       	ldi	r24, 0x01	; 1
    19d8:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    19dc:	d1 fb       	bst	r29, 1
    19de:	44 27       	eor	r20, r20
    19e0:	40 f9       	bld	r20, 0
    19e2:	61 e0       	ldi	r22, 0x01	; 1
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    19ea:	d2 fb       	bst	r29, 2
    19ec:	44 27       	eor	r20, r20
    19ee:	40 f9       	bld	r20, 0
    19f0:	62 e0       	ldi	r22, 0x02	; 2
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    19f8:	4d 2f       	mov	r20, r29
    19fa:	46 95       	lsr	r20
    19fc:	46 95       	lsr	r20
    19fe:	46 95       	lsr	r20
    1a00:	64 e0       	ldi	r22, 0x04	; 4
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1a08:	8f ec       	ldi	r24, 0xCF	; 207
    1a0a:	97 e0       	ldi	r25, 0x07	; 7
    1a0c:	01 97       	sbiw	r24, 0x01	; 1
    1a0e:	f1 f7       	brne	.-4      	; 0x1a0c <LCD_DisplayCharacter+0xe8>
    1a10:	00 c0       	rjmp	.+0      	; 0x1a12 <LCD_DisplayCharacter+0xee>
    1a12:	00 00       	nop
    1a14:	40 e0       	ldi	r20, 0x00	; 0
    1a16:	62 e0       	ldi	r22, 0x02	; 2
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1a1e:	8f ec       	ldi	r24, 0xCF	; 207
    1a20:	97 e0       	ldi	r25, 0x07	; 7
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	f1 f7       	brne	.-4      	; 0x1a22 <LCD_DisplayCharacter+0xfe>
    1a26:	00 c0       	rjmp	.+0      	; 0x1a28 <LCD_DisplayCharacter+0x104>
    1a28:	00 00       	nop
    1a2a:	80 91 bf 06 	lds	r24, 0x06BF	; 0x8006bf <col_global>
    1a2e:	8f 5f       	subi	r24, 0xFF	; 255
    1a30:	80 93 bf 06 	sts	0x06BF, r24	; 0x8006bf <col_global>
    1a34:	84 31       	cpi	r24, 0x14	; 20
    1a36:	59 f4       	brne	.+22     	; 0x1a4e <LCD_DisplayCharacter+0x12a>
    1a38:	80 91 c0 06 	lds	r24, 0x06C0	; 0x8006c0 <row_global>
    1a3c:	8f 5f       	subi	r24, 0xFF	; 255
    1a3e:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <row_global>
    1a42:	10 92 bf 06 	sts	0x06BF, r1	; 0x8006bf <col_global>
    1a46:	84 31       	cpi	r24, 0x14	; 20
    1a48:	11 f4       	brne	.+4      	; 0x1a4e <LCD_DisplayCharacter+0x12a>
    1a4a:	10 92 c0 06 	sts	0x06C0, r1	; 0x8006c0 <row_global>
    1a4e:	df 91       	pop	r29
    1a50:	cf 91       	pop	r28
    1a52:	08 95       	ret

00001a54 <LCD_DisplayString>:
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	8c 01       	movw	r16, r24
    1a5c:	c0 e0       	ldi	r28, 0x00	; 0
    1a5e:	03 c0       	rjmp	.+6      	; 0x1a66 <LCD_DisplayString+0x12>
    1a60:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    1a64:	cf 5f       	subi	r28, 0xFF	; 255
    1a66:	f8 01       	movw	r30, r16
    1a68:	ec 0f       	add	r30, r28
    1a6a:	f1 1d       	adc	r31, r1
    1a6c:	80 81       	ld	r24, Z
    1a6e:	81 11       	cpse	r24, r1
    1a70:	f7 cf       	rjmp	.-18     	; 0x1a60 <LCD_DisplayString+0xc>
    1a72:	cf 91       	pop	r28
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	08 95       	ret

00001a7a <LCD_MoveCursor>:
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	61 f0       	breq	.+24     	; 0x1a96 <LCD_MoveCursor+0x1c>
    1a7e:	28 f0       	brcs	.+10     	; 0x1a8a <LCD_MoveCursor+0x10>
    1a80:	82 30       	cpi	r24, 0x02	; 2
    1a82:	89 f0       	breq	.+34     	; 0x1aa6 <LCD_MoveCursor+0x2c>
    1a84:	83 30       	cpi	r24, 0x03	; 3
    1a86:	b9 f0       	breq	.+46     	; 0x1ab6 <LCD_MoveCursor+0x3c>
    1a88:	1d c0       	rjmp	.+58     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1a8a:	60 93 bf 06 	sts	0x06BF, r22	; 0x8006bf <col_global>
    1a8e:	10 92 c0 06 	sts	0x06C0, r1	; 0x8006c0 <row_global>
    1a92:	96 2f       	mov	r25, r22
    1a94:	17 c0       	rjmp	.+46     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1a96:	90 e4       	ldi	r25, 0x40	; 64
    1a98:	96 0f       	add	r25, r22
    1a9a:	60 93 bf 06 	sts	0x06BF, r22	; 0x8006bf <col_global>
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <row_global>
    1aa4:	0f c0       	rjmp	.+30     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1aa6:	94 e1       	ldi	r25, 0x14	; 20
    1aa8:	96 0f       	add	r25, r22
    1aaa:	60 93 bf 06 	sts	0x06BF, r22	; 0x8006bf <col_global>
    1aae:	82 e0       	ldi	r24, 0x02	; 2
    1ab0:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <row_global>
    1ab4:	07 c0       	rjmp	.+14     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1ab6:	94 e5       	ldi	r25, 0x54	; 84
    1ab8:	96 0f       	add	r25, r22
    1aba:	60 93 bf 06 	sts	0x06BF, r22	; 0x8006bf <col_global>
    1abe:	83 e0       	ldi	r24, 0x03	; 3
    1ac0:	80 93 c0 06 	sts	0x06C0, r24	; 0x8006c0 <row_global>
    1ac4:	89 2f       	mov	r24, r25
    1ac6:	80 68       	ori	r24, 0x80	; 128
    1ac8:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1acc:	08 95       	ret

00001ace <LCD_DisplayStringRowCol>:
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	ec 01       	movw	r28, r24
    1ad4:	86 2f       	mov	r24, r22
    1ad6:	64 2f       	mov	r22, r20
    1ad8:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
    1adc:	ce 01       	movw	r24, r28
    1ade:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <LCD_ClearScreen>:
    1ae8:	10 92 bf 06 	sts	0x06BF, r1	; 0x8006bf <col_global>
    1aec:	10 92 c0 06 	sts	0x06C0, r1	; 0x8006c0 <row_global>
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1af6:	08 95       	ret

00001af8 <LCD_intToString>:




void LCD_intToString(uint32 data)
{
    1af8:	cf 93       	push	r28
    1afa:	df 93       	push	r29
    1afc:	cd b7       	in	r28, 0x3d	; 61
    1afe:	de b7       	in	r29, 0x3e	; 62
    1b00:	61 97       	sbiw	r28, 0x11	; 17
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	de bf       	out	0x3e, r29	; 62
    1b08:	0f be       	out	0x3f, r0	; 63
    1b0a:	cd bf       	out	0x3d, r28	; 61
    1b0c:	dc 01       	movw	r26, r24
    1b0e:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1b10:	4a e0       	ldi	r20, 0x0A	; 10
    1b12:	be 01       	movw	r22, r28
    1b14:	6f 5f       	subi	r22, 0xFF	; 255
    1b16:	7f 4f       	sbci	r23, 0xFF	; 255
    1b18:	0e 94 df 15 	call	0x2bbe	; 0x2bbe <__itoa_ncheck>
	 uint8 string_buff[17];// I write char not sint8_t(signed char ) to avoid warning
	 itoa(data , string_buff , 10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
	 LCD_DisplayString( (uint8_t *)string_buff);
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	01 96       	adiw	r24, 0x01	; 1
    1b20:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
}
    1b24:	61 96       	adiw	r28, 0x11	; 17
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	f8 94       	cli
    1b2a:	de bf       	out	0x3e, r29	; 62
    1b2c:	0f be       	out	0x3f, r0	; 63
    1b2e:	cd bf       	out	0x3d, r28	; 61
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	08 95       	ret

00001b36 <LED_Init>:
#include "LED_interface.h"


void LED_Init(uint8 PORTX , uint8 PIN  )
{
    GPIO_SetPinDirection(PORTX , PIN , OUTPUT_PIN);
    1b36:	42 e0       	ldi	r20, 0x02	; 2
    1b38:	0e 94 63 11 	call	0x22c6	; 0x22c6 <GPIO_SetPinDirection>
    1b3c:	08 95       	ret

00001b3e <LED_OnOffPositiveLogic>:
}

void LED_OnOffPositiveLogic(uint8 PORTX , uint8 PIN ,LEDState_config State_value)
{
    if(State_value == LED_OFF)
    1b3e:	41 11       	cpse	r20, r1
    1b40:	03 c0       	rjmp	.+6      	; 0x1b48 <LED_OnOffPositiveLogic+0xa>
    {
        GPIO_WritePin(PORTX,PIN,LOGIC_LOW);
    1b42:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1b46:	08 95       	ret
    }
    else if(State_value == LED_ON)
    1b48:	41 30       	cpi	r20, 0x01	; 1
    1b4a:	11 f4       	brne	.+4      	; 0x1b50 <LED_OnOffPositiveLogic+0x12>
    {
        GPIO_WritePin(PORTX,PIN,LOGIC_HIGH);
    1b4c:	0e 94 39 12 	call	0x2472	; 0x2472 <GPIO_WritePin>
    1b50:	08 95       	ret

00001b52 <NTC_GetTemperature>:
#include "../../MCAL/ADC/ADC_interface.h"
#include <math.h>


uint8 NTC_GetTemperature(void)
{
    1b52:	8f 92       	push	r8
    1b54:	9f 92       	push	r9
    1b56:	af 92       	push	r10
    1b58:	bf 92       	push	r11
    1b5a:	cf 92       	push	r12
    1b5c:	df 92       	push	r13
    1b5e:	ef 92       	push	r14
    1b60:	ff 92       	push	r15
    uint16 V_out = ADC_ReadChannelSingleConvertion(NTC_PIN);
    1b62:	81 e0       	ldi	r24, 0x01	; 1
    1b64:	0e 94 59 11 	call	0x22b2	; 0x22b2 <ADC_ReadChannelSingleConvertion>
    /*  Apply voltage divider to get Current resistance for NTC     */
    float32 R1 = R2 * ( (ADC_MAX_VALUE / (float32)V_out) - 1.0 ) ;
    1b68:	bc 01       	movw	r22, r24
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	0e 94 56 14 	call	0x28ac	; 0x28ac <__floatunsisf>
    1b72:	9b 01       	movw	r18, r22
    1b74:	ac 01       	movw	r20, r24
    1b76:	60 e0       	ldi	r22, 0x00	; 0
    1b78:	70 ec       	ldi	r23, 0xC0	; 192
    1b7a:	8f e7       	ldi	r24, 0x7F	; 127
    1b7c:	94 e4       	ldi	r25, 0x44	; 68
    1b7e:	0e 94 b5 13 	call	0x276a	; 0x276a <__divsf3>
    1b82:	20 e0       	ldi	r18, 0x00	; 0
    1b84:	30 e0       	ldi	r19, 0x00	; 0
    1b86:	40 e8       	ldi	r20, 0x80	; 128
    1b88:	5f e3       	ldi	r21, 0x3F	; 63
    1b8a:	0e 94 48 13 	call	0x2690	; 0x2690 <__subsf3>
    1b8e:	20 e0       	ldi	r18, 0x00	; 0
    1b90:	30 e4       	ldi	r19, 0x40	; 64
    1b92:	4c e1       	ldi	r20, 0x1C	; 28
    1b94:	56 e4       	ldi	r21, 0x46	; 70
    1b96:	0e 94 34 15 	call	0x2a68	; 0x2a68 <__mulsf3>
    float32 LogR1 = log(R1) ;
    1b9a:	0e 94 ec 14 	call	0x29d8	; 0x29d8 <log>
    1b9e:	6b 01       	movw	r12, r22
    1ba0:	7c 01       	movw	r14, r24
    float32 T = (1.0 / ( C1 + (C2 *LogR1) + (C3 * LogR1 * LogR1 * LogR1) ) ) ;
    1ba2:	26 ed       	ldi	r18, 0xD6	; 214
    1ba4:	34 e6       	ldi	r19, 0x64	; 100
    1ba6:	49 e7       	ldi	r20, 0x79	; 121
    1ba8:	59 e3       	ldi	r21, 0x39	; 57
    1baa:	0e 94 34 15 	call	0x2a68	; 0x2a68 <__mulsf3>
    1bae:	2b ec       	ldi	r18, 0xCB	; 203
    1bb0:	38 e4       	ldi	r19, 0x48	; 72
    1bb2:	44 e8       	ldi	r20, 0x84	; 132
    1bb4:	5a e3       	ldi	r21, 0x3A	; 58
    1bb6:	0e 94 49 13 	call	0x2692	; 0x2692 <__addsf3>
    1bba:	4b 01       	movw	r8, r22
    1bbc:	5c 01       	movw	r10, r24
    1bbe:	2c e6       	ldi	r18, 0x6C	; 108
    1bc0:	3f ec       	ldi	r19, 0xCF	; 207
    1bc2:	48 e5       	ldi	r20, 0x58	; 88
    1bc4:	54 e3       	ldi	r21, 0x34	; 52
    1bc6:	c7 01       	movw	r24, r14
    1bc8:	b6 01       	movw	r22, r12
    1bca:	0e 94 34 15 	call	0x2a68	; 0x2a68 <__mulsf3>
    1bce:	9b 01       	movw	r18, r22
    1bd0:	ac 01       	movw	r20, r24
    1bd2:	c7 01       	movw	r24, r14
    1bd4:	b6 01       	movw	r22, r12
    1bd6:	0e 94 34 15 	call	0x2a68	; 0x2a68 <__mulsf3>
    1bda:	9b 01       	movw	r18, r22
    1bdc:	ac 01       	movw	r20, r24
    1bde:	c7 01       	movw	r24, r14
    1be0:	b6 01       	movw	r22, r12
    1be2:	0e 94 34 15 	call	0x2a68	; 0x2a68 <__mulsf3>
    1be6:	9b 01       	movw	r18, r22
    1be8:	ac 01       	movw	r20, r24
    1bea:	c5 01       	movw	r24, r10
    1bec:	b4 01       	movw	r22, r8
    1bee:	0e 94 49 13 	call	0x2692	; 0x2692 <__addsf3>
    1bf2:	9b 01       	movw	r18, r22
    1bf4:	ac 01       	movw	r20, r24
    1bf6:	60 e0       	ldi	r22, 0x00	; 0
    1bf8:	70 e0       	ldi	r23, 0x00	; 0
    1bfa:	80 e8       	ldi	r24, 0x80	; 128
    1bfc:	9f e3       	ldi	r25, 0x3F	; 63
    1bfe:	0e 94 b5 13 	call	0x276a	; 0x276a <__divsf3>
    T -= 273.15 ;
    1c02:	23 e3       	ldi	r18, 0x33	; 51
    1c04:	33 e9       	ldi	r19, 0x93	; 147
    1c06:	48 e8       	ldi	r20, 0x88	; 136
    1c08:	53 e4       	ldi	r21, 0x43	; 67
    1c0a:	0e 94 48 13 	call	0x2690	; 0x2690 <__subsf3>
    return T ;
    1c0e:	0e 94 27 14 	call	0x284e	; 0x284e <__fixunssfsi>
    1c12:	86 2f       	mov	r24, r22
}
    1c14:	ff 90       	pop	r15
    1c16:	ef 90       	pop	r14
    1c18:	df 90       	pop	r13
    1c1a:	cf 90       	pop	r12
    1c1c:	bf 90       	pop	r11
    1c1e:	af 90       	pop	r10
    1c20:	9f 90       	pop	r9
    1c22:	8f 90       	pop	r8
    1c24:	08 95       	ret

00001c26 <T_T3_Catch_Update_Temp>:
{
	
	while(1)
	{
		/*	Read Current temperature sensor value*/
		Current_Temp = NTC_GetTemperature();
    1c26:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <NTC_GetTemperature>
    1c2a:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <Current_Temp>
		
		/*	Check if current temperature >= Threshold temperature*/
		if(Current_Temp >= thresold_Temp )
    1c2e:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <thresold_Temp>
    1c32:	89 17       	cp	r24, r25
    1c34:	48 f0       	brcs	.+18     	; 0x1c48 <T_T3_Catch_Update_Temp+0x22>
		{
			/*	set event of exceeding temperature	*/
			xEventGroupSetBits(egEvents,ExceedTemperature);
    1c36:	61 e0       	ldi	r22, 0x01	; 1
    1c38:	70 e0       	ldi	r23, 0x00	; 0
    1c3a:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1c3e:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1c42:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
    1c46:	08 c0       	rjmp	.+16     	; 0x1c58 <T_T3_Catch_Update_Temp+0x32>
		}
		else
		{
			/*	Clear event of exceeding temperature	*/
			xEventGroupClearBits(egEvents,ExceedTemperature);
    1c48:	61 e0       	ldi	r22, 0x01	; 1
    1c4a:	70 e0       	ldi	r23, 0x00	; 0
    1c4c:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1c50:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1c54:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>

		}

		/*	take mutex to access LCD shared resource*/
		if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
    1c58:	20 e0       	ldi	r18, 0x00	; 0
    1c5a:	4a e0       	ldi	r20, 0x0A	; 10
    1c5c:	50 e0       	ldi	r21, 0x00	; 0
    1c5e:	60 e0       	ldi	r22, 0x00	; 0
    1c60:	70 e0       	ldi	r23, 0x00	; 0
    1c62:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1c66:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1c6a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1c6e:	81 30       	cpi	r24, 0x01	; 1
    1c70:	19 f5       	brne	.+70     	; 0x1cb8 <T_T3_Catch_Update_Temp+0x92>
		{
			/*	Dispalay value of current Temperature in LCD */
			LCD_MoveCursor(0,10);
    1c72:	6a e0       	ldi	r22, 0x0A	; 10
    1c74:	80 e0       	ldi	r24, 0x00	; 0
    1c76:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
			LCD_intToString(Current_Temp);
    1c7a:	60 91 cd 06 	lds	r22, 0x06CD	; 0x8006cd <Current_Temp>
    1c7e:	70 e0       	ldi	r23, 0x00	; 0
    1c80:	80 e0       	ldi	r24, 0x00	; 0
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
			if(Current_Temp < 100)
    1c88:	80 91 cd 06 	lds	r24, 0x06CD	; 0x8006cd <Current_Temp>
    1c8c:	84 36       	cpi	r24, 0x64	; 100
    1c8e:	20 f4       	brcc	.+8      	; 0x1c98 <T_T3_Catch_Update_Temp+0x72>
			{
				LCD_DisplayString((uint8 *)" ");
    1c90:	87 e5       	ldi	r24, 0x57	; 87
    1c92:	91 e0       	ldi	r25, 0x01	; 1
    1c94:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
			}
			USART_SendStringPolling((uint8 *)"ADC update lcd\r");
    1c98:	84 e7       	ldi	r24, 0x74	; 116
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
			xSemaphoreGive( xMutexLCD );
    1ca0:	20 e0       	ldi	r18, 0x00	; 0
    1ca2:	40 e0       	ldi	r20, 0x00	; 0
    1ca4:	50 e0       	ldi	r21, 0x00	; 0
    1ca6:	60 e0       	ldi	r22, 0x00	; 0
    1ca8:	70 e0       	ldi	r23, 0x00	; 0
    1caa:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1cae:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1cb2:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1cb6:	04 c0       	rjmp	.+8      	; 0x1cc0 <T_T3_Catch_Update_Temp+0x9a>
		}
		/*	Failed to take mutex*/
		else
		{
			/*	tell that failled to update LCD	*/
			USART_SendStringPolling((uint8 *)"ADC Failed update lcd\r");
    1cb8:	84 e8       	ldi	r24, 0x84	; 132
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
		}

		vTaskDelay(500);/*	As I want to take new Temperature Value every half second	*/
    1cc0:	84 ef       	ldi	r24, 0xF4	; 244
    1cc2:	91 e0       	ldi	r25, 0x01	; 1
    1cc4:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskDelay>
	}
    1cc8:	ae cf       	rjmp	.-164    	; 0x1c26 <T_T3_Catch_Update_Temp>

00001cca <T_T4_UART_listen>:

/*	worst case execution time = 8ms	
* Period : 270 ms
*/
void T_T4_UART_listen(void * pvparam)
{
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <T_T4_UART_listen+0x6>
    1cd0:	00 d0       	rcall	.+0      	; 0x1cd2 <T_T4_UART_listen+0x8>
    1cd2:	1f 92       	push	r1
    1cd4:	cd b7       	in	r28, 0x3d	; 61
    1cd6:	de b7       	in	r29, 0x3e	; 62
	
	uint8 u8Ind = 0;
	uint8 txMsg_UART[4] ={};
    1cd8:	19 82       	std	Y+1, r1	; 0x01
    1cda:	1a 82       	std	Y+2, r1	; 0x02
    1cdc:	1b 82       	std	Y+3, r1	; 0x03
    1cde:	1c 82       	std	Y+4, r1	; 0x04
	uint8 u8Data = 0;
    1ce0:	1d 82       	std	Y+5, r1	; 0x05
	boolean update_thresould_temp = FALSE ;
    1ce2:	10 e0       	ldi	r17, 0x00	; 0
* Period : 270 ms
*/
void T_T4_UART_listen(void * pvparam)
{
	
	uint8 u8Ind = 0;
    1ce4:	00 e0       	ldi	r16, 0x00	; 0
    1ce6:	07 c0       	rjmp	.+14     	; 0x1cf6 <T_T4_UART_listen+0x2c>
			
			
			
			if(u8Data == 'G') /*	Will update flag of Threshold Temperature */
			{
				update_thresould_temp = TRUE ;
    1ce8:	11 e0       	ldi	r17, 0x01	; 1
    1cea:	05 c0       	rjmp	.+10     	; 0x1cf6 <T_T4_UART_listen+0x2c>
				update_thresould_temp = FALSE ;
				u8Ind = 0;	
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'C')) /*	Cancel new threshold temperature value*/
			{
				update_thresould_temp = FALSE ;
    1cec:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;
    1cee:	00 e0       	ldi	r16, 0x00	; 0
    1cf0:	02 c0       	rjmp	.+4      	; 0x1cf6 <T_T4_UART_listen+0x2c>
			{
				xQueueSend(MessMailuart_fireState, &u8Data,( TickType_t ) 10);
			}
			else /*	used to clear buffer of threshold temperature if entered any wrong character	*/
			{
				update_thresould_temp = FALSE ;
    1cf2:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;
    1cf4:	00 e0       	ldi	r16, 0x00	; 0
	uint8 txMsg_UART[4] ={};
	uint8 u8Data = 0;
	boolean update_thresould_temp = FALSE ;
	while(1){
		/*	Check if received any new data */
		if(UART_receiveByteUnblocking(&u8Data)){
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	05 96       	adiw	r24, 0x05	; 5
    1cfa:	0e 94 3f 13 	call	0x267e	; 0x267e <UART_receiveByteUnblocking>
    1cfe:	88 23       	and	r24, r24
    1d00:	d1 f3       	breq	.-12     	; 0x1cf6 <T_T4_UART_listen+0x2c>
			
			
			
			if(u8Data == 'G') /*	Will update flag of Threshold Temperature */
    1d02:	8d 81       	ldd	r24, Y+5	; 0x05
    1d04:	87 34       	cpi	r24, 0x47	; 71
    1d06:	81 f3       	breq	.-32     	; 0x1ce8 <T_T4_UART_listen+0x1e>
			{
				update_thresould_temp = TRUE ;
			}
			else if( (update_thresould_temp == TRUE) && ((u8Data >= '0') && (u8Data <= '9')) )
    1d08:	11 30       	cpi	r17, 0x01	; 1
    1d0a:	69 f4       	brne	.+26     	; 0x1d26 <T_T4_UART_listen+0x5c>
    1d0c:	90 ed       	ldi	r25, 0xD0	; 208
    1d0e:	98 0f       	add	r25, r24
    1d10:	9a 30       	cpi	r25, 0x0A	; 10
    1d12:	48 f4       	brcc	.+18     	; 0x1d26 <T_T4_UART_listen+0x5c>
			{
				txMsg_UART[u8Ind] = u8Data;
    1d14:	e1 e0       	ldi	r30, 0x01	; 1
    1d16:	f0 e0       	ldi	r31, 0x00	; 0
    1d18:	ec 0f       	add	r30, r28
    1d1a:	fd 1f       	adc	r31, r29
    1d1c:	e0 0f       	add	r30, r16
    1d1e:	f1 1d       	adc	r31, r1
    1d20:	80 83       	st	Z, r24
				u8Ind++;
    1d22:	0f 5f       	subi	r16, 0xFF	; 255
    1d24:	e8 cf       	rjmp	.-48     	; 0x1cf6 <T_T4_UART_listen+0x2c>
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'K')) /*	Accept new threshold temperature value*/
    1d26:	11 30       	cpi	r17, 0x01	; 1
    1d28:	c1 f4       	brne	.+48     	; 0x1d5a <T_T4_UART_listen+0x90>
    1d2a:	8b 34       	cpi	r24, 0x4B	; 75
    1d2c:	b1 f4       	brne	.+44     	; 0x1d5a <T_T4_UART_listen+0x90>
			{
				txMsg_UART[u8Ind] = 0;
    1d2e:	e1 e0       	ldi	r30, 0x01	; 1
    1d30:	f0 e0       	ldi	r31, 0x00	; 0
    1d32:	ec 0f       	add	r30, r28
    1d34:	fd 1f       	adc	r31, r29
    1d36:	e0 0f       	add	r30, r16
    1d38:	f1 1d       	adc	r31, r1
    1d3a:	10 82       	st	Z, r1
				xQueueSend(MessQUart_Thres_temp, txMsg_UART,( TickType_t ) 10);
    1d3c:	20 e0       	ldi	r18, 0x00	; 0
    1d3e:	4a e0       	ldi	r20, 0x0A	; 10
    1d40:	50 e0       	ldi	r21, 0x00	; 0
    1d42:	be 01       	movw	r22, r28
    1d44:	6f 5f       	subi	r22, 0xFF	; 255
    1d46:	7f 4f       	sbci	r23, 0xFF	; 255
    1d48:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <MessQUart_Thres_temp>
    1d4c:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <MessQUart_Thres_temp+0x1>
    1d50:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
				update_thresould_temp = FALSE ;
    1d54:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;	
    1d56:	00 e0       	ldi	r16, 0x00	; 0
    1d58:	ce cf       	rjmp	.-100    	; 0x1cf6 <T_T4_UART_listen+0x2c>
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'C')) /*	Cancel new threshold temperature value*/
    1d5a:	11 30       	cpi	r17, 0x01	; 1
    1d5c:	11 f4       	brne	.+4      	; 0x1d62 <T_T4_UART_listen+0x98>
    1d5e:	83 34       	cpi	r24, 0x43	; 67
    1d60:	29 f2       	breq	.-118    	; 0x1cec <T_T4_UART_listen+0x22>
			{
				update_thresould_temp = FALSE ;
				u8Ind = 0;
			}
			else if(u8Data == 'T') /*	Will toggle state of Alarm system*/
    1d62:	84 35       	cpi	r24, 0x54	; 84
    1d64:	69 f4       	brne	.+26     	; 0x1d80 <T_T4_UART_listen+0xb6>
			{
				xQueueSend(MessMailuart_fireState, &u8Data, ( TickType_t )10);
    1d66:	20 e0       	ldi	r18, 0x00	; 0
    1d68:	4a e0       	ldi	r20, 0x0A	; 10
    1d6a:	50 e0       	ldi	r21, 0x00	; 0
    1d6c:	be 01       	movw	r22, r28
    1d6e:	6b 5f       	subi	r22, 0xFB	; 251
    1d70:	7f 4f       	sbci	r23, 0xFF	; 255
    1d72:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <MessMailuart_fireState>
    1d76:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <MessMailuart_fireState+0x1>
    1d7a:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1d7e:	bb cf       	rjmp	.-138    	; 0x1cf6 <T_T4_UART_listen+0x2c>
			}
			else if(u8Data == 'D') /*	Will Disbale Alarm system*/
    1d80:	84 34       	cpi	r24, 0x44	; 68
    1d82:	09 f0       	breq	.+2      	; 0x1d86 <T_T4_UART_listen+0xbc>
    1d84:	b6 cf       	rjmp	.-148    	; 0x1cf2 <T_T4_UART_listen+0x28>
			{
				xQueueSend(MessMailuart_fireState, &u8Data,( TickType_t ) 10);
    1d86:	20 e0       	ldi	r18, 0x00	; 0
    1d88:	4a e0       	ldi	r20, 0x0A	; 10
    1d8a:	50 e0       	ldi	r21, 0x00	; 0
    1d8c:	be 01       	movw	r22, r28
    1d8e:	6b 5f       	subi	r22, 0xFB	; 251
    1d90:	7f 4f       	sbci	r23, 0xFF	; 255
    1d92:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <MessMailuart_fireState>
    1d96:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <MessMailuart_fireState+0x1>
    1d9a:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1d9e:	ab cf       	rjmp	.-170    	; 0x1cf6 <T_T4_UART_listen+0x2c>

00001da0 <T_T5_Update_LCD>:

/*	worst case execution time = 100ms	
* Period : 300 ms
*/
void T_T5_Update_LCD(void *pvparam)
{
    1da0:	cf 93       	push	r28
    1da2:	df 93       	push	r29
    1da4:	00 d0       	rcall	.+0      	; 0x1da6 <T_T5_Update_LCD+0x6>
    1da6:	00 d0       	rcall	.+0      	; 0x1da8 <T_T5_Update_LCD+0x8>
    1da8:	1f 92       	push	r1
    1daa:	cd b7       	in	r28, 0x3d	; 61
    1dac:	de b7       	in	r29, 0x3e	; 62
	uint8 rxMsg_thresholdTemp[4] = {};
    1dae:	19 82       	std	Y+1, r1	; 0x01
    1db0:	1a 82       	std	Y+2, r1	; 0x02
    1db2:	1b 82       	std	Y+3, r1	; 0x03
    1db4:	1c 82       	std	Y+4, r1	; 0x04
	uint8 rxmsg_fireState ;
	while(1)
	{
		/*	handle received thresould temperature value and display it */
		if(xQueueReceive(MessQUart_Thres_temp, rxMsg_thresholdTemp, ( TickType_t ) 150))
    1db6:	20 e0       	ldi	r18, 0x00	; 0
    1db8:	46 e9       	ldi	r20, 0x96	; 150
    1dba:	50 e0       	ldi	r21, 0x00	; 0
    1dbc:	be 01       	movw	r22, r28
    1dbe:	6f 5f       	subi	r22, 0xFF	; 255
    1dc0:	7f 4f       	sbci	r23, 0xFF	; 255
    1dc2:	80 91 c7 06 	lds	r24, 0x06C7	; 0x8006c7 <MessQUart_Thres_temp>
    1dc6:	90 91 c8 06 	lds	r25, 0x06C8	; 0x8006c8 <MessQUart_Thres_temp+0x1>
    1dca:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1dce:	88 23       	and	r24, r24
    1dd0:	09 f4       	brne	.+2      	; 0x1dd4 <T_T5_Update_LCD+0x34>
    1dd2:	48 c0       	rjmp	.+144    	; 0x1e64 <T_T5_Update_LCD+0xc4>
		{
			thresold_Temp = rxMsg_thresholdTemp[0] - '0';
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
    1dd6:	80 53       	subi	r24, 0x30	; 48
			thresold_Temp *= 10 ;
    1dd8:	88 0f       	add	r24, r24
    1dda:	98 2f       	mov	r25, r24
    1ddc:	99 0f       	add	r25, r25
    1dde:	99 0f       	add	r25, r25
    1de0:	89 0f       	add	r24, r25
			thresold_Temp += rxMsg_thresholdTemp[1] - '0';
    1de2:	9a 81       	ldd	r25, Y+2	; 0x02
    1de4:	89 0f       	add	r24, r25
    1de6:	80 53       	subi	r24, 0x30	; 48
    1de8:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <thresold_Temp>

			/*	Update Event state if thresold_Temp <= Current_Temp */
			if(thresold_Temp <= Current_Temp)
    1dec:	90 91 cd 06 	lds	r25, 0x06CD	; 0x8006cd <Current_Temp>
    1df0:	98 17       	cp	r25, r24
    1df2:	48 f0       	brcs	.+18     	; 0x1e06 <T_T5_Update_LCD+0x66>
			{
				/*	set event of exceeding temperature	*/
				xEventGroupSetBits(egEvents,ExceedTemperature);
    1df4:	61 e0       	ldi	r22, 0x01	; 1
    1df6:	70 e0       	ldi	r23, 0x00	; 0
    1df8:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1dfc:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1e00:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
    1e04:	08 c0       	rjmp	.+16     	; 0x1e16 <T_T5_Update_LCD+0x76>
			}
			/*	No need to update threshold value	*/
			else
			{
				/*	Clear event of exceeding temperature	*/
				xEventGroupClearBits(egEvents,ExceedTemperature);
    1e06:	61 e0       	ldi	r22, 0x01	; 1
    1e08:	70 e0       	ldi	r23, 0x00	; 0
    1e0a:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1e0e:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1e12:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
			}

			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
    1e16:	20 e0       	ldi	r18, 0x00	; 0
    1e18:	4a e0       	ldi	r20, 0x0A	; 10
    1e1a:	50 e0       	ldi	r21, 0x00	; 0
    1e1c:	60 e0       	ldi	r22, 0x00	; 0
    1e1e:	70 e0       	ldi	r23, 0x00	; 0
    1e20:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1e24:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1e28:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e2c:	81 30       	cpi	r24, 0x01	; 1
    1e2e:	b1 f4       	brne	.+44     	; 0x1e5c <T_T5_Update_LCD+0xbc>
			{
				LCD_DisplayStringRowCol(rxMsg_thresholdTemp,1,16);
    1e30:	40 e1       	ldi	r20, 0x10	; 16
    1e32:	61 e0       	ldi	r22, 0x01	; 1
    1e34:	ce 01       	movw	r24, r28
    1e36:	01 96       	adiw	r24, 0x01	; 1
    1e38:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
				USART_SendStringPolling((uint8 *)"Threshold update lcd\r");
    1e3c:	8b e9       	ldi	r24, 0x9B	; 155
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
				xSemaphoreGive( xMutexLCD );
    1e44:	20 e0       	ldi	r18, 0x00	; 0
    1e46:	40 e0       	ldi	r20, 0x00	; 0
    1e48:	50 e0       	ldi	r21, 0x00	; 0
    1e4a:	60 e0       	ldi	r22, 0x00	; 0
    1e4c:	70 e0       	ldi	r23, 0x00	; 0
    1e4e:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1e52:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1e56:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1e5a:	04 c0       	rjmp	.+8      	; 0x1e64 <T_T5_Update_LCD+0xc4>
			}
			else
			{
				USART_SendStringPolling((uint8 *)"Threshold Failed update lcd\r");
    1e5c:	81 eb       	ldi	r24, 0xB1	; 177
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
		{

		}

		/*	handle state of firing system if it enabled or disabled and update lcd with this change	*/
		if(xQueueReceive(MessMailuart_fireState, &rxmsg_fireState, ( TickType_t ) 150))
    1e64:	20 e0       	ldi	r18, 0x00	; 0
    1e66:	46 e9       	ldi	r20, 0x96	; 150
    1e68:	50 e0       	ldi	r21, 0x00	; 0
    1e6a:	be 01       	movw	r22, r28
    1e6c:	6b 5f       	subi	r22, 0xFB	; 251
    1e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e70:	80 91 c5 06 	lds	r24, 0x06C5	; 0x8006c5 <MessMailuart_fireState>
    1e74:	90 91 c6 06 	lds	r25, 0x06C6	; 0x8006c6 <MessMailuart_fireState+0x1>
    1e78:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e7c:	88 23       	and	r24, r24
    1e7e:	09 f4       	brne	.+2      	; 0x1e82 <T_T5_Update_LCD+0xe2>
    1e80:	9a cf       	rjmp	.-204    	; 0x1db6 <T_T5_Update_LCD+0x16>
		{
			/*	Disable state of fire system */
			if(rxmsg_fireState == 'D')
    1e82:	8d 81       	ldd	r24, Y+5	; 0x05
    1e84:	84 34       	cpi	r24, 0x44	; 68
    1e86:	91 f5       	brne	.+100    	; 0x1eec <T_T5_Update_LCD+0x14c>
			{
				AlarmState = FALSE ;
    1e88:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <AlarmState>
				xEventGroupClearBits(egEvents,SystemFireState);
    1e8c:	62 e0       	ldi	r22, 0x02	; 2
    1e8e:	70 e0       	ldi	r23, 0x00	; 0
    1e90:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1e94:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1e98:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
				if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
    1e9c:	20 e0       	ldi	r18, 0x00	; 0
    1e9e:	4a e0       	ldi	r20, 0x0A	; 10
    1ea0:	50 e0       	ldi	r21, 0x00	; 0
    1ea2:	60 e0       	ldi	r22, 0x00	; 0
    1ea4:	70 e0       	ldi	r23, 0x00	; 0
    1ea6:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1eaa:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1eae:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1eb2:	81 30       	cpi	r24, 0x01	; 1
    1eb4:	b1 f4       	brne	.+44     	; 0x1ee2 <T_T5_Update_LCD+0x142>
				{
					LCD_DisplayStringRowCol((uint8 *)"D",2,13);	
    1eb6:	4d e0       	ldi	r20, 0x0D	; 13
    1eb8:	62 e0       	ldi	r22, 0x02	; 2
    1eba:	8e ec       	ldi	r24, 0xCE	; 206
    1ebc:	90 e0       	ldi	r25, 0x00	; 0
    1ebe:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
					USART_SendStringPolling((uint8 *)"Disable Fire System\r");
    1ec2:	8a ed       	ldi	r24, 0xDA	; 218
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
					xSemaphoreGive( xMutexLCD );
    1eca:	20 e0       	ldi	r18, 0x00	; 0
    1ecc:	40 e0       	ldi	r20, 0x00	; 0
    1ece:	50 e0       	ldi	r21, 0x00	; 0
    1ed0:	60 e0       	ldi	r22, 0x00	; 0
    1ed2:	70 e0       	ldi	r23, 0x00	; 0
    1ed4:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1ed8:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1edc:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1ee0:	6a cf       	rjmp	.-300    	; 0x1db6 <T_T5_Update_LCD+0x16>
				}
				else 
				{
					USART_SendStringPolling((uint8 *)"Failed to Disable Fire System\r");
    1ee2:	80 ed       	ldi	r24, 0xD0	; 208
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
    1eea:	65 cf       	rjmp	.-310    	; 0x1db6 <T_T5_Update_LCD+0x16>
				}
			}
			/*	Toggle state of fire system */
			else if(rxmsg_fireState == 'T')
    1eec:	84 35       	cpi	r24, 0x54	; 84
    1eee:	09 f0       	breq	.+2      	; 0x1ef2 <T_T5_Update_LCD+0x152>
    1ef0:	62 cf       	rjmp	.-316    	; 0x1db6 <T_T5_Update_LCD+0x16>
			{
				
				if(AlarmState == TRUE)
    1ef2:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <AlarmState>
    1ef6:	81 30       	cpi	r24, 0x01	; 1
    1ef8:	91 f5       	brne	.+100    	; 0x1f5e <T_T5_Update_LCD+0x1be>
				{
					AlarmState = FALSE ;
    1efa:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <AlarmState>
					xEventGroupClearBits(egEvents,SystemFireState);
    1efe:	62 e0       	ldi	r22, 0x02	; 2
    1f00:	70 e0       	ldi	r23, 0x00	; 0
    1f02:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1f06:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1f0a:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
					if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
    1f0e:	20 e0       	ldi	r18, 0x00	; 0
    1f10:	4a e0       	ldi	r20, 0x0A	; 10
    1f12:	50 e0       	ldi	r21, 0x00	; 0
    1f14:	60 e0       	ldi	r22, 0x00	; 0
    1f16:	70 e0       	ldi	r23, 0x00	; 0
    1f18:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1f1c:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1f20:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1f24:	81 30       	cpi	r24, 0x01	; 1
    1f26:	b1 f4       	brne	.+44     	; 0x1f54 <T_T5_Update_LCD+0x1b4>
					{
						LCD_DisplayStringRowCol((uint8 *)"D",2,13);	
    1f28:	4d e0       	ldi	r20, 0x0D	; 13
    1f2a:	62 e0       	ldi	r22, 0x02	; 2
    1f2c:	8e ec       	ldi	r24, 0xCE	; 206
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
						USART_SendStringPolling((uint8 *)"Disable Fire System\r");
    1f34:	8a ed       	ldi	r24, 0xDA	; 218
    1f36:	90 e0       	ldi	r25, 0x00	; 0
    1f38:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
						xSemaphoreGive( xMutexLCD );
    1f3c:	20 e0       	ldi	r18, 0x00	; 0
    1f3e:	40 e0       	ldi	r20, 0x00	; 0
    1f40:	50 e0       	ldi	r21, 0x00	; 0
    1f42:	60 e0       	ldi	r22, 0x00	; 0
    1f44:	70 e0       	ldi	r23, 0x00	; 0
    1f46:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1f4a:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1f4e:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1f52:	31 cf       	rjmp	.-414    	; 0x1db6 <T_T5_Update_LCD+0x16>
					}
					else 
					{
						USART_SendStringPolling((uint8 *)"Failed to toggle Fire System state\r");
    1f54:	8f ee       	ldi	r24, 0xEF	; 239
    1f56:	90 e0       	ldi	r25, 0x00	; 0
    1f58:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
    1f5c:	2c cf       	rjmp	.-424    	; 0x1db6 <T_T5_Update_LCD+0x16>
					}
				}
				else if(AlarmState == FALSE)
    1f5e:	81 11       	cpse	r24, r1
    1f60:	2a cf       	rjmp	.-428    	; 0x1db6 <T_T5_Update_LCD+0x16>
				{
					AlarmState = TRUE ;
    1f62:	81 e0       	ldi	r24, 0x01	; 1
    1f64:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <AlarmState>
					xEventGroupSetBits(egEvents,SystemFireState);
    1f68:	62 e0       	ldi	r22, 0x02	; 2
    1f6a:	70 e0       	ldi	r23, 0x00	; 0
    1f6c:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    1f70:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    1f74:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
					if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
    1f78:	20 e0       	ldi	r18, 0x00	; 0
    1f7a:	4a e0       	ldi	r20, 0x0A	; 10
    1f7c:	50 e0       	ldi	r21, 0x00	; 0
    1f7e:	60 e0       	ldi	r22, 0x00	; 0
    1f80:	70 e0       	ldi	r23, 0x00	; 0
    1f82:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1f86:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1f8a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1f8e:	81 30       	cpi	r24, 0x01	; 1
    1f90:	b1 f4       	brne	.+44     	; 0x1fbe <T_T5_Update_LCD+0x21e>
					{
						LCD_DisplayStringRowCol((uint8 *)"E",2,13);	
    1f92:	4d e0       	ldi	r20, 0x0D	; 13
    1f94:	62 e0       	ldi	r22, 0x02	; 2
    1f96:	82 e7       	ldi	r24, 0x72	; 114
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
						USART_SendStringPolling((uint8 *)"enable Fire System\r");
    1f9e:	83 e1       	ldi	r24, 0x13	; 19
    1fa0:	91 e0       	ldi	r25, 0x01	; 1
    1fa2:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
						xSemaphoreGive( xMutexLCD );
    1fa6:	20 e0       	ldi	r18, 0x00	; 0
    1fa8:	40 e0       	ldi	r20, 0x00	; 0
    1faa:	50 e0       	ldi	r21, 0x00	; 0
    1fac:	60 e0       	ldi	r22, 0x00	; 0
    1fae:	70 e0       	ldi	r23, 0x00	; 0
    1fb0:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    1fb4:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    1fb8:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1fbc:	fc ce       	rjmp	.-520    	; 0x1db6 <T_T5_Update_LCD+0x16>
					}
					else 
					{
						USART_SendStringPolling((uint8 *)"Failed to toggle Fire System state\r");
    1fbe:	8f ee       	ldi	r24, 0xEF	; 239
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
    1fc6:	f7 ce       	rjmp	.-530    	; 0x1db6 <T_T5_Update_LCD+0x16>

00001fc8 <System_Init>:
}


void System_Init(void)
{
	LCD_init();
    1fc8:	0e 94 67 0c 	call	0x18ce	; 0x18ce <LCD_init>
	USART_Init();
    1fcc:	0e 94 dd 12 	call	0x25ba	; 0x25ba <USART_Init>
    ADC_Init();
    1fd0:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <ADC_Init>
    LED_Init(PORTC_ID,PIN0_ID);
    1fd4:	60 e0       	ldi	r22, 0x00	; 0
    1fd6:	82 e0       	ldi	r24, 0x02	; 2
    1fd8:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <LED_Init>
    1fdc:	08 95       	ret

00001fde <LCD_MAINInit>:

}

void LCD_MAINInit(void)
{
	LCD_ClearScreen();
    1fde:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_ClearScreen>
	LCD_DisplayStringRowCol((uint8 *)"Cur Temp:    C",0,0);	
    1fe2:	40 e0       	ldi	r20, 0x00	; 0
    1fe4:	60 e0       	ldi	r22, 0x00	; 0
    1fe6:	87 e2       	ldi	r24, 0x27	; 39
    1fe8:	91 e0       	ldi	r25, 0x01	; 1
    1fea:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	/*	Catch value for Temperature and Display it  */
	Current_Temp = NTC_GetTemperature();
    1fee:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <NTC_GetTemperature>
    1ff2:	80 93 cd 06 	sts	0x06CD, r24	; 0x8006cd <Current_Temp>
	LCD_MoveCursor(0,10);
    1ff6:	6a e0       	ldi	r22, 0x0A	; 10
    1ff8:	80 e0       	ldi	r24, 0x00	; 0
    1ffa:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	LCD_intToString(Current_Temp);
    1ffe:	60 91 cd 06 	lds	r22, 0x06CD	; 0x8006cd <Current_Temp>
    2002:	70 e0       	ldi	r23, 0x00	; 0
    2004:	80 e0       	ldi	r24, 0x00	; 0
    2006:	90 e0       	ldi	r25, 0x00	; 0
    2008:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>


	LCD_DisplayStringRowCol((uint8 *)"Threshold Temp:    C",1,0);	
    200c:	40 e0       	ldi	r20, 0x00	; 0
    200e:	61 e0       	ldi	r22, 0x01	; 1
    2010:	86 e3       	ldi	r24, 0x36	; 54
    2012:	91 e0       	ldi	r25, 0x01	; 1
    2014:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	LCD_MoveCursor(1,16);
    2018:	60 e1       	ldi	r22, 0x10	; 16
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	LCD_intToString(thresold_Temp);
    2020:	60 91 63 00 	lds	r22, 0x0063	; 0x800063 <thresold_Temp>
    2024:	70 e0       	ldi	r23, 0x00	; 0
    2026:	80 e0       	ldi	r24, 0x00	; 0
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>


	LCD_DisplayStringRowCol((uint8 *)"Alarm State: ",2,0);	
    202e:	40 e0       	ldi	r20, 0x00	; 0
    2030:	62 e0       	ldi	r22, 0x02	; 2
    2032:	8b e4       	ldi	r24, 0x4B	; 75
    2034:	91 e0       	ldi	r25, 0x01	; 1
    2036:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	LCD_MoveCursor(2,13);
    203a:	6d e0       	ldi	r22, 0x0D	; 13
    203c:	82 e0       	ldi	r24, 0x02	; 2
    203e:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	if(AlarmState == TRUE)
    2042:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <AlarmState>
    2046:	81 30       	cpi	r24, 0x01	; 1
    2048:	21 f4       	brne	.+8      	; 0x2052 <LCD_MAINInit+0x74>
	{
		LCD_DisplayCharacter('E');
    204a:	85 e4       	ldi	r24, 0x45	; 69
    204c:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    2050:	08 95       	ret
	}
	else 
	{
		LCD_DisplayCharacter('D');
    2052:	84 e4       	ldi	r24, 0x44	; 68
    2054:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    2058:	08 95       	ret

0000205a <main>:
EventGroupHandle_t 	egEvents = NULL;
/*	carry value of Eventgroup check	*/
EventBits_t			ebValues = 0;

int main(void)
{
    205a:	af 92       	push	r10
    205c:	bf 92       	push	r11
    205e:	cf 92       	push	r12
    2060:	df 92       	push	r13
    2062:	ef 92       	push	r14
    2064:	ff 92       	push	r15
    2066:	0f 93       	push	r16
	/*	Initialize all MCAl and HAL perephirals	*/
	System_Init();
    2068:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <System_Init>
	/*	display current temperature and threshold temperature and fire system state		*/
	LCD_MAINInit();
    206c:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <LCD_MAINInit>
	/*	create mutex responsible for LCD */
	xMutexLCD = xSemaphoreCreateMutex();
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	0e 94 6e 05 	call	0xadc	; 0xadc <xQueueCreateMutex>
    2076:	90 93 cc 06 	sts	0x06CC, r25	; 0x8006cc <xMutexLCD+0x1>
    207a:	80 93 cb 06 	sts	0x06CB, r24	; 0x8006cb <xMutexLCD>
	/*	create queue responsible for carry threshould temperature	*/
	MessQUart_Thres_temp = xQueueCreate(3,3 * sizeof(uint8) );	
    207e:	40 e0       	ldi	r20, 0x00	; 0
    2080:	63 e0       	ldi	r22, 0x03	; 3
    2082:	83 e0       	ldi	r24, 0x03	; 3
    2084:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericCreate>
    2088:	90 93 c8 06 	sts	0x06C8, r25	; 0x8006c8 <MessQUart_Thres_temp+0x1>
    208c:	80 93 c7 06 	sts	0x06C7, r24	; 0x8006c7 <MessQUart_Thres_temp>
	/*	create queue responsible for carry fire system state	*/
	MessMailuart_fireState = xQueueCreate(3, sizeof(uint8));
    2090:	40 e0       	ldi	r20, 0x00	; 0
    2092:	61 e0       	ldi	r22, 0x01	; 1
    2094:	83 e0       	ldi	r24, 0x03	; 3
    2096:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericCreate>
    209a:	90 93 c6 06 	sts	0x06C6, r25	; 0x8006c6 <MessMailuart_fireState+0x1>
    209e:	80 93 c5 06 	sts	0x06C5, r24	; 0x8006c5 <MessMailuart_fireState>
	/*	create event group responsible for fire alarm of fire sysetm */
	egEvents = xEventGroupCreate();
    20a2:	0e 94 89 00 	call	0x112	; 0x112 <xEventGroupCreate>
    20a6:	90 93 c4 06 	sts	0x06C4, r25	; 0x8006c4 <egEvents+0x1>
    20aa:	80 93 c3 06 	sts	0x06C3, r24	; 0x8006c3 <egEvents>



	xTaskCreate(T_T6_SwitchBetHaz_Nor, "Emergency_normal", 200, NULL, 4, NULL);
    20ae:	a1 2c       	mov	r10, r1
    20b0:	b1 2c       	mov	r11, r1
    20b2:	c1 2c       	mov	r12, r1
    20b4:	d1 2c       	mov	r13, r1
    20b6:	e1 2c       	mov	r14, r1
    20b8:	f1 2c       	mov	r15, r1
    20ba:	04 e0       	ldi	r16, 0x04	; 4
    20bc:	20 e0       	ldi	r18, 0x00	; 0
    20be:	30 e0       	ldi	r19, 0x00	; 0
    20c0:	48 ec       	ldi	r20, 0xC8	; 200
    20c2:	50 e0       	ldi	r21, 0x00	; 0
    20c4:	69 e5       	ldi	r22, 0x59	; 89
    20c6:	71 e0       	ldi	r23, 0x01	; 1
    20c8:	86 ea       	ldi	r24, 0xA6	; 166
    20ca:	90 e1       	ldi	r25, 0x10	; 16
    20cc:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T3_Catch_Update_Temp, "Update Current Temp", 100, &Current_Temp, 2, NULL);
    20d0:	02 e0       	ldi	r16, 0x02	; 2
    20d2:	2d ec       	ldi	r18, 0xCD	; 205
    20d4:	36 e0       	ldi	r19, 0x06	; 6
    20d6:	44 e6       	ldi	r20, 0x64	; 100
    20d8:	50 e0       	ldi	r21, 0x00	; 0
    20da:	6a e6       	ldi	r22, 0x6A	; 106
    20dc:	71 e0       	ldi	r23, 0x01	; 1
    20de:	83 e1       	ldi	r24, 0x13	; 19
    20e0:	9e e0       	ldi	r25, 0x0E	; 14
    20e2:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T5_Update_LCD, "update Threshold_state", 100, NULL, 3, NULL);
    20e6:	03 e0       	ldi	r16, 0x03	; 3
    20e8:	20 e0       	ldi	r18, 0x00	; 0
    20ea:	30 e0       	ldi	r19, 0x00	; 0
    20ec:	44 e6       	ldi	r20, 0x64	; 100
    20ee:	50 e0       	ldi	r21, 0x00	; 0
    20f0:	6e e7       	ldi	r22, 0x7E	; 126
    20f2:	71 e0       	ldi	r23, 0x01	; 1
    20f4:	80 ed       	ldi	r24, 0xD0	; 208
    20f6:	9e e0       	ldi	r25, 0x0E	; 14
    20f8:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T4_UART_listen, "Recieve UART Mess", 100, NULL, 1, NULL);
    20fc:	01 e0       	ldi	r16, 0x01	; 1
    20fe:	20 e0       	ldi	r18, 0x00	; 0
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	44 e6       	ldi	r20, 0x64	; 100
    2104:	50 e0       	ldi	r21, 0x00	; 0
    2106:	65 e9       	ldi	r22, 0x95	; 149
    2108:	71 e0       	ldi	r23, 0x01	; 1
    210a:	85 e6       	ldi	r24, 0x65	; 101
    210c:	9e e0       	ldi	r25, 0x0E	; 14
    210e:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>

	xEventGroupSetBits(egEvents,SystemFireState); // As I by defualt make system Fire Enable
    2112:	62 e0       	ldi	r22, 0x02	; 2
    2114:	70 e0       	ldi	r23, 0x00	; 0
    2116:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    211a:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    211e:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>

	vTaskStartScheduler();
    2122:	0e 94 ff 07 	call	0xffe	; 0xffe <vTaskStartScheduler>

	return 0 ;
}
    2126:	80 e0       	ldi	r24, 0x00	; 0
    2128:	90 e0       	ldi	r25, 0x00	; 0
    212a:	0f 91       	pop	r16
    212c:	ff 90       	pop	r15
    212e:	ef 90       	pop	r14
    2130:	df 90       	pop	r13
    2132:	cf 90       	pop	r12
    2134:	bf 90       	pop	r11
    2136:	af 90       	pop	r10
    2138:	08 95       	ret

0000213a <F_fireStateScreen>:
}


void F_fireStateScreen(void)
{
	LCD_ClearScreen();
    213a:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_ClearScreen>
	LCD_DisplayStringRowCol((uint8 *)"!! ALARM !!", 1 , 4);
    213e:	44 e0       	ldi	r20, 0x04	; 4
    2140:	61 e0       	ldi	r22, 0x01	; 1
    2142:	87 ea       	ldi	r24, 0xA7	; 167
    2144:	91 e0       	ldi	r25, 0x01	; 1
    2146:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
    214a:	08 95       	ret

0000214c <T_T6_SwitchBetHaz_Nor>:
* worst case execution time = 700ms	
* Period : 500 ms
*/
void T_T6_SwitchBetHaz_Nor(void *pvparam)
{
	boolean Mutex_Taken_Already = FALSE ;
    214c:	c0 e0       	ldi	r28, 0x00	; 0
	while (1)
	{
		ebValues = xEventGroupWaitBits(egEvents,
    214e:	04 ef       	ldi	r16, 0xF4	; 244
    2150:	11 e0       	ldi	r17, 0x01	; 1
    2152:	21 e0       	ldi	r18, 0x01	; 1
    2154:	40 e0       	ldi	r20, 0x00	; 0
    2156:	63 e0       	ldi	r22, 0x03	; 3
    2158:	70 e0       	ldi	r23, 0x00	; 0
    215a:	80 91 c3 06 	lds	r24, 0x06C3	; 0x8006c3 <egEvents>
    215e:	90 91 c4 06 	lds	r25, 0x06C4	; 0x8006c4 <egEvents+0x1>
    2162:	0e 94 9c 00 	call	0x138	; 0x138 <xEventGroupWaitBits>
    2166:	90 93 c2 06 	sts	0x06C2, r25	; 0x8006c2 <ebValues+0x1>
    216a:	80 93 c1 06 	sts	0x06C1, r24	; 0x8006c1 <ebValues>
										(SystemFireState | ExceedTemperature),
										0,
										1,//AND
										( TickType_t )500);

		if( ( ebValues & (SystemFireState | ExceedTemperature) )== (SystemFireState | ExceedTemperature) )
    216e:	83 70       	andi	r24, 0x03	; 3
    2170:	99 27       	eor	r25, r25
    2172:	03 97       	sbiw	r24, 0x03	; 3
    2174:	d1 f4       	brne	.+52     	; 0x21aa <T_T6_SwitchBetHaz_Nor+0x5e>
		{
			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
    2176:	20 e0       	ldi	r18, 0x00	; 0
    2178:	4a e0       	ldi	r20, 0x0A	; 10
    217a:	50 e0       	ldi	r21, 0x00	; 0
    217c:	60 e0       	ldi	r22, 0x00	; 0
    217e:	70 e0       	ldi	r23, 0x00	; 0
    2180:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    2184:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    2188:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    218c:	81 30       	cpi	r24, 0x01	; 1
    218e:	f9 f6       	brne	.-66     	; 0x214e <T_T6_SwitchBetHaz_Nor+0x2>
			{
				Mutex_Taken_Already = TRUE ;
				LED_OnOffPositiveLogic(PORTC_ID,PIN0_ID,LED_ON);
    2190:	41 e0       	ldi	r20, 0x01	; 1
    2192:	60 e0       	ldi	r22, 0x00	; 0
    2194:	82 e0       	ldi	r24, 0x02	; 2
    2196:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <LED_OnOffPositiveLogic>
				USART_SendStringPolling((uint8 *)"Fire !!!!!!!!!!!!!!!\r");
    219a:	83 eb       	ldi	r24, 0xB3	; 179
    219c:	91 e0       	ldi	r25, 0x01	; 1
    219e:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>
				F_fireStateScreen();
    21a2:	0e 94 9d 10 	call	0x213a	; 0x213a <F_fireStateScreen>

		if( ( ebValues & (SystemFireState | ExceedTemperature) )== (SystemFireState | ExceedTemperature) )
		{
			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 10 ) == pdTRUE )
			{
				Mutex_Taken_Already = TRUE ;
    21a6:	c1 e0       	ldi	r28, 0x01	; 1
    21a8:	d2 cf       	rjmp	.-92     	; 0x214e <T_T6_SwitchBetHaz_Nor+0x2>
			}
			
		}
		else
		{
			if(Mutex_Taken_Already == TRUE)
    21aa:	c1 30       	cpi	r28, 0x01	; 1
    21ac:	81 f6       	brne	.-96     	; 0x214e <T_T6_SwitchBetHaz_Nor+0x2>
			{
				Mutex_Taken_Already = FALSE ;
				LED_OnOffPositiveLogic(PORTC_ID,PIN0_ID,LED_OFF);
    21ae:	40 e0       	ldi	r20, 0x00	; 0
    21b0:	60 e0       	ldi	r22, 0x00	; 0
    21b2:	82 e0       	ldi	r24, 0x02	; 2
    21b4:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <LED_OnOffPositiveLogic>
				/*	Should be here to avoid continous update LCD without go from Fire state to normal state*/
				LCD_MAINInit();	
    21b8:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <LCD_MAINInit>
				USART_SendStringPolling((uint8 *)"No Fire\r");
    21bc:	89 ec       	ldi	r24, 0xC9	; 201
    21be:	91 e0       	ldi	r25, 0x01	; 1
    21c0:	0e 94 2b 13 	call	0x2656	; 0x2656 <USART_SendStringPolling>

				xSemaphoreGive( xMutexLCD );
    21c4:	20 e0       	ldi	r18, 0x00	; 0
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	60 e0       	ldi	r22, 0x00	; 0
    21cc:	70 e0       	ldi	r23, 0x00	; 0
    21ce:	80 91 cb 06 	lds	r24, 0x06CB	; 0x8006cb <xMutexLCD>
    21d2:	90 91 cc 06 	lds	r25, 0x06CC	; 0x8006cc <xMutexLCD+0x1>
    21d6:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
		}
		else
		{
			if(Mutex_Taken_Already == TRUE)
			{
				Mutex_Taken_Already = FALSE ;
    21da:	c0 e0       	ldi	r28, 0x00	; 0
    21dc:	b8 cf       	rjmp	.-144    	; 0x214e <T_T6_SwitchBetHaz_Nor+0x2>

000021de <ADC_OnlyStartConversionGeneral>:
    return ADC_conversion_value;
}

void ADC_FreeRunningStart (uint8 Channel_NUM)
{
    ADC_OnlyStartConversionGeneral(Channel_NUM);
    21de:	87 70       	andi	r24, 0x07	; 7
    21e0:	97 b1       	in	r25, 0x07	; 7
    21e2:	90 7e       	andi	r25, 0xE0	; 224
    21e4:	89 2b       	or	r24, r25
    21e6:	87 b9       	out	0x07, r24	; 7
    21e8:	86 b1       	in	r24, 0x06	; 6
    21ea:	80 64       	ori	r24, 0x40	; 64
    21ec:	86 b9       	out	0x06, r24	; 6
    21ee:	08 95       	ret

000021f0 <ADC_Init>:
    21f0:	27 b1       	in	r18, 0x07	; 7
    21f2:	e4 e6       	ldi	r30, 0x64	; 100
    21f4:	f0 e0       	ldi	r31, 0x00	; 0
    21f6:	91 81       	ldd	r25, Z+1	; 0x01
    21f8:	30 e4       	ldi	r19, 0x40	; 64
    21fa:	93 9f       	mul	r25, r19
    21fc:	c0 01       	movw	r24, r0
    21fe:	11 24       	eor	r1, r1
    2200:	92 2f       	mov	r25, r18
    2202:	9f 73       	andi	r25, 0x3F	; 63
    2204:	89 2b       	or	r24, r25
    2206:	87 b9       	out	0x07, r24	; 7
    2208:	82 81       	ldd	r24, Z+2	; 0x02
    220a:	81 11       	cpse	r24, r1
    220c:	04 c0       	rjmp	.+8      	; 0x2216 <ADC_Init+0x26>
    220e:	87 b1       	in	r24, 0x07	; 7
    2210:	8f 7d       	andi	r24, 0xDF	; 223
    2212:	87 b9       	out	0x07, r24	; 7
    2214:	05 c0       	rjmp	.+10     	; 0x2220 <ADC_Init+0x30>
    2216:	81 30       	cpi	r24, 0x01	; 1
    2218:	19 f4       	brne	.+6      	; 0x2220 <ADC_Init+0x30>
    221a:	87 b1       	in	r24, 0x07	; 7
    221c:	80 62       	ori	r24, 0x20	; 32
    221e:	87 b9       	out	0x07, r24	; 7
    2220:	86 b1       	in	r24, 0x06	; 6
    2222:	80 68       	ori	r24, 0x80	; 128
    2224:	86 b9       	out	0x06, r24	; 6
    2226:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <ADC_ConfigTypeParam>
    222a:	88 23       	and	r24, r24
    222c:	c9 f0       	breq	.+50     	; 0x2260 <ADC_Init+0x70>
    222e:	81 30       	cpi	r24, 0x01	; 1
    2230:	39 f4       	brne	.+14     	; 0x2240 <ADC_Init+0x50>
    2232:	86 b1       	in	r24, 0x06	; 6
    2234:	80 62       	ori	r24, 0x20	; 32
    2236:	86 b9       	out	0x06, r24	; 6
    2238:	80 b7       	in	r24, 0x30	; 48
    223a:	8f 70       	andi	r24, 0x0F	; 15
    223c:	80 bf       	out	0x30, r24	; 48
    223e:	10 c0       	rjmp	.+32     	; 0x2260 <ADC_Init+0x70>
    2240:	82 30       	cpi	r24, 0x02	; 2
    2242:	71 f4       	brne	.+28     	; 0x2260 <ADC_Init+0x70>
    2244:	86 b1       	in	r24, 0x06	; 6
    2246:	80 62       	ori	r24, 0x20	; 32
    2248:	86 b9       	out	0x06, r24	; 6
    224a:	20 b7       	in	r18, 0x30	; 48
    224c:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <ADC_ConfigTypeParam+0x4>
    2250:	30 e2       	ldi	r19, 0x20	; 32
    2252:	93 9f       	mul	r25, r19
    2254:	c0 01       	movw	r24, r0
    2256:	11 24       	eor	r1, r1
    2258:	92 2f       	mov	r25, r18
    225a:	9f 70       	andi	r25, 0x0F	; 15
    225c:	89 2b       	or	r24, r25
    225e:	80 bf       	out	0x30, r24	; 48
    2260:	96 b1       	in	r25, 0x06	; 6
    2262:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <ADC_ConfigTypeParam+0x3>
    2266:	98 7f       	andi	r25, 0xF8	; 248
    2268:	87 70       	andi	r24, 0x07	; 7
    226a:	89 2b       	or	r24, r25
    226c:	86 b9       	out	0x06, r24	; 6
    226e:	86 b1       	in	r24, 0x06	; 6
    2270:	87 7f       	andi	r24, 0xF7	; 247
    2272:	86 b9       	out	0x06, r24	; 6
    2274:	08 95       	ret

00002276 <ADC_ReadConversionRegister>:

uint16 ADC_ReadConversionRegister(void)
{   
    /* NOTE if I use #define ADC (* (volatile uint16 *) (0x24) )  will reduce all below steps */
    uint16 RegisterValue = 0 ;
    if(ADC_ConfigTypeParam.ADC_ValueAdjustment_value == ADC_Adjust_Right)
    2276:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <ADC_ConfigTypeParam+0x2>
    227a:	81 11       	cpse	r24, r1
    227c:	08 c0       	rjmp	.+16     	; 0x228e <ADC_ReadConversionRegister+0x18>
    {
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ADCL;
    227e:	24 b1       	in	r18, 0x04	; 4
        RegisterValue = (( (uint16)(ADCH & 0x03) ) << 8) | RegisterValue ;
    2280:	85 b1       	in	r24, 0x05	; 5
    2282:	83 70       	andi	r24, 0x03	; 3
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	98 2f       	mov	r25, r24
    2288:	88 27       	eor	r24, r24
    228a:	82 2b       	or	r24, r18
    228c:	08 95       	ret
    }
    else if(ADC_ConfigTypeParam.ADC_ValueAdjustment_value == ADC_Adjust_Left)
    228e:	81 30       	cpi	r24, 0x01	; 1
    2290:	69 f4       	brne	.+26     	; 0x22ac <ADC_ReadConversionRegister+0x36>
    {
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ((ADCL & 0xC0) ) >> 6 ;
    2292:	24 b1       	in	r18, 0x04	; 4
    2294:	22 95       	swap	r18
    2296:	26 95       	lsr	r18
    2298:	26 95       	lsr	r18
    229a:	23 70       	andi	r18, 0x03	; 3
        RegisterValue = (( (uint16)ADCH ) << 2) | RegisterValue ;
    229c:	85 b1       	in	r24, 0x05	; 5
    229e:	90 e0       	ldi	r25, 0x00	; 0
    22a0:	88 0f       	add	r24, r24
    22a2:	99 1f       	adc	r25, r25
    22a4:	88 0f       	add	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	82 2b       	or	r24, r18
    22aa:	08 95       	ret
}

uint16 ADC_ReadConversionRegister(void)
{   
    /* NOTE if I use #define ADC (* (volatile uint16 *) (0x24) )  will reduce all below steps */
    uint16 RegisterValue = 0 ;
    22ac:	80 e0       	ldi	r24, 0x00	; 0
    22ae:	90 e0       	ldi	r25, 0x00	; 0
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ((ADCL & 0xC0) ) >> 6 ;
        RegisterValue = (( (uint16)ADCH ) << 2) | RegisterValue ;
    }
    return RegisterValue ;
}
    22b0:	08 95       	ret

000022b2 <ADC_ReadChannelSingleConvertion>:


uint16 ADC_ReadChannelSingleConvertion(uint8 Channel_NUM)
{
    uint16 ADC_conversion_value = 0 ;
    ADC_OnlyStartConversionGeneral(Channel_NUM);
    22b2:	0e 94 ef 10 	call	0x21de	; 0x21de <ADC_OnlyStartConversionGeneral>
    /*  wait uintil ADIF (conversion flag) in ADCSRA register convert from Low to High As that mean conversion completed  */
    while (BIT_IS_CLEAR(ADCSRA,ADIF));
    22b6:	34 9b       	sbis	0x06, 4	; 6
    22b8:	fe cf       	rjmp	.-4      	; 0x22b6 <ADC_ReadChannelSingleConvertion+0x4>
    ADC_conversion_value = ADC_ReadConversionRegister();
    22ba:	0e 94 3b 11 	call	0x2276	; 0x2276 <ADC_ReadConversionRegister>
    /*  Clear ADIF (conversion flag) in ADCSRA register by write one when use Polling Technique     */
    SET_BIT(ADCSRA,ADIF);
    22be:	26 b1       	in	r18, 0x06	; 6
    22c0:	20 61       	ori	r18, 0x10	; 16
    22c2:	26 b9       	out	0x06, r18	; 6
    return ADC_conversion_value;
}
    22c4:	08 95       	ret

000022c6 <GPIO_SetPinDirection>:

        }
    }

    return returned_value ;
}
    22c6:	84 30       	cpi	r24, 0x04	; 4
    22c8:	08 f0       	brcs	.+2      	; 0x22cc <GPIO_SetPinDirection+0x6>
    22ca:	d2 c0       	rjmp	.+420    	; 0x2470 <GPIO_SetPinDirection+0x1aa>
    22cc:	68 30       	cpi	r22, 0x08	; 8
    22ce:	08 f0       	brcs	.+2      	; 0x22d2 <GPIO_SetPinDirection+0xc>
    22d0:	cf c0       	rjmp	.+414    	; 0x2470 <GPIO_SetPinDirection+0x1aa>
    22d2:	81 30       	cpi	r24, 0x01	; 1
    22d4:	d1 f1       	breq	.+116    	; 0x234a <GPIO_SetPinDirection+0x84>
    22d6:	38 f0       	brcs	.+14     	; 0x22e6 <GPIO_SetPinDirection+0x20>
    22d8:	82 30       	cpi	r24, 0x02	; 2
    22da:	09 f4       	brne	.+2      	; 0x22de <GPIO_SetPinDirection+0x18>
    22dc:	68 c0       	rjmp	.+208    	; 0x23ae <GPIO_SetPinDirection+0xe8>
    22de:	83 30       	cpi	r24, 0x03	; 3
    22e0:	09 f4       	brne	.+2      	; 0x22e4 <GPIO_SetPinDirection+0x1e>
    22e2:	96 c0       	rjmp	.+300    	; 0x2410 <GPIO_SetPinDirection+0x14a>
    22e4:	08 95       	ret
    22e6:	41 11       	cpse	r20, r1
    22e8:	10 c0       	rjmp	.+32     	; 0x230a <GPIO_SetPinDirection+0x44>
    22ea:	2a b3       	in	r18, 0x1a	; 26
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	90 e0       	ldi	r25, 0x00	; 0
    22f0:	02 c0       	rjmp	.+4      	; 0x22f6 <GPIO_SetPinDirection+0x30>
    22f2:	88 0f       	add	r24, r24
    22f4:	99 1f       	adc	r25, r25
    22f6:	6a 95       	dec	r22
    22f8:	e2 f7       	brpl	.-8      	; 0x22f2 <GPIO_SetPinDirection+0x2c>
    22fa:	80 95       	com	r24
    22fc:	92 2f       	mov	r25, r18
    22fe:	98 23       	and	r25, r24
    2300:	9a bb       	out	0x1a, r25	; 26
    2302:	9b b3       	in	r25, 0x1b	; 27
    2304:	89 23       	and	r24, r25
    2306:	8b bb       	out	0x1b, r24	; 27
    2308:	08 95       	ret
    230a:	41 30       	cpi	r20, 0x01	; 1
    230c:	81 f4       	brne	.+32     	; 0x232e <GPIO_SetPinDirection+0x68>
    230e:	2a b3       	in	r18, 0x1a	; 26
    2310:	81 e0       	ldi	r24, 0x01	; 1
    2312:	90 e0       	ldi	r25, 0x00	; 0
    2314:	02 c0       	rjmp	.+4      	; 0x231a <GPIO_SetPinDirection+0x54>
    2316:	88 0f       	add	r24, r24
    2318:	99 1f       	adc	r25, r25
    231a:	6a 95       	dec	r22
    231c:	e2 f7       	brpl	.-8      	; 0x2316 <GPIO_SetPinDirection+0x50>
    231e:	98 2f       	mov	r25, r24
    2320:	90 95       	com	r25
    2322:	92 23       	and	r25, r18
    2324:	9a bb       	out	0x1a, r25	; 26
    2326:	9b b3       	in	r25, 0x1b	; 27
    2328:	89 2b       	or	r24, r25
    232a:	8b bb       	out	0x1b, r24	; 27
    232c:	08 95       	ret
    232e:	42 30       	cpi	r20, 0x02	; 2
    2330:	09 f0       	breq	.+2      	; 0x2334 <GPIO_SetPinDirection+0x6e>
    2332:	9e c0       	rjmp	.+316    	; 0x2470 <GPIO_SetPinDirection+0x1aa>
    2334:	2a b3       	in	r18, 0x1a	; 26
    2336:	81 e0       	ldi	r24, 0x01	; 1
    2338:	90 e0       	ldi	r25, 0x00	; 0
    233a:	02 c0       	rjmp	.+4      	; 0x2340 <GPIO_SetPinDirection+0x7a>
    233c:	88 0f       	add	r24, r24
    233e:	99 1f       	adc	r25, r25
    2340:	6a 95       	dec	r22
    2342:	e2 f7       	brpl	.-8      	; 0x233c <GPIO_SetPinDirection+0x76>
    2344:	82 2b       	or	r24, r18
    2346:	8a bb       	out	0x1a, r24	; 26
    2348:	08 95       	ret
    234a:	41 11       	cpse	r20, r1
    234c:	10 c0       	rjmp	.+32     	; 0x236e <GPIO_SetPinDirection+0xa8>
    234e:	27 b3       	in	r18, 0x17	; 23
    2350:	81 e0       	ldi	r24, 0x01	; 1
    2352:	90 e0       	ldi	r25, 0x00	; 0
    2354:	02 c0       	rjmp	.+4      	; 0x235a <GPIO_SetPinDirection+0x94>
    2356:	88 0f       	add	r24, r24
    2358:	99 1f       	adc	r25, r25
    235a:	6a 95       	dec	r22
    235c:	e2 f7       	brpl	.-8      	; 0x2356 <GPIO_SetPinDirection+0x90>
    235e:	80 95       	com	r24
    2360:	92 2f       	mov	r25, r18
    2362:	98 23       	and	r25, r24
    2364:	97 bb       	out	0x17, r25	; 23
    2366:	98 b3       	in	r25, 0x18	; 24
    2368:	89 23       	and	r24, r25
    236a:	88 bb       	out	0x18, r24	; 24
    236c:	08 95       	ret
    236e:	41 30       	cpi	r20, 0x01	; 1
    2370:	81 f4       	brne	.+32     	; 0x2392 <GPIO_SetPinDirection+0xcc>
    2372:	27 b3       	in	r18, 0x17	; 23
    2374:	81 e0       	ldi	r24, 0x01	; 1
    2376:	90 e0       	ldi	r25, 0x00	; 0
    2378:	02 c0       	rjmp	.+4      	; 0x237e <GPIO_SetPinDirection+0xb8>
    237a:	88 0f       	add	r24, r24
    237c:	99 1f       	adc	r25, r25
    237e:	6a 95       	dec	r22
    2380:	e2 f7       	brpl	.-8      	; 0x237a <GPIO_SetPinDirection+0xb4>
    2382:	98 2f       	mov	r25, r24
    2384:	90 95       	com	r25
    2386:	92 23       	and	r25, r18
    2388:	97 bb       	out	0x17, r25	; 23
    238a:	98 b3       	in	r25, 0x18	; 24
    238c:	89 2b       	or	r24, r25
    238e:	88 bb       	out	0x18, r24	; 24
    2390:	08 95       	ret
    2392:	42 30       	cpi	r20, 0x02	; 2
    2394:	09 f0       	breq	.+2      	; 0x2398 <GPIO_SetPinDirection+0xd2>
    2396:	6c c0       	rjmp	.+216    	; 0x2470 <GPIO_SetPinDirection+0x1aa>
    2398:	27 b3       	in	r18, 0x17	; 23
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	02 c0       	rjmp	.+4      	; 0x23a4 <GPIO_SetPinDirection+0xde>
    23a0:	88 0f       	add	r24, r24
    23a2:	99 1f       	adc	r25, r25
    23a4:	6a 95       	dec	r22
    23a6:	e2 f7       	brpl	.-8      	; 0x23a0 <GPIO_SetPinDirection+0xda>
    23a8:	82 2b       	or	r24, r18
    23aa:	87 bb       	out	0x17, r24	; 23
    23ac:	08 95       	ret
    23ae:	41 11       	cpse	r20, r1
    23b0:	10 c0       	rjmp	.+32     	; 0x23d2 <GPIO_SetPinDirection+0x10c>
    23b2:	24 b3       	in	r18, 0x14	; 20
    23b4:	81 e0       	ldi	r24, 0x01	; 1
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	02 c0       	rjmp	.+4      	; 0x23be <GPIO_SetPinDirection+0xf8>
    23ba:	88 0f       	add	r24, r24
    23bc:	99 1f       	adc	r25, r25
    23be:	6a 95       	dec	r22
    23c0:	e2 f7       	brpl	.-8      	; 0x23ba <GPIO_SetPinDirection+0xf4>
    23c2:	80 95       	com	r24
    23c4:	92 2f       	mov	r25, r18
    23c6:	98 23       	and	r25, r24
    23c8:	94 bb       	out	0x14, r25	; 20
    23ca:	95 b3       	in	r25, 0x15	; 21
    23cc:	89 23       	and	r24, r25
    23ce:	85 bb       	out	0x15, r24	; 21
    23d0:	08 95       	ret
    23d2:	41 30       	cpi	r20, 0x01	; 1
    23d4:	81 f4       	brne	.+32     	; 0x23f6 <GPIO_SetPinDirection+0x130>
    23d6:	24 b3       	in	r18, 0x14	; 20
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	90 e0       	ldi	r25, 0x00	; 0
    23dc:	02 c0       	rjmp	.+4      	; 0x23e2 <GPIO_SetPinDirection+0x11c>
    23de:	88 0f       	add	r24, r24
    23e0:	99 1f       	adc	r25, r25
    23e2:	6a 95       	dec	r22
    23e4:	e2 f7       	brpl	.-8      	; 0x23de <GPIO_SetPinDirection+0x118>
    23e6:	98 2f       	mov	r25, r24
    23e8:	90 95       	com	r25
    23ea:	92 23       	and	r25, r18
    23ec:	94 bb       	out	0x14, r25	; 20
    23ee:	95 b3       	in	r25, 0x15	; 21
    23f0:	89 2b       	or	r24, r25
    23f2:	85 bb       	out	0x15, r24	; 21
    23f4:	08 95       	ret
    23f6:	42 30       	cpi	r20, 0x02	; 2
    23f8:	d9 f5       	brne	.+118    	; 0x2470 <GPIO_SetPinDirection+0x1aa>
    23fa:	24 b3       	in	r18, 0x14	; 20
    23fc:	81 e0       	ldi	r24, 0x01	; 1
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	02 c0       	rjmp	.+4      	; 0x2406 <GPIO_SetPinDirection+0x140>
    2402:	88 0f       	add	r24, r24
    2404:	99 1f       	adc	r25, r25
    2406:	6a 95       	dec	r22
    2408:	e2 f7       	brpl	.-8      	; 0x2402 <GPIO_SetPinDirection+0x13c>
    240a:	82 2b       	or	r24, r18
    240c:	84 bb       	out	0x14, r24	; 20
    240e:	08 95       	ret
    2410:	41 11       	cpse	r20, r1
    2412:	10 c0       	rjmp	.+32     	; 0x2434 <GPIO_SetPinDirection+0x16e>
    2414:	21 b3       	in	r18, 0x11	; 17
    2416:	81 e0       	ldi	r24, 0x01	; 1
    2418:	90 e0       	ldi	r25, 0x00	; 0
    241a:	02 c0       	rjmp	.+4      	; 0x2420 <GPIO_SetPinDirection+0x15a>
    241c:	88 0f       	add	r24, r24
    241e:	99 1f       	adc	r25, r25
    2420:	6a 95       	dec	r22
    2422:	e2 f7       	brpl	.-8      	; 0x241c <GPIO_SetPinDirection+0x156>
    2424:	80 95       	com	r24
    2426:	92 2f       	mov	r25, r18
    2428:	98 23       	and	r25, r24
    242a:	91 bb       	out	0x11, r25	; 17
    242c:	92 b3       	in	r25, 0x12	; 18
    242e:	89 23       	and	r24, r25
    2430:	82 bb       	out	0x12, r24	; 18
    2432:	08 95       	ret
    2434:	41 30       	cpi	r20, 0x01	; 1
    2436:	81 f4       	brne	.+32     	; 0x2458 <GPIO_SetPinDirection+0x192>
    2438:	21 b3       	in	r18, 0x11	; 17
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	90 e0       	ldi	r25, 0x00	; 0
    243e:	02 c0       	rjmp	.+4      	; 0x2444 <GPIO_SetPinDirection+0x17e>
    2440:	88 0f       	add	r24, r24
    2442:	99 1f       	adc	r25, r25
    2444:	6a 95       	dec	r22
    2446:	e2 f7       	brpl	.-8      	; 0x2440 <GPIO_SetPinDirection+0x17a>
    2448:	98 2f       	mov	r25, r24
    244a:	90 95       	com	r25
    244c:	92 23       	and	r25, r18
    244e:	91 bb       	out	0x11, r25	; 17
    2450:	92 b3       	in	r25, 0x12	; 18
    2452:	89 2b       	or	r24, r25
    2454:	82 bb       	out	0x12, r24	; 18
    2456:	08 95       	ret
    2458:	42 30       	cpi	r20, 0x02	; 2
    245a:	51 f4       	brne	.+20     	; 0x2470 <GPIO_SetPinDirection+0x1aa>
    245c:	21 b3       	in	r18, 0x11	; 17
    245e:	81 e0       	ldi	r24, 0x01	; 1
    2460:	90 e0       	ldi	r25, 0x00	; 0
    2462:	02 c0       	rjmp	.+4      	; 0x2468 <GPIO_SetPinDirection+0x1a2>
    2464:	88 0f       	add	r24, r24
    2466:	99 1f       	adc	r25, r25
    2468:	6a 95       	dec	r22
    246a:	e2 f7       	brpl	.-8      	; 0x2464 <GPIO_SetPinDirection+0x19e>
    246c:	82 2b       	or	r24, r18
    246e:	81 bb       	out	0x11, r24	; 17
    2470:	08 95       	ret

00002472 <GPIO_WritePin>:



void GPIO_WritePin(uint8 PORTX , uint8 PIN ,uint8 value)
{
    if(PORTX >= NUM_PORT  || PIN >= NUM_FOR_PINS_PER_PORT)
    2472:	84 30       	cpi	r24, 0x04	; 4
    2474:	08 f0       	brcs	.+2      	; 0x2478 <GPIO_WritePin+0x6>
    2476:	77 c0       	rjmp	.+238    	; 0x2566 <GPIO_WritePin+0xf4>
    2478:	68 30       	cpi	r22, 0x08	; 8
    247a:	08 f0       	brcs	.+2      	; 0x247e <GPIO_WritePin+0xc>
    247c:	74 c0       	rjmp	.+232    	; 0x2566 <GPIO_WritePin+0xf4>
    {
        /* Do Nothing*/
    }
    else
    {
        switch(PORTX)
    247e:	81 30       	cpi	r24, 0x01	; 1
    2480:	11 f1       	breq	.+68     	; 0x24c6 <GPIO_WritePin+0x54>
    2482:	30 f0       	brcs	.+12     	; 0x2490 <GPIO_WritePin+0x1e>
    2484:	82 30       	cpi	r24, 0x02	; 2
    2486:	d1 f1       	breq	.+116    	; 0x24fc <GPIO_WritePin+0x8a>
    2488:	83 30       	cpi	r24, 0x03	; 3
    248a:	09 f4       	brne	.+2      	; 0x248e <GPIO_WritePin+0x1c>
    248c:	52 c0       	rjmp	.+164    	; 0x2532 <GPIO_WritePin+0xc0>
    248e:	08 95       	ret
        {
            case PORTA_ID :
                if(value == LOGIC_HIGH)
    2490:	41 30       	cpi	r20, 0x01	; 1
    2492:	59 f4       	brne	.+22     	; 0x24aa <GPIO_WritePin+0x38>
                    SET_BIT(PORTA,PIN);
    2494:	2b b3       	in	r18, 0x1b	; 27
    2496:	81 e0       	ldi	r24, 0x01	; 1
    2498:	90 e0       	ldi	r25, 0x00	; 0
    249a:	02 c0       	rjmp	.+4      	; 0x24a0 <GPIO_WritePin+0x2e>
    249c:	88 0f       	add	r24, r24
    249e:	99 1f       	adc	r25, r25
    24a0:	6a 95       	dec	r22
    24a2:	e2 f7       	brpl	.-8      	; 0x249c <GPIO_WritePin+0x2a>
    24a4:	82 2b       	or	r24, r18
    24a6:	8b bb       	out	0x1b, r24	; 27
    24a8:	08 95       	ret
                else if(value == LOGIC_LOW)
    24aa:	41 11       	cpse	r20, r1
    24ac:	5c c0       	rjmp	.+184    	; 0x2566 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTA,PIN);
    24ae:	2b b3       	in	r18, 0x1b	; 27
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	90 e0       	ldi	r25, 0x00	; 0
    24b4:	02 c0       	rjmp	.+4      	; 0x24ba <GPIO_WritePin+0x48>
    24b6:	88 0f       	add	r24, r24
    24b8:	99 1f       	adc	r25, r25
    24ba:	6a 95       	dec	r22
    24bc:	e2 f7       	brpl	.-8      	; 0x24b6 <GPIO_WritePin+0x44>
    24be:	80 95       	com	r24
    24c0:	82 23       	and	r24, r18
    24c2:	8b bb       	out	0x1b, r24	; 27
    24c4:	08 95       	ret
                break;


            case PORTB_ID :
                if(value == LOGIC_HIGH)
    24c6:	41 30       	cpi	r20, 0x01	; 1
    24c8:	59 f4       	brne	.+22     	; 0x24e0 <GPIO_WritePin+0x6e>
                    SET_BIT(PORTB,PIN);
    24ca:	28 b3       	in	r18, 0x18	; 24
    24cc:	81 e0       	ldi	r24, 0x01	; 1
    24ce:	90 e0       	ldi	r25, 0x00	; 0
    24d0:	02 c0       	rjmp	.+4      	; 0x24d6 <GPIO_WritePin+0x64>
    24d2:	88 0f       	add	r24, r24
    24d4:	99 1f       	adc	r25, r25
    24d6:	6a 95       	dec	r22
    24d8:	e2 f7       	brpl	.-8      	; 0x24d2 <GPIO_WritePin+0x60>
    24da:	82 2b       	or	r24, r18
    24dc:	88 bb       	out	0x18, r24	; 24
    24de:	08 95       	ret
                else if(value == LOGIC_LOW)
    24e0:	41 11       	cpse	r20, r1
    24e2:	41 c0       	rjmp	.+130    	; 0x2566 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTB,PIN);
    24e4:	28 b3       	in	r18, 0x18	; 24
    24e6:	81 e0       	ldi	r24, 0x01	; 1
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	02 c0       	rjmp	.+4      	; 0x24f0 <GPIO_WritePin+0x7e>
    24ec:	88 0f       	add	r24, r24
    24ee:	99 1f       	adc	r25, r25
    24f0:	6a 95       	dec	r22
    24f2:	e2 f7       	brpl	.-8      	; 0x24ec <GPIO_WritePin+0x7a>
    24f4:	80 95       	com	r24
    24f6:	82 23       	and	r24, r18
    24f8:	88 bb       	out	0x18, r24	; 24
    24fa:	08 95       	ret
                break;  

            case PORTC_ID :
                if(value == LOGIC_HIGH)
    24fc:	41 30       	cpi	r20, 0x01	; 1
    24fe:	59 f4       	brne	.+22     	; 0x2516 <GPIO_WritePin+0xa4>
                    SET_BIT(PORTC,PIN);
    2500:	25 b3       	in	r18, 0x15	; 21
    2502:	81 e0       	ldi	r24, 0x01	; 1
    2504:	90 e0       	ldi	r25, 0x00	; 0
    2506:	02 c0       	rjmp	.+4      	; 0x250c <GPIO_WritePin+0x9a>
    2508:	88 0f       	add	r24, r24
    250a:	99 1f       	adc	r25, r25
    250c:	6a 95       	dec	r22
    250e:	e2 f7       	brpl	.-8      	; 0x2508 <GPIO_WritePin+0x96>
    2510:	82 2b       	or	r24, r18
    2512:	85 bb       	out	0x15, r24	; 21
    2514:	08 95       	ret
                else if(value == LOGIC_LOW)
    2516:	41 11       	cpse	r20, r1
    2518:	26 c0       	rjmp	.+76     	; 0x2566 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTC,PIN);
    251a:	25 b3       	in	r18, 0x15	; 21
    251c:	81 e0       	ldi	r24, 0x01	; 1
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	02 c0       	rjmp	.+4      	; 0x2526 <GPIO_WritePin+0xb4>
    2522:	88 0f       	add	r24, r24
    2524:	99 1f       	adc	r25, r25
    2526:	6a 95       	dec	r22
    2528:	e2 f7       	brpl	.-8      	; 0x2522 <GPIO_WritePin+0xb0>
    252a:	80 95       	com	r24
    252c:	82 23       	and	r24, r18
    252e:	85 bb       	out	0x15, r24	; 21
    2530:	08 95       	ret
                break;

            case PORTD_ID :
                if(value == LOGIC_HIGH)
    2532:	41 30       	cpi	r20, 0x01	; 1
    2534:	59 f4       	brne	.+22     	; 0x254c <GPIO_WritePin+0xda>
                    SET_BIT(PORTD,PIN);
    2536:	22 b3       	in	r18, 0x12	; 18
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	02 c0       	rjmp	.+4      	; 0x2542 <GPIO_WritePin+0xd0>
    253e:	88 0f       	add	r24, r24
    2540:	99 1f       	adc	r25, r25
    2542:	6a 95       	dec	r22
    2544:	e2 f7       	brpl	.-8      	; 0x253e <GPIO_WritePin+0xcc>
    2546:	82 2b       	or	r24, r18
    2548:	82 bb       	out	0x12, r24	; 18
    254a:	08 95       	ret
                else if(value == LOGIC_LOW)
    254c:	41 11       	cpse	r20, r1
    254e:	0b c0       	rjmp	.+22     	; 0x2566 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTD,PIN);
    2550:	22 b3       	in	r18, 0x12	; 18
    2552:	81 e0       	ldi	r24, 0x01	; 1
    2554:	90 e0       	ldi	r25, 0x00	; 0
    2556:	02 c0       	rjmp	.+4      	; 0x255c <GPIO_WritePin+0xea>
    2558:	88 0f       	add	r24, r24
    255a:	99 1f       	adc	r25, r25
    255c:	6a 95       	dec	r22
    255e:	e2 f7       	brpl	.-8      	; 0x2558 <GPIO_WritePin+0xe6>
    2560:	80 95       	com	r24
    2562:	82 23       	and	r24, r18
    2564:	82 bb       	out	0x12, r24	; 18
    2566:	08 95       	ret

00002568 <__vector_13>:
    uint16 Returned_value = 0;
    /*  Should read 9th bit of data if use 9 bit data before UDR*/
    Returned_value = ( (UCSRB & 0x02) << 7) ;
    Returned_value |= UDR ;
    return Returned_value;
}
    2568:	1f 92       	push	r1
    256a:	0f 92       	push	r0
    256c:	0f b6       	in	r0, 0x3f	; 63
    256e:	0f 92       	push	r0
    2570:	11 24       	eor	r1, r1
    2572:	2f 93       	push	r18
    2574:	3f 93       	push	r19
    2576:	4f 93       	push	r20
    2578:	5f 93       	push	r21
    257a:	6f 93       	push	r22
    257c:	7f 93       	push	r23
    257e:	8f 93       	push	r24
    2580:	9f 93       	push	r25
    2582:	af 93       	push	r26
    2584:	bf 93       	push	r27
    2586:	ef 93       	push	r30
    2588:	ff 93       	push	r31
    258a:	e0 91 c9 06 	lds	r30, 0x06C9	; 0x8006c9 <g_CallBackPtr_Receive_USART>
    258e:	f0 91 ca 06 	lds	r31, 0x06CA	; 0x8006ca <g_CallBackPtr_Receive_USART+0x1>
    2592:	30 97       	sbiw	r30, 0x00	; 0
    2594:	09 f0       	breq	.+2      	; 0x2598 <__vector_13+0x30>
    2596:	09 95       	icall
    2598:	ff 91       	pop	r31
    259a:	ef 91       	pop	r30
    259c:	bf 91       	pop	r27
    259e:	af 91       	pop	r26
    25a0:	9f 91       	pop	r25
    25a2:	8f 91       	pop	r24
    25a4:	7f 91       	pop	r23
    25a6:	6f 91       	pop	r22
    25a8:	5f 91       	pop	r21
    25aa:	4f 91       	pop	r20
    25ac:	3f 91       	pop	r19
    25ae:	2f 91       	pop	r18
    25b0:	0f 90       	pop	r0
    25b2:	0f be       	out	0x3f, r0	; 63
    25b4:	0f 90       	pop	r0
    25b6:	1f 90       	pop	r1
    25b8:	18 95       	reti

000025ba <USART_Init>:
    25ba:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <USART_ConfigTypeParam+0x3>
    25be:	81 11       	cpse	r24, r1
    25c0:	04 c0       	rjmp	.+8      	; 0x25ca <USART_Init+0x10>
    25c2:	8a b1       	in	r24, 0x0a	; 10
    25c4:	88 60       	ori	r24, 0x08	; 8
    25c6:	8a b9       	out	0x0a, r24	; 10
    25c8:	0e c0       	rjmp	.+28     	; 0x25e6 <USART_Init+0x2c>
    25ca:	81 30       	cpi	r24, 0x01	; 1
    25cc:	21 f4       	brne	.+8      	; 0x25d6 <USART_Init+0x1c>
    25ce:	8a b1       	in	r24, 0x0a	; 10
    25d0:	80 61       	ori	r24, 0x10	; 16
    25d2:	8a b9       	out	0x0a, r24	; 10
    25d4:	08 c0       	rjmp	.+16     	; 0x25e6 <USART_Init+0x2c>
    25d6:	82 30       	cpi	r24, 0x02	; 2
    25d8:	31 f4       	brne	.+12     	; 0x25e6 <USART_Init+0x2c>
    25da:	8a b1       	in	r24, 0x0a	; 10
    25dc:	80 61       	ori	r24, 0x10	; 16
    25de:	8a b9       	out	0x0a, r24	; 10
    25e0:	8a b1       	in	r24, 0x0a	; 10
    25e2:	88 60       	ori	r24, 0x08	; 8
    25e4:	8a b9       	out	0x0a, r24	; 10
    25e6:	e9 e6       	ldi	r30, 0x69	; 105
    25e8:	f0 e0       	ldi	r31, 0x00	; 0
    25ea:	41 81       	ldd	r20, Z+1	; 0x01
    25ec:	80 e1       	ldi	r24, 0x10	; 16
    25ee:	48 9f       	mul	r20, r24
    25f0:	a0 01       	movw	r20, r0
    25f2:	11 24       	eor	r1, r1
    25f4:	92 81       	ldd	r25, Z+2	; 0x02
    25f6:	29 2f       	mov	r18, r25
    25f8:	30 e0       	ldi	r19, 0x00	; 0
    25fa:	22 0f       	add	r18, r18
    25fc:	33 1f       	adc	r19, r19
    25fe:	22 0f       	add	r18, r18
    2600:	33 1f       	adc	r19, r19
    2602:	22 0f       	add	r18, r18
    2604:	33 1f       	adc	r19, r19
    2606:	90 81       	ld	r25, Z
    2608:	89 2f       	mov	r24, r25
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	88 0f       	add	r24, r24
    260e:	99 1f       	adc	r25, r25
    2610:	40 68       	ori	r20, 0x80	; 128
    2612:	24 2b       	or	r18, r20
    2614:	82 2b       	or	r24, r18
    2616:	80 bd       	out	0x20, r24	; 32
    2618:	2a b1       	in	r18, 0x0a	; 10
    261a:	90 81       	ld	r25, Z
    261c:	94 70       	andi	r25, 0x04	; 4
    261e:	89 2f       	mov	r24, r25
    2620:	90 e0       	ldi	r25, 0x00	; 0
    2622:	88 0f       	add	r24, r24
    2624:	99 1f       	adc	r25, r25
    2626:	88 0f       	add	r24, r24
    2628:	99 1f       	adc	r25, r25
    262a:	92 2f       	mov	r25, r18
    262c:	9b 7f       	andi	r25, 0xFB	; 251
    262e:	89 2b       	or	r24, r25
    2630:	8a b9       	out	0x0a, r24	; 10
    2632:	85 81       	ldd	r24, Z+5	; 0x05
    2634:	80 bd       	out	0x20, r24	; 32
    2636:	84 81       	ldd	r24, Z+4	; 0x04
    2638:	89 b9       	out	0x09, r24	; 9
    263a:	08 95       	ret

0000263c <USART_SendBytePolling>:
    263c:	5d 9b       	sbis	0x0b, 5	; 11
    263e:	fe cf       	rjmp	.-4      	; 0x263c <USART_SendBytePolling>
    2640:	90 ff       	sbrs	r25, 0
    2642:	04 c0       	rjmp	.+8      	; 0x264c <USART_SendBytePolling+0x10>
    2644:	2a b1       	in	r18, 0x0a	; 10
    2646:	21 60       	ori	r18, 0x01	; 1
    2648:	2a b9       	out	0x0a, r18	; 10
    264a:	03 c0       	rjmp	.+6      	; 0x2652 <USART_SendBytePolling+0x16>
    264c:	2a b1       	in	r18, 0x0a	; 10
    264e:	2e 7f       	andi	r18, 0xFE	; 254
    2650:	2a b9       	out	0x0a, r18	; 10
    2652:	8c b9       	out	0x0c, r24	; 12
    2654:	08 95       	ret

00002656 <USART_SendStringPolling>:
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	cf 93       	push	r28
    265c:	8c 01       	movw	r16, r24
    265e:	c0 e0       	ldi	r28, 0x00	; 0
    2660:	04 c0       	rjmp	.+8      	; 0x266a <USART_SendStringPolling+0x14>
    2662:	90 e0       	ldi	r25, 0x00	; 0
    2664:	0e 94 1e 13 	call	0x263c	; 0x263c <USART_SendBytePolling>
    2668:	cf 5f       	subi	r28, 0xFF	; 255
    266a:	f8 01       	movw	r30, r16
    266c:	ec 0f       	add	r30, r28
    266e:	f1 1d       	adc	r31, r1
    2670:	80 81       	ld	r24, Z
    2672:	81 11       	cpse	r24, r1
    2674:	f6 cf       	rjmp	.-20     	; 0x2662 <USART_SendStringPolling+0xc>
    2676:	cf 91       	pop	r28
    2678:	1f 91       	pop	r17
    267a:	0f 91       	pop	r16
    267c:	08 95       	ret

0000267e <UART_receiveByteUnblocking>:


boolean UART_receiveByteUnblocking(uint8 * Data)
{
    boolean result = FALSE;
	if ( UCSRA & (1<<RXC) ){
    267e:	5f 9b       	sbis	0x0b, 7	; 11
    2680:	05 c0       	rjmp	.+10     	; 0x268c <UART_receiveByteUnblocking+0xe>
		(*Data) = UDR;
    2682:	2c b1       	in	r18, 0x0c	; 12
    2684:	fc 01       	movw	r30, r24
    2686:	20 83       	st	Z, r18
		result =  TRUE;		
    2688:	81 e0       	ldi	r24, 0x01	; 1
    268a:	08 95       	ret
	}
	else{
		result = FALSE;
    268c:	80 e0       	ldi	r24, 0x00	; 0
	}
	return result;
    268e:	08 95       	ret

00002690 <__subsf3>:
    2690:	50 58       	subi	r21, 0x80	; 128

00002692 <__addsf3>:
    2692:	bb 27       	eor	r27, r27
    2694:	aa 27       	eor	r26, r26
    2696:	0e 94 60 13 	call	0x26c0	; 0x26c0 <__addsf3x>
    269a:	0c 94 aa 14 	jmp	0x2954	; 0x2954 <__fp_round>
    269e:	0e 94 9c 14 	call	0x2938	; 0x2938 <__fp_pscA>
    26a2:	38 f0       	brcs	.+14     	; 0x26b2 <__addsf3+0x20>
    26a4:	0e 94 a3 14 	call	0x2946	; 0x2946 <__fp_pscB>
    26a8:	20 f0       	brcs	.+8      	; 0x26b2 <__addsf3+0x20>
    26aa:	39 f4       	brne	.+14     	; 0x26ba <__addsf3+0x28>
    26ac:	9f 3f       	cpi	r25, 0xFF	; 255
    26ae:	19 f4       	brne	.+6      	; 0x26b6 <__addsf3+0x24>
    26b0:	26 f4       	brtc	.+8      	; 0x26ba <__addsf3+0x28>
    26b2:	0c 94 99 14 	jmp	0x2932	; 0x2932 <__fp_nan>
    26b6:	0e f4       	brtc	.+2      	; 0x26ba <__addsf3+0x28>
    26b8:	e0 95       	com	r30
    26ba:	e7 fb       	bst	r30, 7
    26bc:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__fp_inf>

000026c0 <__addsf3x>:
    26c0:	e9 2f       	mov	r30, r25
    26c2:	0e 94 bb 14 	call	0x2976	; 0x2976 <__fp_split3>
    26c6:	58 f3       	brcs	.-42     	; 0x269e <__addsf3+0xc>
    26c8:	ba 17       	cp	r27, r26
    26ca:	62 07       	cpc	r22, r18
    26cc:	73 07       	cpc	r23, r19
    26ce:	84 07       	cpc	r24, r20
    26d0:	95 07       	cpc	r25, r21
    26d2:	20 f0       	brcs	.+8      	; 0x26dc <__addsf3x+0x1c>
    26d4:	79 f4       	brne	.+30     	; 0x26f4 <__addsf3x+0x34>
    26d6:	a6 f5       	brtc	.+104    	; 0x2740 <__addsf3x+0x80>
    26d8:	0c 94 dd 14 	jmp	0x29ba	; 0x29ba <__fp_zero>
    26dc:	0e f4       	brtc	.+2      	; 0x26e0 <__addsf3x+0x20>
    26de:	e0 95       	com	r30
    26e0:	0b 2e       	mov	r0, r27
    26e2:	ba 2f       	mov	r27, r26
    26e4:	a0 2d       	mov	r26, r0
    26e6:	0b 01       	movw	r0, r22
    26e8:	b9 01       	movw	r22, r18
    26ea:	90 01       	movw	r18, r0
    26ec:	0c 01       	movw	r0, r24
    26ee:	ca 01       	movw	r24, r20
    26f0:	a0 01       	movw	r20, r0
    26f2:	11 24       	eor	r1, r1
    26f4:	ff 27       	eor	r31, r31
    26f6:	59 1b       	sub	r21, r25
    26f8:	99 f0       	breq	.+38     	; 0x2720 <__addsf3x+0x60>
    26fa:	59 3f       	cpi	r21, 0xF9	; 249
    26fc:	50 f4       	brcc	.+20     	; 0x2712 <__addsf3x+0x52>
    26fe:	50 3e       	cpi	r21, 0xE0	; 224
    2700:	68 f1       	brcs	.+90     	; 0x275c <__addsf3x+0x9c>
    2702:	1a 16       	cp	r1, r26
    2704:	f0 40       	sbci	r31, 0x00	; 0
    2706:	a2 2f       	mov	r26, r18
    2708:	23 2f       	mov	r18, r19
    270a:	34 2f       	mov	r19, r20
    270c:	44 27       	eor	r20, r20
    270e:	58 5f       	subi	r21, 0xF8	; 248
    2710:	f3 cf       	rjmp	.-26     	; 0x26f8 <__addsf3x+0x38>
    2712:	46 95       	lsr	r20
    2714:	37 95       	ror	r19
    2716:	27 95       	ror	r18
    2718:	a7 95       	ror	r26
    271a:	f0 40       	sbci	r31, 0x00	; 0
    271c:	53 95       	inc	r21
    271e:	c9 f7       	brne	.-14     	; 0x2712 <__addsf3x+0x52>
    2720:	7e f4       	brtc	.+30     	; 0x2740 <__addsf3x+0x80>
    2722:	1f 16       	cp	r1, r31
    2724:	ba 0b       	sbc	r27, r26
    2726:	62 0b       	sbc	r22, r18
    2728:	73 0b       	sbc	r23, r19
    272a:	84 0b       	sbc	r24, r20
    272c:	ba f0       	brmi	.+46     	; 0x275c <__addsf3x+0x9c>
    272e:	91 50       	subi	r25, 0x01	; 1
    2730:	a1 f0       	breq	.+40     	; 0x275a <__addsf3x+0x9a>
    2732:	ff 0f       	add	r31, r31
    2734:	bb 1f       	adc	r27, r27
    2736:	66 1f       	adc	r22, r22
    2738:	77 1f       	adc	r23, r23
    273a:	88 1f       	adc	r24, r24
    273c:	c2 f7       	brpl	.-16     	; 0x272e <__addsf3x+0x6e>
    273e:	0e c0       	rjmp	.+28     	; 0x275c <__addsf3x+0x9c>
    2740:	ba 0f       	add	r27, r26
    2742:	62 1f       	adc	r22, r18
    2744:	73 1f       	adc	r23, r19
    2746:	84 1f       	adc	r24, r20
    2748:	48 f4       	brcc	.+18     	; 0x275c <__addsf3x+0x9c>
    274a:	87 95       	ror	r24
    274c:	77 95       	ror	r23
    274e:	67 95       	ror	r22
    2750:	b7 95       	ror	r27
    2752:	f7 95       	ror	r31
    2754:	9e 3f       	cpi	r25, 0xFE	; 254
    2756:	08 f0       	brcs	.+2      	; 0x275a <__addsf3x+0x9a>
    2758:	b0 cf       	rjmp	.-160    	; 0x26ba <__addsf3+0x28>
    275a:	93 95       	inc	r25
    275c:	88 0f       	add	r24, r24
    275e:	08 f0       	brcs	.+2      	; 0x2762 <__addsf3x+0xa2>
    2760:	99 27       	eor	r25, r25
    2762:	ee 0f       	add	r30, r30
    2764:	97 95       	ror	r25
    2766:	87 95       	ror	r24
    2768:	08 95       	ret

0000276a <__divsf3>:
    276a:	0e 94 c9 13 	call	0x2792	; 0x2792 <__divsf3x>
    276e:	0c 94 aa 14 	jmp	0x2954	; 0x2954 <__fp_round>
    2772:	0e 94 a3 14 	call	0x2946	; 0x2946 <__fp_pscB>
    2776:	58 f0       	brcs	.+22     	; 0x278e <__divsf3+0x24>
    2778:	0e 94 9c 14 	call	0x2938	; 0x2938 <__fp_pscA>
    277c:	40 f0       	brcs	.+16     	; 0x278e <__divsf3+0x24>
    277e:	29 f4       	brne	.+10     	; 0x278a <__divsf3+0x20>
    2780:	5f 3f       	cpi	r21, 0xFF	; 255
    2782:	29 f0       	breq	.+10     	; 0x278e <__divsf3+0x24>
    2784:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__fp_inf>
    2788:	51 11       	cpse	r21, r1
    278a:	0c 94 de 14 	jmp	0x29bc	; 0x29bc <__fp_szero>
    278e:	0c 94 99 14 	jmp	0x2932	; 0x2932 <__fp_nan>

00002792 <__divsf3x>:
    2792:	0e 94 bb 14 	call	0x2976	; 0x2976 <__fp_split3>
    2796:	68 f3       	brcs	.-38     	; 0x2772 <__divsf3+0x8>

00002798 <__divsf3_pse>:
    2798:	99 23       	and	r25, r25
    279a:	b1 f3       	breq	.-20     	; 0x2788 <__divsf3+0x1e>
    279c:	55 23       	and	r21, r21
    279e:	91 f3       	breq	.-28     	; 0x2784 <__divsf3+0x1a>
    27a0:	95 1b       	sub	r25, r21
    27a2:	55 0b       	sbc	r21, r21
    27a4:	bb 27       	eor	r27, r27
    27a6:	aa 27       	eor	r26, r26
    27a8:	62 17       	cp	r22, r18
    27aa:	73 07       	cpc	r23, r19
    27ac:	84 07       	cpc	r24, r20
    27ae:	38 f0       	brcs	.+14     	; 0x27be <__divsf3_pse+0x26>
    27b0:	9f 5f       	subi	r25, 0xFF	; 255
    27b2:	5f 4f       	sbci	r21, 0xFF	; 255
    27b4:	22 0f       	add	r18, r18
    27b6:	33 1f       	adc	r19, r19
    27b8:	44 1f       	adc	r20, r20
    27ba:	aa 1f       	adc	r26, r26
    27bc:	a9 f3       	breq	.-22     	; 0x27a8 <__divsf3_pse+0x10>
    27be:	35 d0       	rcall	.+106    	; 0x282a <__divsf3_pse+0x92>
    27c0:	0e 2e       	mov	r0, r30
    27c2:	3a f0       	brmi	.+14     	; 0x27d2 <__divsf3_pse+0x3a>
    27c4:	e0 e8       	ldi	r30, 0x80	; 128
    27c6:	32 d0       	rcall	.+100    	; 0x282c <__divsf3_pse+0x94>
    27c8:	91 50       	subi	r25, 0x01	; 1
    27ca:	50 40       	sbci	r21, 0x00	; 0
    27cc:	e6 95       	lsr	r30
    27ce:	00 1c       	adc	r0, r0
    27d0:	ca f7       	brpl	.-14     	; 0x27c4 <__divsf3_pse+0x2c>
    27d2:	2b d0       	rcall	.+86     	; 0x282a <__divsf3_pse+0x92>
    27d4:	fe 2f       	mov	r31, r30
    27d6:	29 d0       	rcall	.+82     	; 0x282a <__divsf3_pse+0x92>
    27d8:	66 0f       	add	r22, r22
    27da:	77 1f       	adc	r23, r23
    27dc:	88 1f       	adc	r24, r24
    27de:	bb 1f       	adc	r27, r27
    27e0:	26 17       	cp	r18, r22
    27e2:	37 07       	cpc	r19, r23
    27e4:	48 07       	cpc	r20, r24
    27e6:	ab 07       	cpc	r26, r27
    27e8:	b0 e8       	ldi	r27, 0x80	; 128
    27ea:	09 f0       	breq	.+2      	; 0x27ee <__divsf3_pse+0x56>
    27ec:	bb 0b       	sbc	r27, r27
    27ee:	80 2d       	mov	r24, r0
    27f0:	bf 01       	movw	r22, r30
    27f2:	ff 27       	eor	r31, r31
    27f4:	93 58       	subi	r25, 0x83	; 131
    27f6:	5f 4f       	sbci	r21, 0xFF	; 255
    27f8:	3a f0       	brmi	.+14     	; 0x2808 <__divsf3_pse+0x70>
    27fa:	9e 3f       	cpi	r25, 0xFE	; 254
    27fc:	51 05       	cpc	r21, r1
    27fe:	78 f0       	brcs	.+30     	; 0x281e <__divsf3_pse+0x86>
    2800:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__fp_inf>
    2804:	0c 94 de 14 	jmp	0x29bc	; 0x29bc <__fp_szero>
    2808:	5f 3f       	cpi	r21, 0xFF	; 255
    280a:	e4 f3       	brlt	.-8      	; 0x2804 <__divsf3_pse+0x6c>
    280c:	98 3e       	cpi	r25, 0xE8	; 232
    280e:	d4 f3       	brlt	.-12     	; 0x2804 <__divsf3_pse+0x6c>
    2810:	86 95       	lsr	r24
    2812:	77 95       	ror	r23
    2814:	67 95       	ror	r22
    2816:	b7 95       	ror	r27
    2818:	f7 95       	ror	r31
    281a:	9f 5f       	subi	r25, 0xFF	; 255
    281c:	c9 f7       	brne	.-14     	; 0x2810 <__divsf3_pse+0x78>
    281e:	88 0f       	add	r24, r24
    2820:	91 1d       	adc	r25, r1
    2822:	96 95       	lsr	r25
    2824:	87 95       	ror	r24
    2826:	97 f9       	bld	r25, 7
    2828:	08 95       	ret
    282a:	e1 e0       	ldi	r30, 0x01	; 1
    282c:	66 0f       	add	r22, r22
    282e:	77 1f       	adc	r23, r23
    2830:	88 1f       	adc	r24, r24
    2832:	bb 1f       	adc	r27, r27
    2834:	62 17       	cp	r22, r18
    2836:	73 07       	cpc	r23, r19
    2838:	84 07       	cpc	r24, r20
    283a:	ba 07       	cpc	r27, r26
    283c:	20 f0       	brcs	.+8      	; 0x2846 <__divsf3_pse+0xae>
    283e:	62 1b       	sub	r22, r18
    2840:	73 0b       	sbc	r23, r19
    2842:	84 0b       	sbc	r24, r20
    2844:	ba 0b       	sbc	r27, r26
    2846:	ee 1f       	adc	r30, r30
    2848:	88 f7       	brcc	.-30     	; 0x282c <__divsf3_pse+0x94>
    284a:	e0 95       	com	r30
    284c:	08 95       	ret

0000284e <__fixunssfsi>:
    284e:	0e 94 c3 14 	call	0x2986	; 0x2986 <__fp_splitA>
    2852:	88 f0       	brcs	.+34     	; 0x2876 <__fixunssfsi+0x28>
    2854:	9f 57       	subi	r25, 0x7F	; 127
    2856:	98 f0       	brcs	.+38     	; 0x287e <__fixunssfsi+0x30>
    2858:	b9 2f       	mov	r27, r25
    285a:	99 27       	eor	r25, r25
    285c:	b7 51       	subi	r27, 0x17	; 23
    285e:	b0 f0       	brcs	.+44     	; 0x288c <__fixunssfsi+0x3e>
    2860:	e1 f0       	breq	.+56     	; 0x289a <__fixunssfsi+0x4c>
    2862:	66 0f       	add	r22, r22
    2864:	77 1f       	adc	r23, r23
    2866:	88 1f       	adc	r24, r24
    2868:	99 1f       	adc	r25, r25
    286a:	1a f0       	brmi	.+6      	; 0x2872 <__fixunssfsi+0x24>
    286c:	ba 95       	dec	r27
    286e:	c9 f7       	brne	.-14     	; 0x2862 <__fixunssfsi+0x14>
    2870:	14 c0       	rjmp	.+40     	; 0x289a <__fixunssfsi+0x4c>
    2872:	b1 30       	cpi	r27, 0x01	; 1
    2874:	91 f0       	breq	.+36     	; 0x289a <__fixunssfsi+0x4c>
    2876:	0e 94 dd 14 	call	0x29ba	; 0x29ba <__fp_zero>
    287a:	b1 e0       	ldi	r27, 0x01	; 1
    287c:	08 95       	ret
    287e:	0c 94 dd 14 	jmp	0x29ba	; 0x29ba <__fp_zero>
    2882:	67 2f       	mov	r22, r23
    2884:	78 2f       	mov	r23, r24
    2886:	88 27       	eor	r24, r24
    2888:	b8 5f       	subi	r27, 0xF8	; 248
    288a:	39 f0       	breq	.+14     	; 0x289a <__fixunssfsi+0x4c>
    288c:	b9 3f       	cpi	r27, 0xF9	; 249
    288e:	cc f3       	brlt	.-14     	; 0x2882 <__fixunssfsi+0x34>
    2890:	86 95       	lsr	r24
    2892:	77 95       	ror	r23
    2894:	67 95       	ror	r22
    2896:	b3 95       	inc	r27
    2898:	d9 f7       	brne	.-10     	; 0x2890 <__fixunssfsi+0x42>
    289a:	3e f4       	brtc	.+14     	; 0x28aa <__fixunssfsi+0x5c>
    289c:	90 95       	com	r25
    289e:	80 95       	com	r24
    28a0:	70 95       	com	r23
    28a2:	61 95       	neg	r22
    28a4:	7f 4f       	sbci	r23, 0xFF	; 255
    28a6:	8f 4f       	sbci	r24, 0xFF	; 255
    28a8:	9f 4f       	sbci	r25, 0xFF	; 255
    28aa:	08 95       	ret

000028ac <__floatunsisf>:
    28ac:	e8 94       	clt
    28ae:	09 c0       	rjmp	.+18     	; 0x28c2 <__floatsisf+0x12>

000028b0 <__floatsisf>:
    28b0:	97 fb       	bst	r25, 7
    28b2:	3e f4       	brtc	.+14     	; 0x28c2 <__floatsisf+0x12>
    28b4:	90 95       	com	r25
    28b6:	80 95       	com	r24
    28b8:	70 95       	com	r23
    28ba:	61 95       	neg	r22
    28bc:	7f 4f       	sbci	r23, 0xFF	; 255
    28be:	8f 4f       	sbci	r24, 0xFF	; 255
    28c0:	9f 4f       	sbci	r25, 0xFF	; 255
    28c2:	99 23       	and	r25, r25
    28c4:	a9 f0       	breq	.+42     	; 0x28f0 <__floatsisf+0x40>
    28c6:	f9 2f       	mov	r31, r25
    28c8:	96 e9       	ldi	r25, 0x96	; 150
    28ca:	bb 27       	eor	r27, r27
    28cc:	93 95       	inc	r25
    28ce:	f6 95       	lsr	r31
    28d0:	87 95       	ror	r24
    28d2:	77 95       	ror	r23
    28d4:	67 95       	ror	r22
    28d6:	b7 95       	ror	r27
    28d8:	f1 11       	cpse	r31, r1
    28da:	f8 cf       	rjmp	.-16     	; 0x28cc <__floatsisf+0x1c>
    28dc:	fa f4       	brpl	.+62     	; 0x291c <__floatsisf+0x6c>
    28de:	bb 0f       	add	r27, r27
    28e0:	11 f4       	brne	.+4      	; 0x28e6 <__floatsisf+0x36>
    28e2:	60 ff       	sbrs	r22, 0
    28e4:	1b c0       	rjmp	.+54     	; 0x291c <__floatsisf+0x6c>
    28e6:	6f 5f       	subi	r22, 0xFF	; 255
    28e8:	7f 4f       	sbci	r23, 0xFF	; 255
    28ea:	8f 4f       	sbci	r24, 0xFF	; 255
    28ec:	9f 4f       	sbci	r25, 0xFF	; 255
    28ee:	16 c0       	rjmp	.+44     	; 0x291c <__floatsisf+0x6c>
    28f0:	88 23       	and	r24, r24
    28f2:	11 f0       	breq	.+4      	; 0x28f8 <__floatsisf+0x48>
    28f4:	96 e9       	ldi	r25, 0x96	; 150
    28f6:	11 c0       	rjmp	.+34     	; 0x291a <__floatsisf+0x6a>
    28f8:	77 23       	and	r23, r23
    28fa:	21 f0       	breq	.+8      	; 0x2904 <__floatsisf+0x54>
    28fc:	9e e8       	ldi	r25, 0x8E	; 142
    28fe:	87 2f       	mov	r24, r23
    2900:	76 2f       	mov	r23, r22
    2902:	05 c0       	rjmp	.+10     	; 0x290e <__floatsisf+0x5e>
    2904:	66 23       	and	r22, r22
    2906:	71 f0       	breq	.+28     	; 0x2924 <__floatsisf+0x74>
    2908:	96 e8       	ldi	r25, 0x86	; 134
    290a:	86 2f       	mov	r24, r22
    290c:	70 e0       	ldi	r23, 0x00	; 0
    290e:	60 e0       	ldi	r22, 0x00	; 0
    2910:	2a f0       	brmi	.+10     	; 0x291c <__floatsisf+0x6c>
    2912:	9a 95       	dec	r25
    2914:	66 0f       	add	r22, r22
    2916:	77 1f       	adc	r23, r23
    2918:	88 1f       	adc	r24, r24
    291a:	da f7       	brpl	.-10     	; 0x2912 <__floatsisf+0x62>
    291c:	88 0f       	add	r24, r24
    291e:	96 95       	lsr	r25
    2920:	87 95       	ror	r24
    2922:	97 f9       	bld	r25, 7
    2924:	08 95       	ret

00002926 <__fp_inf>:
    2926:	97 f9       	bld	r25, 7
    2928:	9f 67       	ori	r25, 0x7F	; 127
    292a:	80 e8       	ldi	r24, 0x80	; 128
    292c:	70 e0       	ldi	r23, 0x00	; 0
    292e:	60 e0       	ldi	r22, 0x00	; 0
    2930:	08 95       	ret

00002932 <__fp_nan>:
    2932:	9f ef       	ldi	r25, 0xFF	; 255
    2934:	80 ec       	ldi	r24, 0xC0	; 192
    2936:	08 95       	ret

00002938 <__fp_pscA>:
    2938:	00 24       	eor	r0, r0
    293a:	0a 94       	dec	r0
    293c:	16 16       	cp	r1, r22
    293e:	17 06       	cpc	r1, r23
    2940:	18 06       	cpc	r1, r24
    2942:	09 06       	cpc	r0, r25
    2944:	08 95       	ret

00002946 <__fp_pscB>:
    2946:	00 24       	eor	r0, r0
    2948:	0a 94       	dec	r0
    294a:	12 16       	cp	r1, r18
    294c:	13 06       	cpc	r1, r19
    294e:	14 06       	cpc	r1, r20
    2950:	05 06       	cpc	r0, r21
    2952:	08 95       	ret

00002954 <__fp_round>:
    2954:	09 2e       	mov	r0, r25
    2956:	03 94       	inc	r0
    2958:	00 0c       	add	r0, r0
    295a:	11 f4       	brne	.+4      	; 0x2960 <__fp_round+0xc>
    295c:	88 23       	and	r24, r24
    295e:	52 f0       	brmi	.+20     	; 0x2974 <__fp_round+0x20>
    2960:	bb 0f       	add	r27, r27
    2962:	40 f4       	brcc	.+16     	; 0x2974 <__fp_round+0x20>
    2964:	bf 2b       	or	r27, r31
    2966:	11 f4       	brne	.+4      	; 0x296c <__fp_round+0x18>
    2968:	60 ff       	sbrs	r22, 0
    296a:	04 c0       	rjmp	.+8      	; 0x2974 <__fp_round+0x20>
    296c:	6f 5f       	subi	r22, 0xFF	; 255
    296e:	7f 4f       	sbci	r23, 0xFF	; 255
    2970:	8f 4f       	sbci	r24, 0xFF	; 255
    2972:	9f 4f       	sbci	r25, 0xFF	; 255
    2974:	08 95       	ret

00002976 <__fp_split3>:
    2976:	57 fd       	sbrc	r21, 7
    2978:	90 58       	subi	r25, 0x80	; 128
    297a:	44 0f       	add	r20, r20
    297c:	55 1f       	adc	r21, r21
    297e:	59 f0       	breq	.+22     	; 0x2996 <__fp_splitA+0x10>
    2980:	5f 3f       	cpi	r21, 0xFF	; 255
    2982:	71 f0       	breq	.+28     	; 0x29a0 <__fp_splitA+0x1a>
    2984:	47 95       	ror	r20

00002986 <__fp_splitA>:
    2986:	88 0f       	add	r24, r24
    2988:	97 fb       	bst	r25, 7
    298a:	99 1f       	adc	r25, r25
    298c:	61 f0       	breq	.+24     	; 0x29a6 <__fp_splitA+0x20>
    298e:	9f 3f       	cpi	r25, 0xFF	; 255
    2990:	79 f0       	breq	.+30     	; 0x29b0 <__fp_splitA+0x2a>
    2992:	87 95       	ror	r24
    2994:	08 95       	ret
    2996:	12 16       	cp	r1, r18
    2998:	13 06       	cpc	r1, r19
    299a:	14 06       	cpc	r1, r20
    299c:	55 1f       	adc	r21, r21
    299e:	f2 cf       	rjmp	.-28     	; 0x2984 <__fp_split3+0xe>
    29a0:	46 95       	lsr	r20
    29a2:	f1 df       	rcall	.-30     	; 0x2986 <__fp_splitA>
    29a4:	08 c0       	rjmp	.+16     	; 0x29b6 <__fp_splitA+0x30>
    29a6:	16 16       	cp	r1, r22
    29a8:	17 06       	cpc	r1, r23
    29aa:	18 06       	cpc	r1, r24
    29ac:	99 1f       	adc	r25, r25
    29ae:	f1 cf       	rjmp	.-30     	; 0x2992 <__fp_splitA+0xc>
    29b0:	86 95       	lsr	r24
    29b2:	71 05       	cpc	r23, r1
    29b4:	61 05       	cpc	r22, r1
    29b6:	08 94       	sec
    29b8:	08 95       	ret

000029ba <__fp_zero>:
    29ba:	e8 94       	clt

000029bc <__fp_szero>:
    29bc:	bb 27       	eor	r27, r27
    29be:	66 27       	eor	r22, r22
    29c0:	77 27       	eor	r23, r23
    29c2:	cb 01       	movw	r24, r22
    29c4:	97 f9       	bld	r25, 7
    29c6:	08 95       	ret
    29c8:	16 f0       	brts	.+4      	; 0x29ce <__fp_szero+0x12>
    29ca:	0c 94 a1 15 	jmp	0x2b42	; 0x2b42 <__fp_mpack>
    29ce:	0c 94 99 14 	jmp	0x2932	; 0x2932 <__fp_nan>
    29d2:	68 94       	set
    29d4:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__fp_inf>

000029d8 <log>:
    29d8:	0e 94 c3 14 	call	0x2986	; 0x2986 <__fp_splitA>
    29dc:	a8 f3       	brcs	.-22     	; 0x29c8 <__fp_szero+0xc>
    29de:	99 23       	and	r25, r25
    29e0:	c1 f3       	breq	.-16     	; 0x29d2 <__fp_szero+0x16>
    29e2:	ae f3       	brts	.-22     	; 0x29ce <__fp_szero+0x12>
    29e4:	df 93       	push	r29
    29e6:	cf 93       	push	r28
    29e8:	1f 93       	push	r17
    29ea:	0f 93       	push	r16
    29ec:	ff 92       	push	r15
    29ee:	c9 2f       	mov	r28, r25
    29f0:	dd 27       	eor	r29, r29
    29f2:	88 23       	and	r24, r24
    29f4:	2a f0       	brmi	.+10     	; 0x2a00 <log+0x28>
    29f6:	21 97       	sbiw	r28, 0x01	; 1
    29f8:	66 0f       	add	r22, r22
    29fa:	77 1f       	adc	r23, r23
    29fc:	88 1f       	adc	r24, r24
    29fe:	da f7       	brpl	.-10     	; 0x29f6 <log+0x1e>
    2a00:	20 e0       	ldi	r18, 0x00	; 0
    2a02:	30 e0       	ldi	r19, 0x00	; 0
    2a04:	40 e8       	ldi	r20, 0x80	; 128
    2a06:	5f eb       	ldi	r21, 0xBF	; 191
    2a08:	9f e3       	ldi	r25, 0x3F	; 63
    2a0a:	88 39       	cpi	r24, 0x98	; 152
    2a0c:	20 f0       	brcs	.+8      	; 0x2a16 <log+0x3e>
    2a0e:	80 3e       	cpi	r24, 0xE0	; 224
    2a10:	38 f0       	brcs	.+14     	; 0x2a20 <log+0x48>
    2a12:	21 96       	adiw	r28, 0x01	; 1
    2a14:	8f 77       	andi	r24, 0x7F	; 127
    2a16:	0e 94 49 13 	call	0x2692	; 0x2692 <__addsf3>
    2a1a:	e4 e5       	ldi	r30, 0x54	; 84
    2a1c:	f0 e0       	ldi	r31, 0x00	; 0
    2a1e:	04 c0       	rjmp	.+8      	; 0x2a28 <log+0x50>
    2a20:	0e 94 49 13 	call	0x2692	; 0x2692 <__addsf3>
    2a24:	e1 e8       	ldi	r30, 0x81	; 129
    2a26:	f0 e0       	ldi	r31, 0x00	; 0
    2a28:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <__fp_powser>
    2a2c:	8b 01       	movw	r16, r22
    2a2e:	be 01       	movw	r22, r28
    2a30:	ec 01       	movw	r28, r24
    2a32:	fb 2e       	mov	r15, r27
    2a34:	6f 57       	subi	r22, 0x7F	; 127
    2a36:	71 09       	sbc	r23, r1
    2a38:	75 95       	asr	r23
    2a3a:	77 1f       	adc	r23, r23
    2a3c:	88 0b       	sbc	r24, r24
    2a3e:	99 0b       	sbc	r25, r25
    2a40:	0e 94 58 14 	call	0x28b0	; 0x28b0 <__floatsisf>
    2a44:	28 e1       	ldi	r18, 0x18	; 24
    2a46:	32 e7       	ldi	r19, 0x72	; 114
    2a48:	41 e3       	ldi	r20, 0x31	; 49
    2a4a:	5f e3       	ldi	r21, 0x3F	; 63
    2a4c:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <__mulsf3x>
    2a50:	af 2d       	mov	r26, r15
    2a52:	98 01       	movw	r18, r16
    2a54:	ae 01       	movw	r20, r28
    2a56:	ff 90       	pop	r15
    2a58:	0f 91       	pop	r16
    2a5a:	1f 91       	pop	r17
    2a5c:	cf 91       	pop	r28
    2a5e:	df 91       	pop	r29
    2a60:	0e 94 60 13 	call	0x26c0	; 0x26c0 <__addsf3x>
    2a64:	0c 94 aa 14 	jmp	0x2954	; 0x2954 <__fp_round>

00002a68 <__mulsf3>:
    2a68:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <__mulsf3x>
    2a6c:	0c 94 aa 14 	jmp	0x2954	; 0x2954 <__fp_round>
    2a70:	0e 94 9c 14 	call	0x2938	; 0x2938 <__fp_pscA>
    2a74:	38 f0       	brcs	.+14     	; 0x2a84 <__mulsf3+0x1c>
    2a76:	0e 94 a3 14 	call	0x2946	; 0x2946 <__fp_pscB>
    2a7a:	20 f0       	brcs	.+8      	; 0x2a84 <__mulsf3+0x1c>
    2a7c:	95 23       	and	r25, r21
    2a7e:	11 f0       	breq	.+4      	; 0x2a84 <__mulsf3+0x1c>
    2a80:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__fp_inf>
    2a84:	0c 94 99 14 	jmp	0x2932	; 0x2932 <__fp_nan>
    2a88:	11 24       	eor	r1, r1
    2a8a:	0c 94 de 14 	jmp	0x29bc	; 0x29bc <__fp_szero>

00002a8e <__mulsf3x>:
    2a8e:	0e 94 bb 14 	call	0x2976	; 0x2976 <__fp_split3>
    2a92:	70 f3       	brcs	.-36     	; 0x2a70 <__mulsf3+0x8>

00002a94 <__mulsf3_pse>:
    2a94:	95 9f       	mul	r25, r21
    2a96:	c1 f3       	breq	.-16     	; 0x2a88 <__mulsf3+0x20>
    2a98:	95 0f       	add	r25, r21
    2a9a:	50 e0       	ldi	r21, 0x00	; 0
    2a9c:	55 1f       	adc	r21, r21
    2a9e:	62 9f       	mul	r22, r18
    2aa0:	f0 01       	movw	r30, r0
    2aa2:	72 9f       	mul	r23, r18
    2aa4:	bb 27       	eor	r27, r27
    2aa6:	f0 0d       	add	r31, r0
    2aa8:	b1 1d       	adc	r27, r1
    2aaa:	63 9f       	mul	r22, r19
    2aac:	aa 27       	eor	r26, r26
    2aae:	f0 0d       	add	r31, r0
    2ab0:	b1 1d       	adc	r27, r1
    2ab2:	aa 1f       	adc	r26, r26
    2ab4:	64 9f       	mul	r22, r20
    2ab6:	66 27       	eor	r22, r22
    2ab8:	b0 0d       	add	r27, r0
    2aba:	a1 1d       	adc	r26, r1
    2abc:	66 1f       	adc	r22, r22
    2abe:	82 9f       	mul	r24, r18
    2ac0:	22 27       	eor	r18, r18
    2ac2:	b0 0d       	add	r27, r0
    2ac4:	a1 1d       	adc	r26, r1
    2ac6:	62 1f       	adc	r22, r18
    2ac8:	73 9f       	mul	r23, r19
    2aca:	b0 0d       	add	r27, r0
    2acc:	a1 1d       	adc	r26, r1
    2ace:	62 1f       	adc	r22, r18
    2ad0:	83 9f       	mul	r24, r19
    2ad2:	a0 0d       	add	r26, r0
    2ad4:	61 1d       	adc	r22, r1
    2ad6:	22 1f       	adc	r18, r18
    2ad8:	74 9f       	mul	r23, r20
    2ada:	33 27       	eor	r19, r19
    2adc:	a0 0d       	add	r26, r0
    2ade:	61 1d       	adc	r22, r1
    2ae0:	23 1f       	adc	r18, r19
    2ae2:	84 9f       	mul	r24, r20
    2ae4:	60 0d       	add	r22, r0
    2ae6:	21 1d       	adc	r18, r1
    2ae8:	82 2f       	mov	r24, r18
    2aea:	76 2f       	mov	r23, r22
    2aec:	6a 2f       	mov	r22, r26
    2aee:	11 24       	eor	r1, r1
    2af0:	9f 57       	subi	r25, 0x7F	; 127
    2af2:	50 40       	sbci	r21, 0x00	; 0
    2af4:	9a f0       	brmi	.+38     	; 0x2b1c <__mulsf3_pse+0x88>
    2af6:	f1 f0       	breq	.+60     	; 0x2b34 <__mulsf3_pse+0xa0>
    2af8:	88 23       	and	r24, r24
    2afa:	4a f0       	brmi	.+18     	; 0x2b0e <__mulsf3_pse+0x7a>
    2afc:	ee 0f       	add	r30, r30
    2afe:	ff 1f       	adc	r31, r31
    2b00:	bb 1f       	adc	r27, r27
    2b02:	66 1f       	adc	r22, r22
    2b04:	77 1f       	adc	r23, r23
    2b06:	88 1f       	adc	r24, r24
    2b08:	91 50       	subi	r25, 0x01	; 1
    2b0a:	50 40       	sbci	r21, 0x00	; 0
    2b0c:	a9 f7       	brne	.-22     	; 0x2af8 <__mulsf3_pse+0x64>
    2b0e:	9e 3f       	cpi	r25, 0xFE	; 254
    2b10:	51 05       	cpc	r21, r1
    2b12:	80 f0       	brcs	.+32     	; 0x2b34 <__mulsf3_pse+0xa0>
    2b14:	0c 94 93 14 	jmp	0x2926	; 0x2926 <__fp_inf>
    2b18:	0c 94 de 14 	jmp	0x29bc	; 0x29bc <__fp_szero>
    2b1c:	5f 3f       	cpi	r21, 0xFF	; 255
    2b1e:	e4 f3       	brlt	.-8      	; 0x2b18 <__mulsf3_pse+0x84>
    2b20:	98 3e       	cpi	r25, 0xE8	; 232
    2b22:	d4 f3       	brlt	.-12     	; 0x2b18 <__mulsf3_pse+0x84>
    2b24:	86 95       	lsr	r24
    2b26:	77 95       	ror	r23
    2b28:	67 95       	ror	r22
    2b2a:	b7 95       	ror	r27
    2b2c:	f7 95       	ror	r31
    2b2e:	e7 95       	ror	r30
    2b30:	9f 5f       	subi	r25, 0xFF	; 255
    2b32:	c1 f7       	brne	.-16     	; 0x2b24 <__mulsf3_pse+0x90>
    2b34:	fe 2b       	or	r31, r30
    2b36:	88 0f       	add	r24, r24
    2b38:	91 1d       	adc	r25, r1
    2b3a:	96 95       	lsr	r25
    2b3c:	87 95       	ror	r24
    2b3e:	97 f9       	bld	r25, 7
    2b40:	08 95       	ret

00002b42 <__fp_mpack>:
    2b42:	9f 3f       	cpi	r25, 0xFF	; 255
    2b44:	31 f0       	breq	.+12     	; 0x2b52 <__fp_mpack_finite+0xc>

00002b46 <__fp_mpack_finite>:
    2b46:	91 50       	subi	r25, 0x01	; 1
    2b48:	20 f4       	brcc	.+8      	; 0x2b52 <__fp_mpack_finite+0xc>
    2b4a:	87 95       	ror	r24
    2b4c:	77 95       	ror	r23
    2b4e:	67 95       	ror	r22
    2b50:	b7 95       	ror	r27
    2b52:	88 0f       	add	r24, r24
    2b54:	91 1d       	adc	r25, r1
    2b56:	96 95       	lsr	r25
    2b58:	87 95       	ror	r24
    2b5a:	97 f9       	bld	r25, 7
    2b5c:	08 95       	ret

00002b5e <__fp_powser>:
    2b5e:	df 93       	push	r29
    2b60:	cf 93       	push	r28
    2b62:	1f 93       	push	r17
    2b64:	0f 93       	push	r16
    2b66:	ff 92       	push	r15
    2b68:	ef 92       	push	r14
    2b6a:	df 92       	push	r13
    2b6c:	7b 01       	movw	r14, r22
    2b6e:	8c 01       	movw	r16, r24
    2b70:	68 94       	set
    2b72:	06 c0       	rjmp	.+12     	; 0x2b80 <__fp_powser+0x22>
    2b74:	da 2e       	mov	r13, r26
    2b76:	ef 01       	movw	r28, r30
    2b78:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <__mulsf3x>
    2b7c:	fe 01       	movw	r30, r28
    2b7e:	e8 94       	clt
    2b80:	a5 91       	lpm	r26, Z+
    2b82:	25 91       	lpm	r18, Z+
    2b84:	35 91       	lpm	r19, Z+
    2b86:	45 91       	lpm	r20, Z+
    2b88:	55 91       	lpm	r21, Z+
    2b8a:	a6 f3       	brts	.-24     	; 0x2b74 <__fp_powser+0x16>
    2b8c:	ef 01       	movw	r28, r30
    2b8e:	0e 94 60 13 	call	0x26c0	; 0x26c0 <__addsf3x>
    2b92:	fe 01       	movw	r30, r28
    2b94:	97 01       	movw	r18, r14
    2b96:	a8 01       	movw	r20, r16
    2b98:	da 94       	dec	r13
    2b9a:	69 f7       	brne	.-38     	; 0x2b76 <__fp_powser+0x18>
    2b9c:	df 90       	pop	r13
    2b9e:	ef 90       	pop	r14
    2ba0:	ff 90       	pop	r15
    2ba2:	0f 91       	pop	r16
    2ba4:	1f 91       	pop	r17
    2ba6:	cf 91       	pop	r28
    2ba8:	df 91       	pop	r29
    2baa:	08 95       	ret

00002bac <memcpy>:
    2bac:	fb 01       	movw	r30, r22
    2bae:	dc 01       	movw	r26, r24
    2bb0:	02 c0       	rjmp	.+4      	; 0x2bb6 <memcpy+0xa>
    2bb2:	01 90       	ld	r0, Z+
    2bb4:	0d 92       	st	X+, r0
    2bb6:	41 50       	subi	r20, 0x01	; 1
    2bb8:	50 40       	sbci	r21, 0x00	; 0
    2bba:	d8 f7       	brcc	.-10     	; 0x2bb2 <memcpy+0x6>
    2bbc:	08 95       	ret

00002bbe <__itoa_ncheck>:
    2bbe:	bb 27       	eor	r27, r27
    2bc0:	4a 30       	cpi	r20, 0x0A	; 10
    2bc2:	31 f4       	brne	.+12     	; 0x2bd0 <__itoa_ncheck+0x12>
    2bc4:	99 23       	and	r25, r25
    2bc6:	22 f4       	brpl	.+8      	; 0x2bd0 <__itoa_ncheck+0x12>
    2bc8:	bd e2       	ldi	r27, 0x2D	; 45
    2bca:	90 95       	com	r25
    2bcc:	81 95       	neg	r24
    2bce:	9f 4f       	sbci	r25, 0xFF	; 255
    2bd0:	0c 94 eb 15 	jmp	0x2bd6	; 0x2bd6 <__utoa_common>

00002bd4 <__utoa_ncheck>:
    2bd4:	bb 27       	eor	r27, r27

00002bd6 <__utoa_common>:
    2bd6:	fb 01       	movw	r30, r22
    2bd8:	55 27       	eor	r21, r21
    2bda:	aa 27       	eor	r26, r26
    2bdc:	88 0f       	add	r24, r24
    2bde:	99 1f       	adc	r25, r25
    2be0:	aa 1f       	adc	r26, r26
    2be2:	a4 17       	cp	r26, r20
    2be4:	10 f0       	brcs	.+4      	; 0x2bea <__utoa_common+0x14>
    2be6:	a4 1b       	sub	r26, r20
    2be8:	83 95       	inc	r24
    2bea:	50 51       	subi	r21, 0x10	; 16
    2bec:	b9 f7       	brne	.-18     	; 0x2bdc <__utoa_common+0x6>
    2bee:	a0 5d       	subi	r26, 0xD0	; 208
    2bf0:	aa 33       	cpi	r26, 0x3A	; 58
    2bf2:	08 f0       	brcs	.+2      	; 0x2bf6 <__utoa_common+0x20>
    2bf4:	a9 5d       	subi	r26, 0xD9	; 217
    2bf6:	a1 93       	st	Z+, r26
    2bf8:	00 97       	sbiw	r24, 0x00	; 0
    2bfa:	79 f7       	brne	.-34     	; 0x2bda <__utoa_common+0x4>
    2bfc:	b1 11       	cpse	r27, r1
    2bfe:	b1 93       	st	Z+, r27
    2c00:	11 92       	st	Z+, r1
    2c02:	cb 01       	movw	r24, r22
    2c04:	0c 94 04 16 	jmp	0x2c08	; 0x2c08 <strrev>

00002c08 <strrev>:
    2c08:	dc 01       	movw	r26, r24
    2c0a:	fc 01       	movw	r30, r24
    2c0c:	67 2f       	mov	r22, r23
    2c0e:	71 91       	ld	r23, Z+
    2c10:	77 23       	and	r23, r23
    2c12:	e1 f7       	brne	.-8      	; 0x2c0c <strrev+0x4>
    2c14:	32 97       	sbiw	r30, 0x02	; 2
    2c16:	04 c0       	rjmp	.+8      	; 0x2c20 <strrev+0x18>
    2c18:	7c 91       	ld	r23, X
    2c1a:	6d 93       	st	X+, r22
    2c1c:	70 83       	st	Z, r23
    2c1e:	62 91       	ld	r22, -Z
    2c20:	ae 17       	cp	r26, r30
    2c22:	bf 07       	cpc	r27, r31
    2c24:	c8 f3       	brcs	.-14     	; 0x2c18 <strrev+0x10>
    2c26:	08 95       	ret

00002c28 <_exit>:
    2c28:	f8 94       	cli

00002c2a <__stop_program>:
    2c2a:	ff cf       	rjmp	.-2      	; 0x2c2a <__stop_program>
