
FireAlarm_System.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002be6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e2  00800060  00002be6  00002c7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000004fc  00800142  00800142  00002d5c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002d5c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002d8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b8  00000000  00000000  00002dc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006936  00000000  00000000  00003380  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001930  00000000  00000000  00009cb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000039bc  00000000  00000000  0000b5e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ee8  00000000  00000000  0000efa4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000021db  00000000  00000000  0000fe8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000557f  00000000  00000000  00012067  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000508  00000000  00000000  000175e6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       8:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      10:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      14:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      18:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      24:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      28:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      2c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      30:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      34:	0c 94 91 12 	jmp	0x2522	; 0x2522 <__vector_13>
      38:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      3c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      40:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      44:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      48:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      4c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      50:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      54:	08 00       	.word	0x0008	; ????
      56:	00 00       	nop
      58:	be 92       	st	-X, r11
      5a:	24 49       	sbci	r18, 0x94	; 148
      5c:	12 3e       	cpi	r17, 0xE2	; 226
      5e:	ab aa       	std	Y+51, r10	; 0x33
      60:	aa 2a       	or	r10, r26
      62:	be cd       	rjmp	.-1156   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
      64:	cc cc       	rjmp	.-1640   	; 0xfffff9fe <__eeprom_end+0xff7ef9fe>
      66:	4c 3e       	cpi	r20, 0xEC	; 236
      68:	00 00       	nop
      6a:	00 80       	ld	r0, Z
      6c:	be ab       	std	Y+54, r27	; 0x36
      6e:	aa aa       	std	Y+50, r10	; 0x32
      70:	aa 3e       	cpi	r26, 0xEA	; 234
      72:	00 00       	nop
      74:	00 00       	nop
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	00 00       	nop
      7e:	00 00       	nop
      80:	00 08       	sbc	r0, r0
      82:	41 78       	andi	r20, 0x81	; 129
      84:	d3 bb       	out	0x13, r29	; 19
      86:	43 87       	std	Z+11, r20	; 0x0b
      88:	d1 13       	cpse	r29, r17
      8a:	3d 19       	sub	r19, r13
      8c:	0e 3c       	cpi	r16, 0xCE	; 206
      8e:	c3 bd       	out	0x23, r28	; 35
      90:	42 82       	std	Z+2, r4	; 0x02
      92:	ad 2b       	or	r26, r29
      94:	3e 68       	ori	r19, 0x8E	; 142
      96:	ec 82       	std	Y+4, r14	; 0x04
      98:	76 be       	out	0x36, r7	; 54
      9a:	d9 8f       	std	Y+25, r29	; 0x19
      9c:	e1 a9       	ldd	r30, Z+49	; 0x31
      9e:	3e 4c       	sbci	r19, 0xCE	; 206
      a0:	80 ef       	ldi	r24, 0xF0	; 240
      a2:	ff be       	out	0x3f, r15	; 63
      a4:	01 c4       	rjmp	.+2050   	; 0x8a8 <prvUnlockQueue+0x44>
      a6:	ff 7f       	andi	r31, 0xFF	; 255
      a8:	3f 00       	.word	0x003f	; ????
      aa:	00 00       	nop
	...

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf e5       	ldi	r28, 0x5F	; 95
      b4:	d8 e0       	ldi	r29, 0x08	; 8
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_copy_data>:
      ba:	11 e0       	ldi	r17, 0x01	; 1
      bc:	a0 e6       	ldi	r26, 0x60	; 96
      be:	b0 e0       	ldi	r27, 0x00	; 0
      c0:	e6 ee       	ldi	r30, 0xE6	; 230
      c2:	fb e2       	ldi	r31, 0x2B	; 43
      c4:	02 c0       	rjmp	.+4      	; 0xca <__do_copy_data+0x10>
      c6:	05 90       	lpm	r0, Z+
      c8:	0d 92       	st	X+, r0
      ca:	a2 34       	cpi	r26, 0x42	; 66
      cc:	b1 07       	cpc	r27, r17
      ce:	d9 f7       	brne	.-10     	; 0xc6 <__do_copy_data+0xc>

000000d0 <__do_clear_bss>:
      d0:	26 e0       	ldi	r18, 0x06	; 6
      d2:	a2 e4       	ldi	r26, 0x42	; 66
      d4:	b1 e0       	ldi	r27, 0x01	; 1
      d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
      d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
      da:	ae 33       	cpi	r26, 0x3E	; 62
      dc:	b2 07       	cpc	r27, r18
      de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>
      e0:	0e 94 0e 10 	call	0x201c	; 0x201c <main>
      e4:	0c 94 f1 15 	jmp	0x2be2	; 0x2be2 <_exit>

000000e8 <__bad_interrupt>:
      e8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ec <prvTestWaitCondition>:
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
      ec:	41 11       	cpse	r20, r1
      ee:	06 c0       	rjmp	.+12     	; 0xfc <prvTestWaitCondition+0x10>
      f0:	68 23       	and	r22, r24
      f2:	79 23       	and	r23, r25
      f4:	67 2b       	or	r22, r23
      f6:	49 f4       	brne	.+18     	; 0x10a <prvTestWaitCondition+0x1e>
      f8:	80 e0       	ldi	r24, 0x00	; 0
      fa:	08 95       	ret
      fc:	86 23       	and	r24, r22
      fe:	97 23       	and	r25, r23
     100:	68 17       	cp	r22, r24
     102:	79 07       	cpc	r23, r25
     104:	21 f0       	breq	.+8      	; 0x10e <prvTestWaitCondition+0x22>
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret
     10a:	81 e0       	ldi	r24, 0x01	; 1
     10c:	08 95       	ret
     10e:	81 e0       	ldi	r24, 0x01	; 1
     110:	08 95       	ret

00000112 <xEventGroupCreate>:
     112:	cf 93       	push	r28
     114:	df 93       	push	r29
     116:	8b e0       	ldi	r24, 0x0B	; 11
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     11e:	ec 01       	movw	r28, r24
     120:	00 97       	sbiw	r24, 0x00	; 0
     122:	31 f0       	breq	.+12     	; 0x130 <xEventGroupCreate+0x1e>
     124:	fc 01       	movw	r30, r24
     126:	11 92       	st	Z+, r1
     128:	11 92       	st	Z+, r1
     12a:	cf 01       	movw	r24, r30
     12c:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     130:	ce 01       	movw	r24, r28
     132:	df 91       	pop	r29
     134:	cf 91       	pop	r28
     136:	08 95       	ret

00000138 <xEventGroupWaitBits>:
     138:	af 92       	push	r10
     13a:	bf 92       	push	r11
     13c:	cf 92       	push	r12
     13e:	df 92       	push	r13
     140:	ef 92       	push	r14
     142:	ff 92       	push	r15
     144:	0f 93       	push	r16
     146:	1f 93       	push	r17
     148:	cf 93       	push	r28
     14a:	df 93       	push	r29
     14c:	7c 01       	movw	r14, r24
     14e:	5b 01       	movw	r10, r22
     150:	c4 2e       	mov	r12, r20
     152:	d2 2e       	mov	r13, r18
     154:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
     158:	f7 01       	movw	r30, r14
     15a:	c0 81       	ld	r28, Z
     15c:	d1 81       	ldd	r29, Z+1	; 0x01
     15e:	4d 2d       	mov	r20, r13
     160:	b5 01       	movw	r22, r10
     162:	ce 01       	movw	r24, r28
     164:	0e 94 76 00 	call	0xec	; 0xec <prvTestWaitCondition>
     168:	88 23       	and	r24, r24
     16a:	69 f0       	breq	.+26     	; 0x186 <xEventGroupWaitBits+0x4e>
     16c:	cc 20       	and	r12, r12
     16e:	09 f1       	breq	.+66     	; 0x1b2 <xEventGroupWaitBits+0x7a>
     170:	c5 01       	movw	r24, r10
     172:	80 95       	com	r24
     174:	90 95       	com	r25
     176:	8c 23       	and	r24, r28
     178:	9d 23       	and	r25, r29
     17a:	f7 01       	movw	r30, r14
     17c:	91 83       	std	Z+1, r25	; 0x01
     17e:	80 83       	st	Z, r24
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	10 e0       	ldi	r17, 0x00	; 0
     184:	18 c0       	rjmp	.+48     	; 0x1b6 <xEventGroupWaitBits+0x7e>
     186:	01 15       	cp	r16, r1
     188:	11 05       	cpc	r17, r1
     18a:	a9 f0       	breq	.+42     	; 0x1b6 <xEventGroupWaitBits+0x7e>
     18c:	c1 10       	cpse	r12, r1
     18e:	03 c0       	rjmp	.+6      	; 0x196 <xEventGroupWaitBits+0x5e>
     190:	60 e0       	ldi	r22, 0x00	; 0
     192:	70 e0       	ldi	r23, 0x00	; 0
     194:	02 c0       	rjmp	.+4      	; 0x19a <xEventGroupWaitBits+0x62>
     196:	60 e0       	ldi	r22, 0x00	; 0
     198:	71 e0       	ldi	r23, 0x01	; 1
     19a:	d1 10       	cpse	r13, r1
     19c:	74 60       	ori	r23, 0x04	; 4
     19e:	6a 29       	or	r22, r10
     1a0:	7b 29       	or	r23, r11
     1a2:	a8 01       	movw	r20, r16
     1a4:	c7 01       	movw	r24, r14
     1a6:	02 96       	adiw	r24, 0x02	; 2
     1a8:	0e 94 2f 0a 	call	0x145e	; 0x145e <vTaskPlaceOnUnorderedEventList>
     1ac:	c0 e0       	ldi	r28, 0x00	; 0
     1ae:	d0 e0       	ldi	r29, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <xEventGroupWaitBits+0x7e>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
     1b6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     1ba:	01 2b       	or	r16, r17
     1bc:	19 f1       	breq	.+70     	; 0x204 <xEventGroupWaitBits+0xcc>
     1be:	81 11       	cpse	r24, r1
     1c0:	02 c0       	rjmp	.+4      	; 0x1c6 <xEventGroupWaitBits+0x8e>
     1c2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     1c6:	0e 94 b8 0b 	call	0x1770	; 0x1770 <uxTaskResetEventItemValue>
     1ca:	ec 01       	movw	r28, r24
     1cc:	91 fd       	sbrc	r25, 1
     1ce:	19 c0       	rjmp	.+50     	; 0x202 <xEventGroupWaitBits+0xca>
     1d0:	0f b6       	in	r0, 0x3f	; 63
     1d2:	f8 94       	cli
     1d4:	0f 92       	push	r0
     1d6:	f7 01       	movw	r30, r14
     1d8:	c0 81       	ld	r28, Z
     1da:	d1 81       	ldd	r29, Z+1	; 0x01
     1dc:	4d 2d       	mov	r20, r13
     1de:	b5 01       	movw	r22, r10
     1e0:	ce 01       	movw	r24, r28
     1e2:	0e 94 76 00 	call	0xec	; 0xec <prvTestWaitCondition>
     1e6:	88 23       	and	r24, r24
     1e8:	51 f0       	breq	.+20     	; 0x1fe <xEventGroupWaitBits+0xc6>
     1ea:	cc 20       	and	r12, r12
     1ec:	41 f0       	breq	.+16     	; 0x1fe <xEventGroupWaitBits+0xc6>
     1ee:	b5 01       	movw	r22, r10
     1f0:	60 95       	com	r22
     1f2:	70 95       	com	r23
     1f4:	6c 23       	and	r22, r28
     1f6:	7d 23       	and	r23, r29
     1f8:	f7 01       	movw	r30, r14
     1fa:	71 83       	std	Z+1, r23	; 0x01
     1fc:	60 83       	st	Z, r22
     1fe:	0f 90       	pop	r0
     200:	0f be       	out	0x3f, r0	; 63
     202:	dd 27       	eor	r29, r29
     204:	ce 01       	movw	r24, r28
     206:	df 91       	pop	r29
     208:	cf 91       	pop	r28
     20a:	1f 91       	pop	r17
     20c:	0f 91       	pop	r16
     20e:	ff 90       	pop	r15
     210:	ef 90       	pop	r14
     212:	df 90       	pop	r13
     214:	cf 90       	pop	r12
     216:	bf 90       	pop	r11
     218:	af 90       	pop	r10
     21a:	08 95       	ret

0000021c <xEventGroupClearBits>:
     21c:	fc 01       	movw	r30, r24
     21e:	0f b6       	in	r0, 0x3f	; 63
     220:	f8 94       	cli
     222:	0f 92       	push	r0
     224:	80 81       	ld	r24, Z
     226:	91 81       	ldd	r25, Z+1	; 0x01
     228:	60 95       	com	r22
     22a:	70 95       	com	r23
     22c:	68 23       	and	r22, r24
     22e:	79 23       	and	r23, r25
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	0f 90       	pop	r0
     236:	0f be       	out	0x3f, r0	; 63
     238:	08 95       	ret

0000023a <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     23a:	cf 92       	push	r12
     23c:	df 92       	push	r13
     23e:	ef 92       	push	r14
     240:	ff 92       	push	r15
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	cf 93       	push	r28
     248:	df 93       	push	r29
     24a:	7c 01       	movw	r14, r24
     24c:	8b 01       	movw	r16, r22
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     24e:	ec 01       	movw	r28, r24
     250:	25 96       	adiw	r28, 0x05	; 5
	vTaskSuspendAll();
     252:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     256:	d7 01       	movw	r26, r14
     258:	17 96       	adiw	r26, 0x07	; 7
     25a:	ed 91       	ld	r30, X+
     25c:	fc 91       	ld	r31, X
     25e:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     260:	8d 91       	ld	r24, X+
     262:	9c 91       	ld	r25, X
     264:	11 97       	sbiw	r26, 0x01	; 1
     266:	08 2b       	or	r16, r24
     268:	19 2b       	or	r17, r25
     26a:	0d 93       	st	X+, r16
     26c:	1c 93       	st	X, r17
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     26e:	00 e0       	ldi	r16, 0x00	; 0
     270:	10 e0       	ldi	r17, 0x00	; 0

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     272:	2d c0       	rjmp	.+90     	; 0x2ce <xEventGroupSetBits+0x94>
		{
			pxNext = listGET_NEXT( pxListItem );
     274:	c2 80       	ldd	r12, Z+2	; 0x02
     276:	d3 80       	ldd	r13, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     278:	80 81       	ld	r24, Z
     27a:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     27c:	9c 01       	movw	r18, r24
     27e:	33 27       	eor	r19, r19

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     280:	92 fd       	sbrc	r25, 2
     282:	09 c0       	rjmp	.+18     	; 0x296 <xEventGroupSetBits+0x5c>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     284:	d7 01       	movw	r26, r14
     286:	4d 91       	ld	r20, X+
     288:	5c 91       	ld	r21, X
     28a:	42 23       	and	r20, r18
     28c:	53 23       	and	r21, r19
     28e:	45 2b       	or	r20, r21
     290:	61 f4       	brne	.+24     	; 0x2aa <xEventGroupSetBits+0x70>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     292:	40 e0       	ldi	r20, 0x00	; 0
     294:	0d c0       	rjmp	.+26     	; 0x2b0 <xEventGroupSetBits+0x76>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     296:	d7 01       	movw	r26, r14
     298:	4d 91       	ld	r20, X+
     29a:	5c 91       	ld	r21, X
     29c:	42 23       	and	r20, r18
     29e:	53 23       	and	r21, r19
     2a0:	24 17       	cp	r18, r20
     2a2:	35 07       	cpc	r19, r21
     2a4:	21 f0       	breq	.+8      	; 0x2ae <xEventGroupSetBits+0x74>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     2a6:	40 e0       	ldi	r20, 0x00	; 0
     2a8:	03 c0       	rjmp	.+6      	; 0x2b0 <xEventGroupSetBits+0x76>
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     2aa:	41 e0       	ldi	r20, 0x01	; 1
     2ac:	01 c0       	rjmp	.+2      	; 0x2b0 <xEventGroupSetBits+0x76>
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     2ae:	41 e0       	ldi	r20, 0x01	; 1
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     2b0:	44 23       	and	r20, r20
     2b2:	59 f0       	breq	.+22     	; 0x2ca <xEventGroupSetBits+0x90>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     2b4:	90 ff       	sbrs	r25, 0
     2b6:	02 c0       	rjmp	.+4      	; 0x2bc <xEventGroupSetBits+0x82>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     2b8:	02 2b       	or	r16, r18
     2ba:	13 2b       	or	r17, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     2bc:	d7 01       	movw	r26, r14
     2be:	6d 91       	ld	r22, X+
     2c0:	7c 91       	ld	r23, X
     2c2:	72 60       	ori	r23, 0x02	; 2
     2c4:	cf 01       	movw	r24, r30
     2c6:	0e 94 9b 0a 	call	0x1536	; 0x1536 <xTaskRemoveFromUnorderedEventList>
		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
			xMatchFound = pdFALSE;
     2ca:	ec 2d       	mov	r30, r12
     2cc:	fd 2d       	mov	r31, r13

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     2ce:	ec 17       	cp	r30, r28
     2d0:	fd 07       	cpc	r31, r29
     2d2:	81 f6       	brne	.-96     	; 0x274 <xEventGroupSetBits+0x3a>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     2d4:	00 95       	com	r16
     2d6:	10 95       	com	r17
     2d8:	f7 01       	movw	r30, r14
     2da:	80 81       	ld	r24, Z
     2dc:	91 81       	ldd	r25, Z+1	; 0x01
     2de:	08 23       	and	r16, r24
     2e0:	19 23       	and	r17, r25
     2e2:	11 83       	std	Z+1, r17	; 0x01
     2e4:	00 83       	st	Z, r16
	}
	( void ) xTaskResumeAll();
     2e6:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     2ea:	d7 01       	movw	r26, r14
     2ec:	8d 91       	ld	r24, X+
     2ee:	9c 91       	ld	r25, X
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	1f 91       	pop	r17
     2f6:	0f 91       	pop	r16
     2f8:	ff 90       	pop	r15
     2fa:	ef 90       	pop	r14
     2fc:	df 90       	pop	r13
     2fe:	cf 90       	pop	r12
     300:	08 95       	ret

00000302 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     308:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     30c:	80 91 42 01 	lds	r24, 0x0142	; 0x800142 <__data_end>
     310:	90 91 43 01 	lds	r25, 0x0143	; 0x800143 <__data_end+0x1>
     314:	89 2b       	or	r24, r25
     316:	31 f4       	brne	.+12     	; 0x324 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     318:	87 e4       	ldi	r24, 0x47	; 71
     31a:	91 e0       	ldi	r25, 0x01	; 1
     31c:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <__data_end+0x1>
     320:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     324:	20 91 44 01 	lds	r18, 0x0144	; 0x800144 <xNextFreeByte>
     328:	30 91 45 01 	lds	r19, 0x0145	; 0x800145 <xNextFreeByte+0x1>
     32c:	c9 01       	movw	r24, r18
     32e:	8c 0f       	add	r24, r28
     330:	9d 1f       	adc	r25, r29
     332:	8d 37       	cpi	r24, 0x7D	; 125
     334:	44 e0       	ldi	r20, 0x04	; 4
     336:	94 07       	cpc	r25, r20
     338:	70 f4       	brcc	.+28     	; 0x356 <pvPortMalloc+0x54>
     33a:	28 17       	cp	r18, r24
     33c:	39 07       	cpc	r19, r25
     33e:	70 f4       	brcc	.+28     	; 0x35c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     340:	c0 91 42 01 	lds	r28, 0x0142	; 0x800142 <__data_end>
     344:	d0 91 43 01 	lds	r29, 0x0143	; 0x800143 <__data_end+0x1>
     348:	c2 0f       	add	r28, r18
     34a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     34c:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <xNextFreeByte+0x1>
     350:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <xNextFreeByte>
     354:	05 c0       	rjmp	.+10     	; 0x360 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     356:	c0 e0       	ldi	r28, 0x00	; 0
     358:	d0 e0       	ldi	r29, 0x00	; 0
     35a:	02 c0       	rjmp	.+4      	; 0x360 <pvPortMalloc+0x5e>
     35c:	c0 e0       	ldi	r28, 0x00	; 0
     35e:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     360:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     364:	ce 01       	movw	r24, r28
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     36c:	08 95       	ret

0000036e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     36e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     370:	03 96       	adiw	r24, 0x03	; 3
     372:	92 83       	std	Z+2, r25	; 0x02
     374:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     376:	2f ef       	ldi	r18, 0xFF	; 255
     378:	3f ef       	ldi	r19, 0xFF	; 255
     37a:	34 83       	std	Z+4, r19	; 0x04
     37c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     37e:	96 83       	std	Z+6, r25	; 0x06
     380:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     382:	90 87       	std	Z+8, r25	; 0x08
     384:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     386:	10 82       	st	Z, r1
     388:	08 95       	ret

0000038a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     38a:	fc 01       	movw	r30, r24
     38c:	11 86       	std	Z+9, r1	; 0x09
     38e:	10 86       	std	Z+8, r1	; 0x08
     390:	08 95       	ret

00000392 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     392:	cf 93       	push	r28
     394:	df 93       	push	r29
     396:	9c 01       	movw	r18, r24
     398:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     39a:	dc 01       	movw	r26, r24
     39c:	11 96       	adiw	r26, 0x01	; 1
     39e:	cd 91       	ld	r28, X+
     3a0:	dc 91       	ld	r29, X
     3a2:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3a4:	d3 83       	std	Z+3, r29	; 0x03
     3a6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3a8:	8c 81       	ldd	r24, Y+4	; 0x04
     3aa:	9d 81       	ldd	r25, Y+5	; 0x05
     3ac:	95 83       	std	Z+5, r25	; 0x05
     3ae:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3b0:	8c 81       	ldd	r24, Y+4	; 0x04
     3b2:	9d 81       	ldd	r25, Y+5	; 0x05
     3b4:	dc 01       	movw	r26, r24
     3b6:	13 96       	adiw	r26, 0x03	; 3
     3b8:	7c 93       	st	X, r23
     3ba:	6e 93       	st	-X, r22
     3bc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     3be:	7d 83       	std	Y+5, r23	; 0x05
     3c0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3c2:	31 87       	std	Z+9, r19	; 0x09
     3c4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     3c6:	f9 01       	movw	r30, r18
     3c8:	80 81       	ld	r24, Z
     3ca:	8f 5f       	subi	r24, 0xFF	; 255
     3cc:	80 83       	st	Z, r24
}
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	08 95       	ret

000003d4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3d4:	cf 93       	push	r28
     3d6:	df 93       	push	r29
     3d8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     3da:	48 81       	ld	r20, Y
     3dc:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3de:	4f 3f       	cpi	r20, 0xFF	; 255
     3e0:	2f ef       	ldi	r18, 0xFF	; 255
     3e2:	52 07       	cpc	r21, r18
     3e4:	21 f4       	brne	.+8      	; 0x3ee <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3e6:	fc 01       	movw	r30, r24
     3e8:	a7 81       	ldd	r26, Z+7	; 0x07
     3ea:	b0 85       	ldd	r27, Z+8	; 0x08
     3ec:	0d c0       	rjmp	.+26     	; 0x408 <__EEPROM_REGION_LENGTH__+0x8>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3ee:	dc 01       	movw	r26, r24
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	01 c0       	rjmp	.+2      	; 0x3f6 <vListInsert+0x22>
     3f4:	df 01       	movw	r26, r30
     3f6:	12 96       	adiw	r26, 0x02	; 2
     3f8:	ed 91       	ld	r30, X+
     3fa:	fc 91       	ld	r31, X
     3fc:	13 97       	sbiw	r26, 0x03	; 3
     3fe:	20 81       	ld	r18, Z
     400:	31 81       	ldd	r19, Z+1	; 0x01
     402:	42 17       	cp	r20, r18
     404:	53 07       	cpc	r21, r19
     406:	b0 f7       	brcc	.-20     	; 0x3f4 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     408:	12 96       	adiw	r26, 0x02	; 2
     40a:	ed 91       	ld	r30, X+
     40c:	fc 91       	ld	r31, X
     40e:	13 97       	sbiw	r26, 0x03	; 3
     410:	fb 83       	std	Y+3, r31	; 0x03
     412:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     414:	d5 83       	std	Z+5, r29	; 0x05
     416:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     418:	bd 83       	std	Y+5, r27	; 0x05
     41a:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     41c:	13 96       	adiw	r26, 0x03	; 3
     41e:	dc 93       	st	X, r29
     420:	ce 93       	st	-X, r28
     422:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     424:	99 87       	std	Y+9, r25	; 0x09
     426:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     428:	fc 01       	movw	r30, r24
     42a:	20 81       	ld	r18, Z
     42c:	2f 5f       	subi	r18, 0xFF	; 255
     42e:	20 83       	st	Z, r18
}
     430:	df 91       	pop	r29
     432:	cf 91       	pop	r28
     434:	08 95       	ret

00000436 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     43c:	a0 85       	ldd	r26, Z+8	; 0x08
     43e:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     440:	c2 81       	ldd	r28, Z+2	; 0x02
     442:	d3 81       	ldd	r29, Z+3	; 0x03
     444:	84 81       	ldd	r24, Z+4	; 0x04
     446:	95 81       	ldd	r25, Z+5	; 0x05
     448:	9d 83       	std	Y+5, r25	; 0x05
     44a:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     44c:	c4 81       	ldd	r28, Z+4	; 0x04
     44e:	d5 81       	ldd	r29, Z+5	; 0x05
     450:	82 81       	ldd	r24, Z+2	; 0x02
     452:	93 81       	ldd	r25, Z+3	; 0x03
     454:	9b 83       	std	Y+3, r25	; 0x03
     456:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     458:	11 96       	adiw	r26, 0x01	; 1
     45a:	8d 91       	ld	r24, X+
     45c:	9c 91       	ld	r25, X
     45e:	12 97       	sbiw	r26, 0x02	; 2
     460:	e8 17       	cp	r30, r24
     462:	f9 07       	cpc	r31, r25
     464:	31 f4       	brne	.+12     	; 0x472 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     466:	84 81       	ldd	r24, Z+4	; 0x04
     468:	95 81       	ldd	r25, Z+5	; 0x05
     46a:	12 96       	adiw	r26, 0x02	; 2
     46c:	9c 93       	st	X, r25
     46e:	8e 93       	st	-X, r24
     470:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     472:	11 86       	std	Z+9, r1	; 0x09
     474:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     476:	8c 91       	ld	r24, X
     478:	81 50       	subi	r24, 0x01	; 1
     47a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     482:	1b bc       	out	0x2b, r1	; 43
     484:	8c e7       	ldi	r24, 0x7C	; 124
     486:	8a bd       	out	0x2a, r24	; 42
     488:	8b e0       	ldi	r24, 0x0B	; 11
     48a:	8e bd       	out	0x2e, r24	; 46
     48c:	89 b7       	in	r24, 0x39	; 57
     48e:	80 61       	ori	r24, 0x10	; 16
     490:	89 bf       	out	0x39, r24	; 57
     492:	08 95       	ret

00000494 <pxPortInitialiseStack>:
     494:	31 e1       	ldi	r19, 0x11	; 17
     496:	fc 01       	movw	r30, r24
     498:	30 83       	st	Z, r19
     49a:	31 97       	sbiw	r30, 0x01	; 1
     49c:	22 e2       	ldi	r18, 0x22	; 34
     49e:	20 83       	st	Z, r18
     4a0:	31 97       	sbiw	r30, 0x01	; 1
     4a2:	a3 e3       	ldi	r26, 0x33	; 51
     4a4:	a0 83       	st	Z, r26
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	60 83       	st	Z, r22
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	70 83       	st	Z, r23
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	10 82       	st	Z, r1
     4b2:	31 97       	sbiw	r30, 0x01	; 1
     4b4:	60 e8       	ldi	r22, 0x80	; 128
     4b6:	60 83       	st	Z, r22
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	10 82       	st	Z, r1
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	62 e0       	ldi	r22, 0x02	; 2
     4c0:	60 83       	st	Z, r22
     4c2:	31 97       	sbiw	r30, 0x01	; 1
     4c4:	63 e0       	ldi	r22, 0x03	; 3
     4c6:	60 83       	st	Z, r22
     4c8:	31 97       	sbiw	r30, 0x01	; 1
     4ca:	64 e0       	ldi	r22, 0x04	; 4
     4cc:	60 83       	st	Z, r22
     4ce:	31 97       	sbiw	r30, 0x01	; 1
     4d0:	65 e0       	ldi	r22, 0x05	; 5
     4d2:	60 83       	st	Z, r22
     4d4:	31 97       	sbiw	r30, 0x01	; 1
     4d6:	66 e0       	ldi	r22, 0x06	; 6
     4d8:	60 83       	st	Z, r22
     4da:	31 97       	sbiw	r30, 0x01	; 1
     4dc:	67 e0       	ldi	r22, 0x07	; 7
     4de:	60 83       	st	Z, r22
     4e0:	31 97       	sbiw	r30, 0x01	; 1
     4e2:	68 e0       	ldi	r22, 0x08	; 8
     4e4:	60 83       	st	Z, r22
     4e6:	31 97       	sbiw	r30, 0x01	; 1
     4e8:	69 e0       	ldi	r22, 0x09	; 9
     4ea:	60 83       	st	Z, r22
     4ec:	31 97       	sbiw	r30, 0x01	; 1
     4ee:	60 e1       	ldi	r22, 0x10	; 16
     4f0:	60 83       	st	Z, r22
     4f2:	31 97       	sbiw	r30, 0x01	; 1
     4f4:	30 83       	st	Z, r19
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	32 e1       	ldi	r19, 0x12	; 18
     4fa:	30 83       	st	Z, r19
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	33 e1       	ldi	r19, 0x13	; 19
     500:	30 83       	st	Z, r19
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	34 e1       	ldi	r19, 0x14	; 20
     506:	30 83       	st	Z, r19
     508:	31 97       	sbiw	r30, 0x01	; 1
     50a:	35 e1       	ldi	r19, 0x15	; 21
     50c:	30 83       	st	Z, r19
     50e:	31 97       	sbiw	r30, 0x01	; 1
     510:	36 e1       	ldi	r19, 0x16	; 22
     512:	30 83       	st	Z, r19
     514:	31 97       	sbiw	r30, 0x01	; 1
     516:	37 e1       	ldi	r19, 0x17	; 23
     518:	30 83       	st	Z, r19
     51a:	31 97       	sbiw	r30, 0x01	; 1
     51c:	38 e1       	ldi	r19, 0x18	; 24
     51e:	30 83       	st	Z, r19
     520:	31 97       	sbiw	r30, 0x01	; 1
     522:	39 e1       	ldi	r19, 0x19	; 25
     524:	30 83       	st	Z, r19
     526:	31 97       	sbiw	r30, 0x01	; 1
     528:	30 e2       	ldi	r19, 0x20	; 32
     52a:	30 83       	st	Z, r19
     52c:	31 97       	sbiw	r30, 0x01	; 1
     52e:	31 e2       	ldi	r19, 0x21	; 33
     530:	30 83       	st	Z, r19
     532:	31 97       	sbiw	r30, 0x01	; 1
     534:	20 83       	st	Z, r18
     536:	31 97       	sbiw	r30, 0x01	; 1
     538:	23 e2       	ldi	r18, 0x23	; 35
     53a:	20 83       	st	Z, r18
     53c:	31 97       	sbiw	r30, 0x01	; 1
     53e:	40 83       	st	Z, r20
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	50 83       	st	Z, r21
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	26 e2       	ldi	r18, 0x26	; 38
     548:	20 83       	st	Z, r18
     54a:	31 97       	sbiw	r30, 0x01	; 1
     54c:	27 e2       	ldi	r18, 0x27	; 39
     54e:	20 83       	st	Z, r18
     550:	31 97       	sbiw	r30, 0x01	; 1
     552:	28 e2       	ldi	r18, 0x28	; 40
     554:	20 83       	st	Z, r18
     556:	31 97       	sbiw	r30, 0x01	; 1
     558:	29 e2       	ldi	r18, 0x29	; 41
     55a:	20 83       	st	Z, r18
     55c:	31 97       	sbiw	r30, 0x01	; 1
     55e:	20 e3       	ldi	r18, 0x30	; 48
     560:	20 83       	st	Z, r18
     562:	31 97       	sbiw	r30, 0x01	; 1
     564:	21 e3       	ldi	r18, 0x31	; 49
     566:	20 83       	st	Z, r18
     568:	86 97       	sbiw	r24, 0x26	; 38
     56a:	08 95       	ret

0000056c <xPortStartScheduler>:
     56c:	0e 94 41 02 	call	0x482	; 0x482 <prvSetupTimerInterrupt>
     570:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
     574:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     578:	cd 91       	ld	r28, X+
     57a:	cd bf       	out	0x3d, r28	; 61
     57c:	dd 91       	ld	r29, X+
     57e:	de bf       	out	0x3e, r29	; 62
     580:	ff 91       	pop	r31
     582:	ef 91       	pop	r30
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	bf 91       	pop	r27
     58a:	af 91       	pop	r26
     58c:	9f 91       	pop	r25
     58e:	8f 91       	pop	r24
     590:	7f 91       	pop	r23
     592:	6f 91       	pop	r22
     594:	5f 91       	pop	r21
     596:	4f 91       	pop	r20
     598:	3f 91       	pop	r19
     59a:	2f 91       	pop	r18
     59c:	1f 91       	pop	r17
     59e:	0f 91       	pop	r16
     5a0:	ff 90       	pop	r15
     5a2:	ef 90       	pop	r14
     5a4:	df 90       	pop	r13
     5a6:	cf 90       	pop	r12
     5a8:	bf 90       	pop	r11
     5aa:	af 90       	pop	r10
     5ac:	9f 90       	pop	r9
     5ae:	8f 90       	pop	r8
     5b0:	7f 90       	pop	r7
     5b2:	6f 90       	pop	r6
     5b4:	5f 90       	pop	r5
     5b6:	4f 90       	pop	r4
     5b8:	3f 90       	pop	r3
     5ba:	2f 90       	pop	r2
     5bc:	1f 90       	pop	r1
     5be:	0f 90       	pop	r0
     5c0:	0f be       	out	0x3f, r0	; 63
     5c2:	0f 90       	pop	r0
     5c4:	08 95       	ret
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	08 95       	ret

000005ca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5ca:	0f 92       	push	r0
     5cc:	0f b6       	in	r0, 0x3f	; 63
     5ce:	f8 94       	cli
     5d0:	0f 92       	push	r0
     5d2:	1f 92       	push	r1
     5d4:	11 24       	eor	r1, r1
     5d6:	2f 92       	push	r2
     5d8:	3f 92       	push	r3
     5da:	4f 92       	push	r4
     5dc:	5f 92       	push	r5
     5de:	6f 92       	push	r6
     5e0:	7f 92       	push	r7
     5e2:	8f 92       	push	r8
     5e4:	9f 92       	push	r9
     5e6:	af 92       	push	r10
     5e8:	bf 92       	push	r11
     5ea:	cf 92       	push	r12
     5ec:	df 92       	push	r13
     5ee:	ef 92       	push	r14
     5f0:	ff 92       	push	r15
     5f2:	0f 93       	push	r16
     5f4:	1f 93       	push	r17
     5f6:	2f 93       	push	r18
     5f8:	3f 93       	push	r19
     5fa:	4f 93       	push	r20
     5fc:	5f 93       	push	r21
     5fe:	6f 93       	push	r22
     600:	7f 93       	push	r23
     602:	8f 93       	push	r24
     604:	9f 93       	push	r25
     606:	af 93       	push	r26
     608:	bf 93       	push	r27
     60a:	cf 93       	push	r28
     60c:	df 93       	push	r29
     60e:	ef 93       	push	r30
     610:	ff 93       	push	r31
     612:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
     616:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     61a:	0d b6       	in	r0, 0x3d	; 61
     61c:	0d 92       	st	X+, r0
     61e:	0e b6       	in	r0, 0x3e	; 62
     620:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     622:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     626:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
     62a:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     67c:	0f 92       	push	r0
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	0f 92       	push	r0
     684:	1f 92       	push	r1
     686:	11 24       	eor	r1, r1
     688:	2f 92       	push	r2
     68a:	3f 92       	push	r3
     68c:	4f 92       	push	r4
     68e:	5f 92       	push	r5
     690:	6f 92       	push	r6
     692:	7f 92       	push	r7
     694:	8f 92       	push	r8
     696:	9f 92       	push	r9
     698:	af 92       	push	r10
     69a:	bf 92       	push	r11
     69c:	cf 92       	push	r12
     69e:	df 92       	push	r13
     6a0:	ef 92       	push	r14
     6a2:	ff 92       	push	r15
     6a4:	0f 93       	push	r16
     6a6:	1f 93       	push	r17
     6a8:	2f 93       	push	r18
     6aa:	3f 93       	push	r19
     6ac:	4f 93       	push	r20
     6ae:	5f 93       	push	r21
     6b0:	6f 93       	push	r22
     6b2:	7f 93       	push	r23
     6b4:	8f 93       	push	r24
     6b6:	9f 93       	push	r25
     6b8:	af 93       	push	r26
     6ba:	bf 93       	push	r27
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	ef 93       	push	r30
     6c2:	ff 93       	push	r31
     6c4:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
     6c8:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     6cc:	0d b6       	in	r0, 0x3d	; 61
     6ce:	0d 92       	st	X+, r0
     6d0:	0e b6       	in	r0, 0x3e	; 62
     6d2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     6d4:	0e 94 30 08 	call	0x1060	; 0x1060 <xTaskIncrementTick>
     6d8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     6da:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     6de:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
     6e2:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     6e6:	cd 91       	ld	r28, X+
     6e8:	cd bf       	out	0x3d, r28	; 61
     6ea:	dd 91       	ld	r29, X+
     6ec:	de bf       	out	0x3e, r29	; 62
     6ee:	ff 91       	pop	r31
     6f0:	ef 91       	pop	r30
     6f2:	df 91       	pop	r29
     6f4:	cf 91       	pop	r28
     6f6:	bf 91       	pop	r27
     6f8:	af 91       	pop	r26
     6fa:	9f 91       	pop	r25
     6fc:	8f 91       	pop	r24
     6fe:	7f 91       	pop	r23
     700:	6f 91       	pop	r22
     702:	5f 91       	pop	r21
     704:	4f 91       	pop	r20
     706:	3f 91       	pop	r19
     708:	2f 91       	pop	r18
     70a:	1f 91       	pop	r17
     70c:	0f 91       	pop	r16
     70e:	ff 90       	pop	r15
     710:	ef 90       	pop	r14
     712:	df 90       	pop	r13
     714:	cf 90       	pop	r12
     716:	bf 90       	pop	r11
     718:	af 90       	pop	r10
     71a:	9f 90       	pop	r9
     71c:	8f 90       	pop	r8
     71e:	7f 90       	pop	r7
     720:	6f 90       	pop	r6
     722:	5f 90       	pop	r5
     724:	4f 90       	pop	r4
     726:	3f 90       	pop	r3
     728:	2f 90       	pop	r2
     72a:	1f 90       	pop	r1
     72c:	0f 90       	pop	r0
     72e:	0f be       	out	0x3f, r0	; 63
     730:	0f 90       	pop	r0

	asm volatile ( "ret" );
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 3e 03 	call	0x67c	; 0x67c <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     73a:	0f b6       	in	r0, 0x3f	; 63
     73c:	f8 94       	cli
     73e:	0f 92       	push	r0
     740:	fc 01       	movw	r30, r24
     742:	82 8d       	ldd	r24, Z+26	; 0x1a
     744:	81 11       	cpse	r24, r1
     746:	02 c0       	rjmp	.+4      	; 0x74c <prvIsQueueEmpty+0x12>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	01 c0       	rjmp	.+2      	; 0x74e <prvIsQueueEmpty+0x14>
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	0f 90       	pop	r0
     750:	0f be       	out	0x3f, r0	; 63
     752:	08 95       	ret

00000754 <prvIsQueueFull>:
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	f8 94       	cli
     758:	0f 92       	push	r0
     75a:	fc 01       	movw	r30, r24
     75c:	22 8d       	ldd	r18, Z+26	; 0x1a
     75e:	83 8d       	ldd	r24, Z+27	; 0x1b
     760:	28 13       	cpse	r18, r24
     762:	02 c0       	rjmp	.+4      	; 0x768 <prvIsQueueFull+0x14>
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	01 c0       	rjmp	.+2      	; 0x76a <prvIsQueueFull+0x16>
     768:	80 e0       	ldi	r24, 0x00	; 0
     76a:	0f 90       	pop	r0
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	08 95       	ret

00000770 <prvCopyDataToQueue>:
     770:	1f 93       	push	r17
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	ec 01       	movw	r28, r24
     778:	14 2f       	mov	r17, r20
     77a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     77c:	41 11       	cpse	r20, r1
     77e:	0c c0       	rjmp	.+24     	; 0x798 <prvCopyDataToQueue+0x28>
     780:	88 81       	ld	r24, Y
     782:	99 81       	ldd	r25, Y+1	; 0x01
     784:	89 2b       	or	r24, r25
     786:	09 f0       	breq	.+2      	; 0x78a <prvCopyDataToQueue+0x1a>
     788:	45 c0       	rjmp	.+138    	; 0x814 <__DATA_REGION_LENGTH__+0x14>
     78a:	8a 81       	ldd	r24, Y+2	; 0x02
     78c:	9b 81       	ldd	r25, Y+3	; 0x03
     78e:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <xTaskPriorityDisinherit>
     792:	1b 82       	std	Y+3, r1	; 0x03
     794:	1a 82       	std	Y+2, r1	; 0x02
     796:	45 c0       	rjmp	.+138    	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     798:	11 11       	cpse	r17, r1
     79a:	17 c0       	rjmp	.+46     	; 0x7ca <prvCopyDataToQueue+0x5a>
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	8c 81       	ldd	r24, Y+4	; 0x04
     7a0:	9d 81       	ldd	r25, Y+5	; 0x05
     7a2:	0e 94 b3 15 	call	0x2b66	; 0x2b66 <memcpy>
     7a6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7a8:	8c 81       	ldd	r24, Y+4	; 0x04
     7aa:	9d 81       	ldd	r25, Y+5	; 0x05
     7ac:	82 0f       	add	r24, r18
     7ae:	91 1d       	adc	r25, r1
     7b0:	9d 83       	std	Y+5, r25	; 0x05
     7b2:	8c 83       	std	Y+4, r24	; 0x04
     7b4:	2a 81       	ldd	r18, Y+2	; 0x02
     7b6:	3b 81       	ldd	r19, Y+3	; 0x03
     7b8:	82 17       	cp	r24, r18
     7ba:	93 07       	cpc	r25, r19
     7bc:	68 f1       	brcs	.+90     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
     7be:	88 81       	ld	r24, Y
     7c0:	99 81       	ldd	r25, Y+1	; 0x01
     7c2:	9d 83       	std	Y+5, r25	; 0x05
     7c4:	8c 83       	std	Y+4, r24	; 0x04
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	2c c0       	rjmp	.+88     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	8e 81       	ldd	r24, Y+6	; 0x06
     7ce:	9f 81       	ldd	r25, Y+7	; 0x07
     7d0:	0e 94 b3 15 	call	0x2b66	; 0x2b66 <memcpy>
     7d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	91 95       	neg	r25
     7da:	81 95       	neg	r24
     7dc:	91 09       	sbc	r25, r1
     7de:	2e 81       	ldd	r18, Y+6	; 0x06
     7e0:	3f 81       	ldd	r19, Y+7	; 0x07
     7e2:	28 0f       	add	r18, r24
     7e4:	39 1f       	adc	r19, r25
     7e6:	3f 83       	std	Y+7, r19	; 0x07
     7e8:	2e 83       	std	Y+6, r18	; 0x06
     7ea:	48 81       	ld	r20, Y
     7ec:	59 81       	ldd	r21, Y+1	; 0x01
     7ee:	24 17       	cp	r18, r20
     7f0:	35 07       	cpc	r19, r21
     7f2:	30 f4       	brcc	.+12     	; 0x800 <__DATA_REGION_LENGTH__>
     7f4:	2a 81       	ldd	r18, Y+2	; 0x02
     7f6:	3b 81       	ldd	r19, Y+3	; 0x03
     7f8:	82 0f       	add	r24, r18
     7fa:	93 1f       	adc	r25, r19
     7fc:	9f 83       	std	Y+7, r25	; 0x07
     7fe:	8e 83       	std	Y+6, r24	; 0x06
     800:	12 30       	cpi	r17, 0x02	; 2
     802:	61 f4       	brne	.+24     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     804:	8a 8d       	ldd	r24, Y+26	; 0x1a
     806:	88 23       	and	r24, r24
     808:	59 f0       	breq	.+22     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     80a:	8a 8d       	ldd	r24, Y+26	; 0x1a
     80c:	81 50       	subi	r24, 0x01	; 1
     80e:	8a 8f       	std	Y+26, r24	; 0x1a
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	07 c0       	rjmp	.+14     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	05 c0       	rjmp	.+10     	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	03 c0       	rjmp	.+6      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	01 c0       	rjmp	.+2      	; 0x822 <__DATA_REGION_LENGTH__+0x22>
     820:	80 e0       	ldi	r24, 0x00	; 0
     822:	9a 8d       	ldd	r25, Y+26	; 0x1a
     824:	9f 5f       	subi	r25, 0xFF	; 255
     826:	9a 8f       	std	Y+26, r25	; 0x1a
     828:	df 91       	pop	r29
     82a:	cf 91       	pop	r28
     82c:	1f 91       	pop	r17
     82e:	08 95       	ret

00000830 <prvCopyDataFromQueue>:
     830:	fc 01       	movw	r30, r24
     832:	44 8d       	ldd	r20, Z+28	; 0x1c
     834:	44 23       	and	r20, r20
     836:	a9 f0       	breq	.+42     	; 0x862 <__stack+0x3>
     838:	50 e0       	ldi	r21, 0x00	; 0
     83a:	26 81       	ldd	r18, Z+6	; 0x06
     83c:	37 81       	ldd	r19, Z+7	; 0x07
     83e:	24 0f       	add	r18, r20
     840:	35 1f       	adc	r19, r21
     842:	37 83       	std	Z+7, r19	; 0x07
     844:	26 83       	std	Z+6, r18	; 0x06
     846:	82 81       	ldd	r24, Z+2	; 0x02
     848:	93 81       	ldd	r25, Z+3	; 0x03
     84a:	28 17       	cp	r18, r24
     84c:	39 07       	cpc	r19, r25
     84e:	20 f0       	brcs	.+8      	; 0x858 <prvCopyDataFromQueue+0x28>
     850:	80 81       	ld	r24, Z
     852:	91 81       	ldd	r25, Z+1	; 0x01
     854:	97 83       	std	Z+7, r25	; 0x07
     856:	86 83       	std	Z+6, r24	; 0x06
     858:	cb 01       	movw	r24, r22
     85a:	66 81       	ldd	r22, Z+6	; 0x06
     85c:	77 81       	ldd	r23, Z+7	; 0x07
     85e:	0e 94 b3 15 	call	0x2b66	; 0x2b66 <memcpy>
     862:	08 95       	ret

00000864 <prvUnlockQueue>:
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	ec 01       	movw	r28, r24
     86a:	0f b6       	in	r0, 0x3f	; 63
     86c:	f8 94       	cli
     86e:	0f 92       	push	r0
     870:	0d c0       	rjmp	.+26     	; 0x88c <prvUnlockQueue+0x28>
     872:	89 89       	ldd	r24, Y+17	; 0x11
     874:	88 23       	and	r24, r24
     876:	69 f0       	breq	.+26     	; 0x892 <prvUnlockQueue+0x2e>
     878:	ce 01       	movw	r24, r28
     87a:	41 96       	adiw	r24, 0x11	; 17
     87c:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     880:	81 11       	cpse	r24, r1
     882:	0e 94 12 0b 	call	0x1624	; 0x1624 <vTaskMissedYield>
     886:	8e 8d       	ldd	r24, Y+30	; 0x1e
     888:	81 50       	subi	r24, 0x01	; 1
     88a:	8e 8f       	std	Y+30, r24	; 0x1e
     88c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     88e:	18 16       	cp	r1, r24
     890:	84 f3       	brlt	.-32     	; 0x872 <prvUnlockQueue+0xe>
     892:	8f ef       	ldi	r24, 0xFF	; 255
     894:	8e 8f       	std	Y+30, r24	; 0x1e
     896:	0f 90       	pop	r0
     898:	0f be       	out	0x3f, r0	; 63
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	0f 92       	push	r0
     8a0:	0d c0       	rjmp	.+26     	; 0x8bc <prvUnlockQueue+0x58>
     8a2:	88 85       	ldd	r24, Y+8	; 0x08
     8a4:	88 23       	and	r24, r24
     8a6:	69 f0       	breq	.+26     	; 0x8c2 <prvUnlockQueue+0x5e>
     8a8:	ce 01       	movw	r24, r28
     8aa:	08 96       	adiw	r24, 0x08	; 8
     8ac:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     8b0:	81 11       	cpse	r24, r1
     8b2:	0e 94 12 0b 	call	0x1624	; 0x1624 <vTaskMissedYield>
     8b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8b8:	81 50       	subi	r24, 0x01	; 1
     8ba:	8d 8f       	std	Y+29, r24	; 0x1d
     8bc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8be:	18 16       	cp	r1, r24
     8c0:	84 f3       	brlt	.-32     	; 0x8a2 <prvUnlockQueue+0x3e>
     8c2:	8f ef       	ldi	r24, 0xFF	; 255
     8c4:	8d 8f       	std	Y+29, r24	; 0x1d
     8c6:	0f 90       	pop	r0
     8c8:	0f be       	out	0x3f, r0	; 63
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <xQueueGenericReset>:
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	ec 01       	movw	r28, r24
     8d6:	0f b6       	in	r0, 0x3f	; 63
     8d8:	f8 94       	cli
     8da:	0f 92       	push	r0
     8dc:	e8 81       	ld	r30, Y
     8de:	f9 81       	ldd	r31, Y+1	; 0x01
     8e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8e6:	30 e0       	ldi	r19, 0x00	; 0
     8e8:	82 9f       	mul	r24, r18
     8ea:	a0 01       	movw	r20, r0
     8ec:	83 9f       	mul	r24, r19
     8ee:	50 0d       	add	r21, r0
     8f0:	92 9f       	mul	r25, r18
     8f2:	50 0d       	add	r21, r0
     8f4:	11 24       	eor	r1, r1
     8f6:	4e 0f       	add	r20, r30
     8f8:	5f 1f       	adc	r21, r31
     8fa:	5b 83       	std	Y+3, r21	; 0x03
     8fc:	4a 83       	std	Y+2, r20	; 0x02
     8fe:	1a 8e       	std	Y+26, r1	; 0x1a
     900:	fd 83       	std	Y+5, r31	; 0x05
     902:	ec 83       	std	Y+4, r30	; 0x04
     904:	01 97       	sbiw	r24, 0x01	; 1
     906:	28 9f       	mul	r18, r24
     908:	a0 01       	movw	r20, r0
     90a:	29 9f       	mul	r18, r25
     90c:	50 0d       	add	r21, r0
     90e:	38 9f       	mul	r19, r24
     910:	50 0d       	add	r21, r0
     912:	11 24       	eor	r1, r1
     914:	cf 01       	movw	r24, r30
     916:	84 0f       	add	r24, r20
     918:	95 1f       	adc	r25, r21
     91a:	9f 83       	std	Y+7, r25	; 0x07
     91c:	8e 83       	std	Y+6, r24	; 0x06
     91e:	8f ef       	ldi	r24, 0xFF	; 255
     920:	8d 8f       	std	Y+29, r24	; 0x1d
     922:	8e 8f       	std	Y+30, r24	; 0x1e
     924:	61 11       	cpse	r22, r1
     926:	0c c0       	rjmp	.+24     	; 0x940 <xQueueGenericReset+0x70>
     928:	88 85       	ldd	r24, Y+8	; 0x08
     92a:	88 23       	and	r24, r24
     92c:	89 f0       	breq	.+34     	; 0x950 <xQueueGenericReset+0x80>
     92e:	ce 01       	movw	r24, r28
     930:	08 96       	adiw	r24, 0x08	; 8
     932:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     936:	81 30       	cpi	r24, 0x01	; 1
     938:	59 f4       	brne	.+22     	; 0x950 <xQueueGenericReset+0x80>
     93a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     93e:	08 c0       	rjmp	.+16     	; 0x950 <xQueueGenericReset+0x80>
     940:	ce 01       	movw	r24, r28
     942:	08 96       	adiw	r24, 0x08	; 8
     944:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     948:	ce 01       	movw	r24, r28
     94a:	41 96       	adiw	r24, 0x11	; 17
     94c:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     950:	0f 90       	pop	r0
     952:	0f be       	out	0x3f, r0	; 63
     954:	81 e0       	ldi	r24, 0x01	; 1
     956:	df 91       	pop	r29
     958:	cf 91       	pop	r28
     95a:	08 95       	ret

0000095c <xQueueGenericCreate>:
     95c:	0f 93       	push	r16
     95e:	1f 93       	push	r17
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	88 23       	and	r24, r24
     966:	01 f1       	breq	.+64     	; 0x9a8 <xQueueGenericCreate+0x4c>
     968:	06 2f       	mov	r16, r22
     96a:	18 2f       	mov	r17, r24
     96c:	8f e1       	ldi	r24, 0x1F	; 31
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     974:	ec 01       	movw	r28, r24
     976:	89 2b       	or	r24, r25
     978:	c9 f0       	breq	.+50     	; 0x9ac <xQueueGenericCreate+0x50>
     97a:	10 9f       	mul	r17, r16
     97c:	c0 01       	movw	r24, r0
     97e:	11 24       	eor	r1, r1
     980:	01 96       	adiw	r24, 0x01	; 1
     982:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     986:	99 83       	std	Y+1, r25	; 0x01
     988:	88 83       	st	Y, r24
     98a:	89 2b       	or	r24, r25
     98c:	39 f0       	breq	.+14     	; 0x99c <xQueueGenericCreate+0x40>
     98e:	1b 8f       	std	Y+27, r17	; 0x1b
     990:	0c 8f       	std	Y+28, r16	; 0x1c
     992:	61 e0       	ldi	r22, 0x01	; 1
     994:	ce 01       	movw	r24, r28
     996:	0e 94 68 04 	call	0x8d0	; 0x8d0 <xQueueGenericReset>
     99a:	08 c0       	rjmp	.+16     	; 0x9ac <xQueueGenericCreate+0x50>
     99c:	ce 01       	movw	r24, r28
     99e:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     9a2:	c0 e0       	ldi	r28, 0x00	; 0
     9a4:	d0 e0       	ldi	r29, 0x00	; 0
     9a6:	02 c0       	rjmp	.+4      	; 0x9ac <xQueueGenericCreate+0x50>
     9a8:	c0 e0       	ldi	r28, 0x00	; 0
     9aa:	d0 e0       	ldi	r29, 0x00	; 0
     9ac:	ce 01       	movw	r24, r28
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	1f 91       	pop	r17
     9b4:	0f 91       	pop	r16
     9b6:	08 95       	ret

000009b8 <xQueueGenericSend>:
     9b8:	cf 92       	push	r12
     9ba:	df 92       	push	r13
     9bc:	ef 92       	push	r14
     9be:	ff 92       	push	r15
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	00 d0       	rcall	.+0      	; 0x9ca <xQueueGenericSend+0x12>
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <xQueueGenericSend+0x14>
     9cc:	1f 92       	push	r1
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
     9d2:	8c 01       	movw	r16, r24
     9d4:	7b 01       	movw	r14, r22
     9d6:	5d 83       	std	Y+5, r21	; 0x05
     9d8:	4c 83       	std	Y+4, r20	; 0x04
     9da:	c2 2e       	mov	r12, r18
     9dc:	d1 2c       	mov	r13, r1
     9de:	0f b6       	in	r0, 0x3f	; 63
     9e0:	f8 94       	cli
     9e2:	0f 92       	push	r0
     9e4:	f8 01       	movw	r30, r16
     9e6:	92 8d       	ldd	r25, Z+26	; 0x1a
     9e8:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ea:	98 17       	cp	r25, r24
     9ec:	18 f0       	brcs	.+6      	; 0x9f4 <xQueueGenericSend+0x3c>
     9ee:	f2 e0       	ldi	r31, 0x02	; 2
     9f0:	cf 12       	cpse	r12, r31
     9f2:	19 c0       	rjmp	.+50     	; 0xa26 <xQueueGenericSend+0x6e>
     9f4:	4c 2d       	mov	r20, r12
     9f6:	b7 01       	movw	r22, r14
     9f8:	c8 01       	movw	r24, r16
     9fa:	0e 94 b8 03 	call	0x770	; 0x770 <prvCopyDataToQueue>
     9fe:	f8 01       	movw	r30, r16
     a00:	91 89       	ldd	r25, Z+17	; 0x11
     a02:	99 23       	and	r25, r25
     a04:	49 f0       	breq	.+18     	; 0xa18 <xQueueGenericSend+0x60>
     a06:	c8 01       	movw	r24, r16
     a08:	41 96       	adiw	r24, 0x11	; 17
     a0a:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     a0e:	81 30       	cpi	r24, 0x01	; 1
     a10:	31 f4       	brne	.+12     	; 0xa1e <xQueueGenericSend+0x66>
     a12:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     a16:	03 c0       	rjmp	.+6      	; 0xa1e <xQueueGenericSend+0x66>
     a18:	81 11       	cpse	r24, r1
     a1a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     a1e:	0f 90       	pop	r0
     a20:	0f be       	out	0x3f, r0	; 63
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	4d c0       	rjmp	.+154    	; 0xac0 <xQueueGenericSend+0x108>
     a26:	8c 81       	ldd	r24, Y+4	; 0x04
     a28:	9d 81       	ldd	r25, Y+5	; 0x05
     a2a:	89 2b       	or	r24, r25
     a2c:	21 f4       	brne	.+8      	; 0xa36 <xQueueGenericSend+0x7e>
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	45 c0       	rjmp	.+138    	; 0xac0 <xQueueGenericSend+0x108>
     a36:	d1 10       	cpse	r13, r1
     a38:	06 c0       	rjmp	.+12     	; 0xa46 <xQueueGenericSend+0x8e>
     a3a:	ce 01       	movw	r24, r28
     a3c:	01 96       	adiw	r24, 0x01	; 1
     a3e:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
     a42:	dd 24       	eor	r13, r13
     a44:	d3 94       	inc	r13
     a46:	0f 90       	pop	r0
     a48:	0f be       	out	0x3f, r0	; 63
     a4a:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
     a4e:	0f b6       	in	r0, 0x3f	; 63
     a50:	f8 94       	cli
     a52:	0f 92       	push	r0
     a54:	f8 01       	movw	r30, r16
     a56:	85 8d       	ldd	r24, Z+29	; 0x1d
     a58:	8f 3f       	cpi	r24, 0xFF	; 255
     a5a:	09 f4       	brne	.+2      	; 0xa5e <xQueueGenericSend+0xa6>
     a5c:	15 8e       	std	Z+29, r1	; 0x1d
     a5e:	f8 01       	movw	r30, r16
     a60:	86 8d       	ldd	r24, Z+30	; 0x1e
     a62:	8f 3f       	cpi	r24, 0xFF	; 255
     a64:	09 f4       	brne	.+2      	; 0xa68 <xQueueGenericSend+0xb0>
     a66:	16 8e       	std	Z+30, r1	; 0x1e
     a68:	0f 90       	pop	r0
     a6a:	0f be       	out	0x3f, r0	; 63
     a6c:	be 01       	movw	r22, r28
     a6e:	6c 5f       	subi	r22, 0xFC	; 252
     a70:	7f 4f       	sbci	r23, 0xFF	; 255
     a72:	ce 01       	movw	r24, r28
     a74:	01 96       	adiw	r24, 0x01	; 1
     a76:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskCheckForTimeOut>
     a7a:	81 11       	cpse	r24, r1
     a7c:	1b c0       	rjmp	.+54     	; 0xab4 <xQueueGenericSend+0xfc>
     a7e:	c8 01       	movw	r24, r16
     a80:	0e 94 aa 03 	call	0x754	; 0x754 <prvIsQueueFull>
     a84:	88 23       	and	r24, r24
     a86:	81 f0       	breq	.+32     	; 0xaa8 <xQueueGenericSend+0xf0>
     a88:	6c 81       	ldd	r22, Y+4	; 0x04
     a8a:	7d 81       	ldd	r23, Y+5	; 0x05
     a8c:	c8 01       	movw	r24, r16
     a8e:	08 96       	adiw	r24, 0x08	; 8
     a90:	0e 94 12 0a 	call	0x1424	; 0x1424 <vTaskPlaceOnEventList>
     a94:	c8 01       	movw	r24, r16
     a96:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     a9a:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     a9e:	81 11       	cpse	r24, r1
     aa0:	9e cf       	rjmp	.-196    	; 0x9de <xQueueGenericSend+0x26>
     aa2:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     aa6:	9b cf       	rjmp	.-202    	; 0x9de <xQueueGenericSend+0x26>
     aa8:	c8 01       	movw	r24, r16
     aaa:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     aae:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     ab2:	95 cf       	rjmp	.-214    	; 0x9de <xQueueGenericSend+0x26>
     ab4:	c8 01       	movw	r24, r16
     ab6:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
     aba:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     abe:	80 e0       	ldi	r24, 0x00	; 0
     ac0:	0f 90       	pop	r0
     ac2:	0f 90       	pop	r0
     ac4:	0f 90       	pop	r0
     ac6:	0f 90       	pop	r0
     ac8:	0f 90       	pop	r0
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	ff 90       	pop	r15
     ad4:	ef 90       	pop	r14
     ad6:	df 90       	pop	r13
     ad8:	cf 90       	pop	r12
     ada:	08 95       	ret

00000adc <xQueueCreateMutex>:
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29
     ae0:	8f e1       	ldi	r24, 0x1F	; 31
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     ae8:	ec 01       	movw	r28, r24
     aea:	89 2b       	or	r24, r25
     aec:	f9 f0       	breq	.+62     	; 0xb2c <xQueueCreateMutex+0x50>
     aee:	1b 82       	std	Y+3, r1	; 0x03
     af0:	1a 82       	std	Y+2, r1	; 0x02
     af2:	19 82       	std	Y+1, r1	; 0x01
     af4:	18 82       	st	Y, r1
     af6:	1d 82       	std	Y+5, r1	; 0x05
     af8:	1c 82       	std	Y+4, r1	; 0x04
     afa:	1f 82       	std	Y+7, r1	; 0x07
     afc:	1e 82       	std	Y+6, r1	; 0x06
     afe:	1a 8e       	std	Y+26, r1	; 0x1a
     b00:	81 e0       	ldi	r24, 0x01	; 1
     b02:	8b 8f       	std	Y+27, r24	; 0x1b
     b04:	1c 8e       	std	Y+28, r1	; 0x1c
     b06:	8f ef       	ldi	r24, 0xFF	; 255
     b08:	8d 8f       	std	Y+29, r24	; 0x1d
     b0a:	8e 8f       	std	Y+30, r24	; 0x1e
     b0c:	ce 01       	movw	r24, r28
     b0e:	08 96       	adiw	r24, 0x08	; 8
     b10:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     b14:	ce 01       	movw	r24, r28
     b16:	41 96       	adiw	r24, 0x11	; 17
     b18:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     b1c:	20 e0       	ldi	r18, 0x00	; 0
     b1e:	40 e0       	ldi	r20, 0x00	; 0
     b20:	50 e0       	ldi	r21, 0x00	; 0
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	70 e0       	ldi	r23, 0x00	; 0
     b26:	ce 01       	movw	r24, r28
     b28:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
     b2c:	ce 01       	movw	r24, r28
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	08 95       	ret

00000b34 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     b34:	af 92       	push	r10
     b36:	bf 92       	push	r11
     b38:	cf 92       	push	r12
     b3a:	df 92       	push	r13
     b3c:	ef 92       	push	r14
     b3e:	ff 92       	push	r15
     b40:	0f 93       	push	r16
     b42:	1f 93       	push	r17
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <xQueueGenericReceive+0x16>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <xQueueGenericReceive+0x18>
     b4c:	1f 92       	push	r1
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
     b52:	8c 01       	movw	r16, r24
     b54:	6b 01       	movw	r12, r22
     b56:	5d 83       	std	Y+5, r21	; 0x05
     b58:	4c 83       	std	Y+4, r20	; 0x04
     b5a:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
     b5c:	f1 2c       	mov	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     b64:	f8 01       	movw	r30, r16
     b66:	82 8d       	ldd	r24, Z+26	; 0x1a
     b68:	88 23       	and	r24, r24
     b6a:	99 f1       	breq	.+102    	; 0xbd2 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     b6c:	a6 80       	ldd	r10, Z+6	; 0x06
     b6e:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     b70:	b6 01       	movw	r22, r12
     b72:	c8 01       	movw	r24, r16
     b74:	0e 94 18 04 	call	0x830	; 0x830 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     b78:	e1 10       	cpse	r14, r1
     b7a:	1a c0       	rjmp	.+52     	; 0xbb0 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     b7c:	f8 01       	movw	r30, r16
     b7e:	82 8d       	ldd	r24, Z+26	; 0x1a
     b80:	81 50       	subi	r24, 0x01	; 1
     b82:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b84:	80 81       	ld	r24, Z
     b86:	91 81       	ldd	r25, Z+1	; 0x01
     b88:	89 2b       	or	r24, r25
     b8a:	29 f4       	brne	.+10     	; 0xb96 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     b8c:	0e 94 cf 0b 	call	0x179e	; 0x179e <pvTaskIncrementMutexHeldCount>
     b90:	f8 01       	movw	r30, r16
     b92:	93 83       	std	Z+3, r25	; 0x03
     b94:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b96:	f8 01       	movw	r30, r16
     b98:	80 85       	ldd	r24, Z+8	; 0x08
     b9a:	88 23       	and	r24, r24
     b9c:	b1 f0       	breq	.+44     	; 0xbca <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     b9e:	c8 01       	movw	r24, r16
     ba0:	08 96       	adiw	r24, 0x08	; 8
     ba2:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     ba6:	81 30       	cpi	r24, 0x01	; 1
     ba8:	81 f4       	brne	.+32     	; 0xbca <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
     baa:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     bae:	0d c0       	rjmp	.+26     	; 0xbca <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     bb0:	f8 01       	movw	r30, r16
     bb2:	b7 82       	std	Z+7, r11	; 0x07
     bb4:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bb6:	81 89       	ldd	r24, Z+17	; 0x11
     bb8:	88 23       	and	r24, r24
     bba:	39 f0       	breq	.+14     	; 0xbca <xQueueGenericReceive+0x96>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bbc:	c8 01       	movw	r24, r16
     bbe:	41 96       	adiw	r24, 0x11	; 17
     bc0:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <xTaskRemoveFromEventList>
     bc4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     bc6:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	5b c0       	rjmp	.+182    	; 0xc88 <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     bd2:	8c 81       	ldd	r24, Y+4	; 0x04
     bd4:	9d 81       	ldd	r25, Y+5	; 0x05
     bd6:	89 2b       	or	r24, r25
     bd8:	21 f4       	brne	.+8      	; 0xbe2 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     bda:	0f 90       	pop	r0
     bdc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	53 c0       	rjmp	.+166    	; 0xc88 <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
     be2:	f1 10       	cpse	r15, r1
     be4:	06 c0       	rjmp	.+12     	; 0xbf2 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     be6:	ce 01       	movw	r24, r28
     be8:	01 96       	adiw	r24, 0x01	; 1
     bea:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     bee:	ff 24       	eor	r15, r15
     bf0:	f3 94       	inc	r15
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     bf2:	0f 90       	pop	r0
     bf4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     bf6:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	0f 92       	push	r0
     c00:	f8 01       	movw	r30, r16
     c02:	85 8d       	ldd	r24, Z+29	; 0x1d
     c04:	8f 3f       	cpi	r24, 0xFF	; 255
     c06:	09 f4       	brne	.+2      	; 0xc0a <xQueueGenericReceive+0xd6>
     c08:	15 8e       	std	Z+29, r1	; 0x1d
     c0a:	f8 01       	movw	r30, r16
     c0c:	86 8d       	ldd	r24, Z+30	; 0x1e
     c0e:	8f 3f       	cpi	r24, 0xFF	; 255
     c10:	09 f4       	brne	.+2      	; 0xc14 <xQueueGenericReceive+0xe0>
     c12:	16 8e       	std	Z+30, r1	; 0x1e
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c18:	be 01       	movw	r22, r28
     c1a:	6c 5f       	subi	r22, 0xFC	; 252
     c1c:	7f 4f       	sbci	r23, 0xFF	; 255
     c1e:	ce 01       	movw	r24, r28
     c20:	01 96       	adiw	r24, 0x01	; 1
     c22:	0e 94 e0 0a 	call	0x15c0	; 0x15c0 <xTaskCheckForTimeOut>
     c26:	81 11       	cpse	r24, r1
     c28:	29 c0       	rjmp	.+82     	; 0xc7c <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c2a:	c8 01       	movw	r24, r16
     c2c:	0e 94 9d 03 	call	0x73a	; 0x73a <prvIsQueueEmpty>
     c30:	88 23       	and	r24, r24
     c32:	f1 f0       	breq	.+60     	; 0xc70 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c34:	f8 01       	movw	r30, r16
     c36:	80 81       	ld	r24, Z
     c38:	91 81       	ldd	r25, Z+1	; 0x01
     c3a:	89 2b       	or	r24, r25
     c3c:	49 f4       	brne	.+18     	; 0xc50 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
     c3e:	0f b6       	in	r0, 0x3f	; 63
     c40:	f8 94       	cli
     c42:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     c44:	82 81       	ldd	r24, Z+2	; 0x02
     c46:	93 81       	ldd	r25, Z+3	; 0x03
     c48:	0e 94 16 0b 	call	0x162c	; 0x162c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     c4c:	0f 90       	pop	r0
     c4e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c50:	6c 81       	ldd	r22, Y+4	; 0x04
     c52:	7d 81       	ldd	r23, Y+5	; 0x05
     c54:	c8 01       	movw	r24, r16
     c56:	41 96       	adiw	r24, 0x11	; 17
     c58:	0e 94 12 0a 	call	0x1424	; 0x1424 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     c5c:	c8 01       	movw	r24, r16
     c5e:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     c62:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     c66:	81 11       	cpse	r24, r1
     c68:	7a cf       	rjmp	.-268    	; 0xb5e <xQueueGenericReceive+0x2a>
				{
					portYIELD_WITHIN_API();
     c6a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     c6e:	77 cf       	rjmp	.-274    	; 0xb5e <xQueueGenericReceive+0x2a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     c70:	c8 01       	movw	r24, r16
     c72:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     c76:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
     c7a:	71 cf       	rjmp	.-286    	; 0xb5e <xQueueGenericReceive+0x2a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     c7c:	c8 01       	movw	r24, r16
     c7e:	0e 94 32 04 	call	0x864	; 0x864 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     c82:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     c86:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     c88:	0f 90       	pop	r0
     c8a:	0f 90       	pop	r0
     c8c:	0f 90       	pop	r0
     c8e:	0f 90       	pop	r0
     c90:	0f 90       	pop	r0
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	ff 90       	pop	r15
     c9c:	ef 90       	pop	r14
     c9e:	df 90       	pop	r13
     ca0:	cf 90       	pop	r12
     ca2:	bf 90       	pop	r11
     ca4:	af 90       	pop	r10
     ca6:	08 95       	ret

00000ca8 <prvResetNextTaskUnblockTime>:
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;

		return xReturn;
	}
     ca8:	e0 91 e3 05 	lds	r30, 0x05E3	; 0x8005e3 <pxDelayedTaskList>
     cac:	f0 91 e4 05 	lds	r31, 0x05E4	; 0x8005e4 <pxDelayedTaskList+0x1>
     cb0:	80 81       	ld	r24, Z
     cb2:	81 11       	cpse	r24, r1
     cb4:	07 c0       	rjmp	.+14     	; 0xcc4 <prvResetNextTaskUnblockTime+0x1c>
     cb6:	8f ef       	ldi	r24, 0xFF	; 255
     cb8:	9f ef       	ldi	r25, 0xFF	; 255
     cba:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     cbe:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     cc2:	08 95       	ret
     cc4:	e0 91 e3 05 	lds	r30, 0x05E3	; 0x8005e3 <pxDelayedTaskList>
     cc8:	f0 91 e4 05 	lds	r31, 0x05E4	; 0x8005e4 <pxDelayedTaskList+0x1>
     ccc:	05 80       	ldd	r0, Z+5	; 0x05
     cce:	f6 81       	ldd	r31, Z+6	; 0x06
     cd0:	e0 2d       	mov	r30, r0
     cd2:	06 80       	ldd	r0, Z+6	; 0x06
     cd4:	f7 81       	ldd	r31, Z+7	; 0x07
     cd6:	e0 2d       	mov	r30, r0
     cd8:	82 81       	ldd	r24, Z+2	; 0x02
     cda:	93 81       	ldd	r25, Z+3	; 0x03
     cdc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     ce0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     ce4:	08 95       	ret

00000ce6 <prvAllocateTCBAndStack>:
     ce6:	ef 92       	push	r14
     ce8:	ff 92       	push	r15
     cea:	0f 93       	push	r16
     cec:	1f 93       	push	r17
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	7c 01       	movw	r14, r24
     cf4:	eb 01       	movw	r28, r22
     cf6:	84 e3       	ldi	r24, 0x34	; 52
     cf8:	90 e0       	ldi	r25, 0x00	; 0
     cfa:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     cfe:	8c 01       	movw	r16, r24
     d00:	89 2b       	or	r24, r25
     d02:	89 f0       	breq	.+34     	; 0xd26 <prvAllocateTCBAndStack+0x40>
     d04:	20 97       	sbiw	r28, 0x00	; 0
     d06:	21 f4       	brne	.+8      	; 0xd10 <prvAllocateTCBAndStack+0x2a>
     d08:	c7 01       	movw	r24, r14
     d0a:	0e 94 81 01 	call	0x302	; 0x302 <pvPortMalloc>
     d0e:	01 c0       	rjmp	.+2      	; 0xd12 <prvAllocateTCBAndStack+0x2c>
     d10:	ce 01       	movw	r24, r28
     d12:	f8 01       	movw	r30, r16
     d14:	90 8f       	std	Z+24, r25	; 0x18
     d16:	87 8b       	std	Z+23, r24	; 0x17
     d18:	89 2b       	or	r24, r25
     d1a:	29 f4       	brne	.+10     	; 0xd26 <prvAllocateTCBAndStack+0x40>
     d1c:	c8 01       	movw	r24, r16
     d1e:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d22:	00 e0       	ldi	r16, 0x00	; 0
     d24:	10 e0       	ldi	r17, 0x00	; 0
     d26:	c8 01       	movw	r24, r16
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	08 95       	ret

00000d36 <prvDeleteTCB>:
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	ec 01       	movw	r28, r24
     d3c:	8f 89       	ldd	r24, Y+23	; 0x17
     d3e:	98 8d       	ldd	r25, Y+24	; 0x18
     d40:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d44:	ce 01       	movw	r24, r28
     d46:	0e 94 b6 01 	call	0x36c	; 0x36c <vPortFree>
     d4a:	df 91       	pop	r29
     d4c:	cf 91       	pop	r28
     d4e:	08 95       	ret

00000d50 <prvInitialiseTCBVariables>:
     d50:	1f 93       	push	r17
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	ec 01       	movw	r28, r24
     d58:	14 2f       	mov	r17, r20
     d5a:	20 e0       	ldi	r18, 0x00	; 0
     d5c:	0f c0       	rjmp	.+30     	; 0xd7c <prvInitialiseTCBVariables+0x2c>
     d5e:	82 2f       	mov	r24, r18
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	fb 01       	movw	r30, r22
     d64:	e8 0f       	add	r30, r24
     d66:	f9 1f       	adc	r31, r25
     d68:	30 81       	ld	r19, Z
     d6a:	de 01       	movw	r26, r28
     d6c:	a8 0f       	add	r26, r24
     d6e:	b9 1f       	adc	r27, r25
     d70:	59 96       	adiw	r26, 0x19	; 25
     d72:	3c 93       	st	X, r19
     d74:	80 81       	ld	r24, Z
     d76:	88 23       	and	r24, r24
     d78:	19 f0       	breq	.+6      	; 0xd80 <prvInitialiseTCBVariables+0x30>
     d7a:	2f 5f       	subi	r18, 0xFF	; 255
     d7c:	29 31       	cpi	r18, 0x19	; 25
     d7e:	78 f3       	brcs	.-34     	; 0xd5e <prvInitialiseTCBVariables+0xe>
     d80:	19 aa       	std	Y+49, r1	; 0x31
     d82:	16 30       	cpi	r17, 0x06	; 6
     d84:	08 f0       	brcs	.+2      	; 0xd88 <prvInitialiseTCBVariables+0x38>
     d86:	15 e0       	ldi	r17, 0x05	; 5
     d88:	1e 8b       	std	Y+22, r17	; 0x16
     d8a:	1a ab       	std	Y+50, r17	; 0x32
     d8c:	1b aa       	std	Y+51, r1	; 0x33
     d8e:	ce 01       	movw	r24, r28
     d90:	02 96       	adiw	r24, 0x02	; 2
     d92:	0e 94 c5 01 	call	0x38a	; 0x38a <vListInitialiseItem>
     d96:	ce 01       	movw	r24, r28
     d98:	0c 96       	adiw	r24, 0x0c	; 12
     d9a:	0e 94 c5 01 	call	0x38a	; 0x38a <vListInitialiseItem>
     d9e:	d9 87       	std	Y+9, r29	; 0x09
     da0:	c8 87       	std	Y+8, r28	; 0x08
     da2:	86 e0       	ldi	r24, 0x06	; 6
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	81 1b       	sub	r24, r17
     da8:	91 09       	sbc	r25, r1
     daa:	9d 87       	std	Y+13, r25	; 0x0d
     dac:	8c 87       	std	Y+12, r24	; 0x0c
     dae:	db 8b       	std	Y+19, r29	; 0x13
     db0:	ca 8b       	std	Y+18, r28	; 0x12
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	08 95       	ret

00000dba <prvInitialiseTaskLists>:
     dba:	cf 93       	push	r28
     dbc:	c0 e0       	ldi	r28, 0x00	; 0
     dbe:	10 c0       	rjmp	.+32     	; 0xde0 <prvInitialiseTaskLists+0x26>
     dc0:	8c 2f       	mov	r24, r28
     dc2:	90 e0       	ldi	r25, 0x00	; 0
     dc4:	9c 01       	movw	r18, r24
     dc6:	22 0f       	add	r18, r18
     dc8:	33 1f       	adc	r19, r19
     dca:	22 0f       	add	r18, r18
     dcc:	33 1f       	adc	r19, r19
     dce:	22 0f       	add	r18, r18
     dd0:	33 1f       	adc	r19, r19
     dd2:	82 0f       	add	r24, r18
     dd4:	93 1f       	adc	r25, r19
     dd6:	89 50       	subi	r24, 0x09	; 9
     dd8:	9a 4f       	sbci	r25, 0xFA	; 250
     dda:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dde:	cf 5f       	subi	r28, 0xFF	; 255
     de0:	c6 30       	cpi	r28, 0x06	; 6
     de2:	70 f3       	brcs	.-36     	; 0xdc0 <prvInitialiseTaskLists+0x6>
     de4:	8e ee       	ldi	r24, 0xEE	; 238
     de6:	95 e0       	ldi	r25, 0x05	; 5
     de8:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dec:	85 ee       	ldi	r24, 0xE5	; 229
     dee:	95 e0       	ldi	r25, 0x05	; 5
     df0:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     df4:	88 ed       	ldi	r24, 0xD8	; 216
     df6:	95 e0       	ldi	r25, 0x05	; 5
     df8:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     dfc:	8f ec       	ldi	r24, 0xCF	; 207
     dfe:	95 e0       	ldi	r25, 0x05	; 5
     e00:	0e 94 b7 01 	call	0x36e	; 0x36e <vListInitialise>
     e04:	8e ee       	ldi	r24, 0xEE	; 238
     e06:	95 e0       	ldi	r25, 0x05	; 5
     e08:	90 93 e4 05 	sts	0x05E4, r25	; 0x8005e4 <pxDelayedTaskList+0x1>
     e0c:	80 93 e3 05 	sts	0x05E3, r24	; 0x8005e3 <pxDelayedTaskList>
     e10:	85 ee       	ldi	r24, 0xE5	; 229
     e12:	95 e0       	ldi	r25, 0x05	; 5
     e14:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <pxOverflowDelayedTaskList+0x1>
     e18:	80 93 e1 05 	sts	0x05E1, r24	; 0x8005e1 <pxOverflowDelayedTaskList>
     e1c:	cf 91       	pop	r28
     e1e:	08 95       	ret

00000e20 <prvAddCurrentTaskToDelayedList>:
     e20:	cf 93       	push	r28
     e22:	df 93       	push	r29
     e24:	ec 01       	movw	r28, r24
     e26:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
     e2a:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     e2e:	93 83       	std	Z+3, r25	; 0x03
     e30:	82 83       	std	Z+2, r24	; 0x02
     e32:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xTickCount>
     e36:	90 91 cc 05 	lds	r25, 0x05CC	; 0x8005cc <xTickCount+0x1>
     e3a:	c8 17       	cp	r28, r24
     e3c:	d9 07       	cpc	r29, r25
     e3e:	68 f4       	brcc	.+26     	; 0xe5a <prvAddCurrentTaskToDelayedList+0x3a>
     e40:	60 91 2d 06 	lds	r22, 0x062D	; 0x80062d <pxCurrentTCB>
     e44:	70 91 2e 06 	lds	r23, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     e48:	80 91 e1 05 	lds	r24, 0x05E1	; 0x8005e1 <pxOverflowDelayedTaskList>
     e4c:	90 91 e2 05 	lds	r25, 0x05E2	; 0x8005e2 <pxOverflowDelayedTaskList+0x1>
     e50:	6e 5f       	subi	r22, 0xFE	; 254
     e52:	7f 4f       	sbci	r23, 0xFF	; 255
     e54:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
     e58:	17 c0       	rjmp	.+46     	; 0xe88 <prvAddCurrentTaskToDelayedList+0x68>
     e5a:	60 91 2d 06 	lds	r22, 0x062D	; 0x80062d <pxCurrentTCB>
     e5e:	70 91 2e 06 	lds	r23, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     e62:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <pxDelayedTaskList>
     e66:	90 91 e4 05 	lds	r25, 0x05E4	; 0x8005e4 <pxDelayedTaskList+0x1>
     e6a:	6e 5f       	subi	r22, 0xFE	; 254
     e6c:	7f 4f       	sbci	r23, 0xFF	; 255
     e6e:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
     e72:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     e76:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     e7a:	c8 17       	cp	r28, r24
     e7c:	d9 07       	cpc	r29, r25
     e7e:	20 f4       	brcc	.+8      	; 0xe88 <prvAddCurrentTaskToDelayedList+0x68>
     e80:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     e84:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	08 95       	ret

00000e8e <xTaskGenericCreate>:
     e8e:	2f 92       	push	r2
     e90:	3f 92       	push	r3
     e92:	4f 92       	push	r4
     e94:	5f 92       	push	r5
     e96:	7f 92       	push	r7
     e98:	8f 92       	push	r8
     e9a:	9f 92       	push	r9
     e9c:	af 92       	push	r10
     e9e:	bf 92       	push	r11
     ea0:	cf 92       	push	r12
     ea2:	df 92       	push	r13
     ea4:	ef 92       	push	r14
     ea6:	ff 92       	push	r15
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	cf 93       	push	r28
     eae:	df 93       	push	r29
     eb0:	00 d0       	rcall	.+0      	; 0xeb2 <xTaskGenericCreate+0x24>
     eb2:	00 d0       	rcall	.+0      	; 0xeb4 <xTaskGenericCreate+0x26>
     eb4:	cd b7       	in	r28, 0x3d	; 61
     eb6:	de b7       	in	r29, 0x3e	; 62
     eb8:	9a 83       	std	Y+2, r25	; 0x02
     eba:	89 83       	std	Y+1, r24	; 0x01
     ebc:	4b 01       	movw	r8, r22
     ebe:	5c 83       	std	Y+4, r21	; 0x04
     ec0:	4b 83       	std	Y+3, r20	; 0x03
     ec2:	19 01       	movw	r2, r18
     ec4:	70 2e       	mov	r7, r16
     ec6:	b6 01       	movw	r22, r12
     ec8:	25 01       	movw	r4, r10
     eca:	ca 01       	movw	r24, r20
     ecc:	0e 94 73 06 	call	0xce6	; 0xce6 <prvAllocateTCBAndStack>
     ed0:	5c 01       	movw	r10, r24
     ed2:	00 97       	sbiw	r24, 0x00	; 0
     ed4:	09 f4       	brne	.+2      	; 0xed8 <xTaskGenericCreate+0x4a>
     ed6:	6a c0       	rjmp	.+212    	; 0xfac <xTaskGenericCreate+0x11e>
     ed8:	fc 01       	movw	r30, r24
     eda:	c7 88       	ldd	r12, Z+23	; 0x17
     edc:	d0 8c       	ldd	r13, Z+24	; 0x18
     ede:	8b 81       	ldd	r24, Y+3	; 0x03
     ee0:	9c 81       	ldd	r25, Y+4	; 0x04
     ee2:	01 97       	sbiw	r24, 0x01	; 1
     ee4:	c8 0e       	add	r12, r24
     ee6:	d9 1e       	adc	r13, r25
     ee8:	0b 81       	ldd	r16, Y+3	; 0x03
     eea:	1c 81       	ldd	r17, Y+4	; 0x04
     eec:	92 01       	movw	r18, r4
     eee:	47 2d       	mov	r20, r7
     ef0:	b4 01       	movw	r22, r8
     ef2:	c5 01       	movw	r24, r10
     ef4:	0e 94 a8 06 	call	0xd50	; 0xd50 <prvInitialiseTCBVariables>
     ef8:	a1 01       	movw	r20, r2
     efa:	69 81       	ldd	r22, Y+1	; 0x01
     efc:	7a 81       	ldd	r23, Y+2	; 0x02
     efe:	c6 01       	movw	r24, r12
     f00:	0e 94 4a 02 	call	0x494	; 0x494 <pxPortInitialiseStack>
     f04:	f5 01       	movw	r30, r10
     f06:	91 83       	std	Z+1, r25	; 0x01
     f08:	80 83       	st	Z, r24
     f0a:	e1 14       	cp	r14, r1
     f0c:	f1 04       	cpc	r15, r1
     f0e:	19 f0       	breq	.+6      	; 0xf16 <xTaskGenericCreate+0x88>
     f10:	f7 01       	movw	r30, r14
     f12:	b1 82       	std	Z+1, r11	; 0x01
     f14:	a0 82       	st	Z, r10
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	f8 94       	cli
     f1a:	0f 92       	push	r0
     f1c:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <uxCurrentNumberOfTasks>
     f20:	8f 5f       	subi	r24, 0xFF	; 255
     f22:	80 93 cd 05 	sts	0x05CD, r24	; 0x8005cd <uxCurrentNumberOfTasks>
     f26:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxCurrentTCB>
     f2a:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     f2e:	89 2b       	or	r24, r25
     f30:	59 f4       	brne	.+22     	; 0xf48 <xTaskGenericCreate+0xba>
     f32:	b0 92 2e 06 	sts	0x062E, r11	; 0x80062e <pxCurrentTCB+0x1>
     f36:	a0 92 2d 06 	sts	0x062D, r10	; 0x80062d <pxCurrentTCB>
     f3a:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <uxCurrentNumberOfTasks>
     f3e:	81 30       	cpi	r24, 0x01	; 1
     f40:	91 f4       	brne	.+36     	; 0xf66 <xTaskGenericCreate+0xd8>
     f42:	0e 94 dd 06 	call	0xdba	; 0xdba <prvInitialiseTaskLists>
     f46:	0f c0       	rjmp	.+30     	; 0xf66 <xTaskGenericCreate+0xd8>
     f48:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <xSchedulerRunning>
     f4c:	81 11       	cpse	r24, r1
     f4e:	0b c0       	rjmp	.+22     	; 0xf66 <xTaskGenericCreate+0xd8>
     f50:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
     f54:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     f58:	86 89       	ldd	r24, Z+22	; 0x16
     f5a:	78 16       	cp	r7, r24
     f5c:	20 f0       	brcs	.+8      	; 0xf66 <xTaskGenericCreate+0xd8>
     f5e:	b0 92 2e 06 	sts	0x062E, r11	; 0x80062e <pxCurrentTCB+0x1>
     f62:	a0 92 2d 06 	sts	0x062D, r10	; 0x80062d <pxCurrentTCB>
     f66:	80 91 c5 05 	lds	r24, 0x05C5	; 0x8005c5 <uxTaskNumber>
     f6a:	8f 5f       	subi	r24, 0xFF	; 255
     f6c:	80 93 c5 05 	sts	0x05C5, r24	; 0x8005c5 <uxTaskNumber>
     f70:	f5 01       	movw	r30, r10
     f72:	86 89       	ldd	r24, Z+22	; 0x16
     f74:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
     f78:	98 17       	cp	r25, r24
     f7a:	10 f4       	brcc	.+4      	; 0xf80 <xTaskGenericCreate+0xf2>
     f7c:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	b5 01       	movw	r22, r10
     f84:	6e 5f       	subi	r22, 0xFE	; 254
     f86:	7f 4f       	sbci	r23, 0xFF	; 255
     f88:	9c 01       	movw	r18, r24
     f8a:	22 0f       	add	r18, r18
     f8c:	33 1f       	adc	r19, r19
     f8e:	22 0f       	add	r18, r18
     f90:	33 1f       	adc	r19, r19
     f92:	22 0f       	add	r18, r18
     f94:	33 1f       	adc	r19, r19
     f96:	82 0f       	add	r24, r18
     f98:	93 1f       	adc	r25, r19
     f9a:	89 50       	subi	r24, 0x09	; 9
     f9c:	9a 4f       	sbci	r25, 0xFA	; 250
     f9e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
     fa2:	0f 90       	pop	r0
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	f1 e0       	ldi	r31, 0x01	; 1
     fa8:	f9 83       	std	Y+1, r31	; 0x01
     faa:	02 c0       	rjmp	.+4      	; 0xfb0 <xTaskGenericCreate+0x122>
     fac:	8f ef       	ldi	r24, 0xFF	; 255
     fae:	89 83       	std	Y+1, r24	; 0x01
     fb0:	e9 81       	ldd	r30, Y+1	; 0x01
     fb2:	e1 30       	cpi	r30, 0x01	; 1
     fb4:	69 f4       	brne	.+26     	; 0xfd0 <xTaskGenericCreate+0x142>
     fb6:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <xSchedulerRunning>
     fba:	88 23       	and	r24, r24
     fbc:	49 f0       	breq	.+18     	; 0xfd0 <xTaskGenericCreate+0x142>
     fbe:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
     fc2:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
     fc6:	86 89       	ldd	r24, Z+22	; 0x16
     fc8:	87 15       	cp	r24, r7
     fca:	10 f4       	brcc	.+4      	; 0xfd0 <xTaskGenericCreate+0x142>
     fcc:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
     fd0:	89 81       	ldd	r24, Y+1	; 0x01
     fd2:	0f 90       	pop	r0
     fd4:	0f 90       	pop	r0
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	df 91       	pop	r29
     fdc:	cf 91       	pop	r28
     fde:	1f 91       	pop	r17
     fe0:	0f 91       	pop	r16
     fe2:	ff 90       	pop	r15
     fe4:	ef 90       	pop	r14
     fe6:	df 90       	pop	r13
     fe8:	cf 90       	pop	r12
     fea:	bf 90       	pop	r11
     fec:	af 90       	pop	r10
     fee:	9f 90       	pop	r9
     ff0:	8f 90       	pop	r8
     ff2:	7f 90       	pop	r7
     ff4:	5f 90       	pop	r5
     ff6:	4f 90       	pop	r4
     ff8:	3f 90       	pop	r3
     ffa:	2f 90       	pop	r2
     ffc:	08 95       	ret

00000ffe <vTaskStartScheduler>:
     ffe:	af 92       	push	r10
    1000:	bf 92       	push	r11
    1002:	cf 92       	push	r12
    1004:	df 92       	push	r13
    1006:	ef 92       	push	r14
    1008:	ff 92       	push	r15
    100a:	0f 93       	push	r16
    100c:	a1 2c       	mov	r10, r1
    100e:	b1 2c       	mov	r11, r1
    1010:	c1 2c       	mov	r12, r1
    1012:	d1 2c       	mov	r13, r1
    1014:	e1 2c       	mov	r14, r1
    1016:	f1 2c       	mov	r15, r1
    1018:	00 e0       	ldi	r16, 0x00	; 0
    101a:	20 e0       	ldi	r18, 0x00	; 0
    101c:	30 e0       	ldi	r19, 0x00	; 0
    101e:	45 e5       	ldi	r20, 0x55	; 85
    1020:	50 e0       	ldi	r21, 0x00	; 0
    1022:	6f e6       	ldi	r22, 0x6F	; 111
    1024:	70 e0       	ldi	r23, 0x00	; 0
    1026:	8d ea       	ldi	r24, 0xAD	; 173
    1028:	99 e0       	ldi	r25, 0x09	; 9
    102a:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	49 f4       	brne	.+18     	; 0x1044 <vTaskStartScheduler+0x46>
    1032:	f8 94       	cli
    1034:	80 93 c9 05 	sts	0x05C9, r24	; 0x8005c9 <xSchedulerRunning>
    1038:	10 92 cc 05 	sts	0x05CC, r1	; 0x8005cc <xTickCount+0x1>
    103c:	10 92 cb 05 	sts	0x05CB, r1	; 0x8005cb <xTickCount>
    1040:	0e 94 b6 02 	call	0x56c	; 0x56c <xPortStartScheduler>
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	08 95       	ret

00001054 <vTaskSuspendAll>:
    1054:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <uxSchedulerSuspended>
    1058:	8f 5f       	subi	r24, 0xFF	; 255
    105a:	80 93 c4 05 	sts	0x05C4, r24	; 0x8005c4 <uxSchedulerSuspended>
    105e:	08 95       	ret

00001060 <xTaskIncrementTick>:
    1060:	df 92       	push	r13
    1062:	ef 92       	push	r14
    1064:	ff 92       	push	r15
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <uxSchedulerSuspended>
    1072:	81 11       	cpse	r24, r1
    1074:	99 c0       	rjmp	.+306    	; 0x11a8 <xTaskIncrementTick+0x148>
    1076:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xTickCount>
    107a:	90 91 cc 05 	lds	r25, 0x05CC	; 0x8005cc <xTickCount+0x1>
    107e:	01 96       	adiw	r24, 0x01	; 1
    1080:	90 93 cc 05 	sts	0x05CC, r25	; 0x8005cc <xTickCount+0x1>
    1084:	80 93 cb 05 	sts	0x05CB, r24	; 0x8005cb <xTickCount>
    1088:	e0 90 cb 05 	lds	r14, 0x05CB	; 0x8005cb <xTickCount>
    108c:	f0 90 cc 05 	lds	r15, 0x05CC	; 0x8005cc <xTickCount+0x1>
    1090:	e1 14       	cp	r14, r1
    1092:	f1 04       	cpc	r15, r1
    1094:	b9 f4       	brne	.+46     	; 0x10c4 <xTaskIncrementTick+0x64>
    1096:	80 91 e3 05 	lds	r24, 0x05E3	; 0x8005e3 <pxDelayedTaskList>
    109a:	90 91 e4 05 	lds	r25, 0x05E4	; 0x8005e4 <pxDelayedTaskList+0x1>
    109e:	20 91 e1 05 	lds	r18, 0x05E1	; 0x8005e1 <pxOverflowDelayedTaskList>
    10a2:	30 91 e2 05 	lds	r19, 0x05E2	; 0x8005e2 <pxOverflowDelayedTaskList+0x1>
    10a6:	30 93 e4 05 	sts	0x05E4, r19	; 0x8005e4 <pxDelayedTaskList+0x1>
    10aa:	20 93 e3 05 	sts	0x05E3, r18	; 0x8005e3 <pxDelayedTaskList>
    10ae:	90 93 e2 05 	sts	0x05E2, r25	; 0x8005e2 <pxOverflowDelayedTaskList+0x1>
    10b2:	80 93 e1 05 	sts	0x05E1, r24	; 0x8005e1 <pxOverflowDelayedTaskList>
    10b6:	80 91 c6 05 	lds	r24, 0x05C6	; 0x8005c6 <xNumOfOverflows>
    10ba:	8f 5f       	subi	r24, 0xFF	; 255
    10bc:	80 93 c6 05 	sts	0x05C6, r24	; 0x8005c6 <xNumOfOverflows>
    10c0:	0e 94 54 06 	call	0xca8	; 0xca8 <prvResetNextTaskUnblockTime>
    10c4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    10c8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    10cc:	e8 16       	cp	r14, r24
    10ce:	f9 06       	cpc	r15, r25
    10d0:	28 f4       	brcc	.+10     	; 0x10dc <xTaskIncrementTick+0x7c>
    10d2:	d1 2c       	mov	r13, r1
    10d4:	53 c0       	rjmp	.+166    	; 0x117c <xTaskIncrementTick+0x11c>
    10d6:	dd 24       	eor	r13, r13
    10d8:	d3 94       	inc	r13
    10da:	01 c0       	rjmp	.+2      	; 0x10de <xTaskIncrementTick+0x7e>
    10dc:	d1 2c       	mov	r13, r1
    10de:	e0 91 e3 05 	lds	r30, 0x05E3	; 0x8005e3 <pxDelayedTaskList>
    10e2:	f0 91 e4 05 	lds	r31, 0x05E4	; 0x8005e4 <pxDelayedTaskList+0x1>
    10e6:	80 81       	ld	r24, Z
    10e8:	81 11       	cpse	r24, r1
    10ea:	07 c0       	rjmp	.+14     	; 0x10fa <xTaskIncrementTick+0x9a>
    10ec:	8f ef       	ldi	r24, 0xFF	; 255
    10ee:	9f ef       	ldi	r25, 0xFF	; 255
    10f0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    10f4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    10f8:	41 c0       	rjmp	.+130    	; 0x117c <xTaskIncrementTick+0x11c>
    10fa:	e0 91 e3 05 	lds	r30, 0x05E3	; 0x8005e3 <pxDelayedTaskList>
    10fe:	f0 91 e4 05 	lds	r31, 0x05E4	; 0x8005e4 <pxDelayedTaskList+0x1>
    1102:	05 80       	ldd	r0, Z+5	; 0x05
    1104:	f6 81       	ldd	r31, Z+6	; 0x06
    1106:	e0 2d       	mov	r30, r0
    1108:	c6 81       	ldd	r28, Z+6	; 0x06
    110a:	d7 81       	ldd	r29, Z+7	; 0x07
    110c:	8a 81       	ldd	r24, Y+2	; 0x02
    110e:	9b 81       	ldd	r25, Y+3	; 0x03
    1110:	e8 16       	cp	r14, r24
    1112:	f9 06       	cpc	r15, r25
    1114:	28 f4       	brcc	.+10     	; 0x1120 <xTaskIncrementTick+0xc0>
    1116:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    111a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    111e:	2e c0       	rjmp	.+92     	; 0x117c <xTaskIncrementTick+0x11c>
    1120:	8e 01       	movw	r16, r28
    1122:	0e 5f       	subi	r16, 0xFE	; 254
    1124:	1f 4f       	sbci	r17, 0xFF	; 255
    1126:	c8 01       	movw	r24, r16
    1128:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    112c:	8c 89       	ldd	r24, Y+20	; 0x14
    112e:	9d 89       	ldd	r25, Y+21	; 0x15
    1130:	89 2b       	or	r24, r25
    1132:	21 f0       	breq	.+8      	; 0x113c <xTaskIncrementTick+0xdc>
    1134:	ce 01       	movw	r24, r28
    1136:	0c 96       	adiw	r24, 0x0c	; 12
    1138:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    113c:	8e 89       	ldd	r24, Y+22	; 0x16
    113e:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    1142:	98 17       	cp	r25, r24
    1144:	10 f4       	brcc	.+4      	; 0x114a <xTaskIncrementTick+0xea>
    1146:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	9c 01       	movw	r18, r24
    114e:	22 0f       	add	r18, r18
    1150:	33 1f       	adc	r19, r19
    1152:	22 0f       	add	r18, r18
    1154:	33 1f       	adc	r19, r19
    1156:	22 0f       	add	r18, r18
    1158:	33 1f       	adc	r19, r19
    115a:	82 0f       	add	r24, r18
    115c:	93 1f       	adc	r25, r19
    115e:	b8 01       	movw	r22, r16
    1160:	89 50       	subi	r24, 0x09	; 9
    1162:	9a 4f       	sbci	r25, 0xFA	; 250
    1164:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1168:	9e 89       	ldd	r25, Y+22	; 0x16
    116a:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    116e:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1172:	86 89       	ldd	r24, Z+22	; 0x16
    1174:	98 17       	cp	r25, r24
    1176:	08 f0       	brcs	.+2      	; 0x117a <xTaskIncrementTick+0x11a>
    1178:	ae cf       	rjmp	.-164    	; 0x10d6 <xTaskIncrementTick+0x76>
    117a:	b1 cf       	rjmp	.-158    	; 0x10de <xTaskIncrementTick+0x7e>
    117c:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    1180:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1184:	86 89       	ldd	r24, Z+22	; 0x16
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	fc 01       	movw	r30, r24
    118a:	ee 0f       	add	r30, r30
    118c:	ff 1f       	adc	r31, r31
    118e:	ee 0f       	add	r30, r30
    1190:	ff 1f       	adc	r31, r31
    1192:	ee 0f       	add	r30, r30
    1194:	ff 1f       	adc	r31, r31
    1196:	8e 0f       	add	r24, r30
    1198:	9f 1f       	adc	r25, r31
    119a:	fc 01       	movw	r30, r24
    119c:	e9 50       	subi	r30, 0x09	; 9
    119e:	fa 4f       	sbci	r31, 0xFA	; 250
    11a0:	80 81       	ld	r24, Z
    11a2:	82 30       	cpi	r24, 0x02	; 2
    11a4:	40 f4       	brcc	.+16     	; 0x11b6 <xTaskIncrementTick+0x156>
    11a6:	09 c0       	rjmp	.+18     	; 0x11ba <xTaskIncrementTick+0x15a>
    11a8:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxPendedTicks>
    11ac:	8f 5f       	subi	r24, 0xFF	; 255
    11ae:	80 93 c8 05 	sts	0x05C8, r24	; 0x8005c8 <uxPendedTicks>
    11b2:	d1 2c       	mov	r13, r1
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <xTaskIncrementTick+0x15a>
    11b6:	dd 24       	eor	r13, r13
    11b8:	d3 94       	inc	r13
    11ba:	80 91 c7 05 	lds	r24, 0x05C7	; 0x8005c7 <xYieldPending>
    11be:	88 23       	and	r24, r24
    11c0:	11 f0       	breq	.+4      	; 0x11c6 <xTaskIncrementTick+0x166>
    11c2:	dd 24       	eor	r13, r13
    11c4:	d3 94       	inc	r13
    11c6:	8d 2d       	mov	r24, r13
    11c8:	df 91       	pop	r29
    11ca:	cf 91       	pop	r28
    11cc:	1f 91       	pop	r17
    11ce:	0f 91       	pop	r16
    11d0:	ff 90       	pop	r15
    11d2:	ef 90       	pop	r14
    11d4:	df 90       	pop	r13
    11d6:	08 95       	ret

000011d8 <xTaskResumeAll>:
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	0f b6       	in	r0, 0x3f	; 63
    11e2:	f8 94       	cli
    11e4:	0f 92       	push	r0
    11e6:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <uxSchedulerSuspended>
    11ea:	81 50       	subi	r24, 0x01	; 1
    11ec:	80 93 c4 05 	sts	0x05C4, r24	; 0x8005c4 <uxSchedulerSuspended>
    11f0:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <uxSchedulerSuspended>
    11f4:	81 11       	cpse	r24, r1
    11f6:	57 c0       	rjmp	.+174    	; 0x12a6 <xTaskResumeAll+0xce>
    11f8:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <uxCurrentNumberOfTasks>
    11fc:	81 11       	cpse	r24, r1
    11fe:	32 c0       	rjmp	.+100    	; 0x1264 <xTaskResumeAll+0x8c>
    1200:	55 c0       	rjmp	.+170    	; 0x12ac <xTaskResumeAll+0xd4>
    1202:	e0 91 dd 05 	lds	r30, 0x05DD	; 0x8005dd <xPendingReadyList+0x5>
    1206:	f0 91 de 05 	lds	r31, 0x05DE	; 0x8005de <xPendingReadyList+0x6>
    120a:	c6 81       	ldd	r28, Z+6	; 0x06
    120c:	d7 81       	ldd	r29, Z+7	; 0x07
    120e:	ce 01       	movw	r24, r28
    1210:	0c 96       	adiw	r24, 0x0c	; 12
    1212:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1216:	8e 01       	movw	r16, r28
    1218:	0e 5f       	subi	r16, 0xFE	; 254
    121a:	1f 4f       	sbci	r17, 0xFF	; 255
    121c:	c8 01       	movw	r24, r16
    121e:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1222:	8e 89       	ldd	r24, Y+22	; 0x16
    1224:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    1228:	98 17       	cp	r25, r24
    122a:	10 f4       	brcc	.+4      	; 0x1230 <xTaskResumeAll+0x58>
    122c:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	9c 01       	movw	r18, r24
    1234:	22 0f       	add	r18, r18
    1236:	33 1f       	adc	r19, r19
    1238:	22 0f       	add	r18, r18
    123a:	33 1f       	adc	r19, r19
    123c:	22 0f       	add	r18, r18
    123e:	33 1f       	adc	r19, r19
    1240:	82 0f       	add	r24, r18
    1242:	93 1f       	adc	r25, r19
    1244:	b8 01       	movw	r22, r16
    1246:	89 50       	subi	r24, 0x09	; 9
    1248:	9a 4f       	sbci	r25, 0xFA	; 250
    124a:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    124e:	9e 89       	ldd	r25, Y+22	; 0x16
    1250:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    1254:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1258:	86 89       	ldd	r24, Z+22	; 0x16
    125a:	98 17       	cp	r25, r24
    125c:	18 f0       	brcs	.+6      	; 0x1264 <xTaskResumeAll+0x8c>
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xYieldPending>
    1264:	80 91 d8 05 	lds	r24, 0x05D8	; 0x8005d8 <xPendingReadyList>
    1268:	81 11       	cpse	r24, r1
    126a:	cb cf       	rjmp	.-106    	; 0x1202 <xTaskResumeAll+0x2a>
    126c:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxPendedTicks>
    1270:	81 11       	cpse	r24, r1
    1272:	0d c0       	rjmp	.+26     	; 0x128e <xTaskResumeAll+0xb6>
    1274:	10 c0       	rjmp	.+32     	; 0x1296 <xTaskResumeAll+0xbe>
    1276:	0e 94 30 08 	call	0x1060	; 0x1060 <xTaskIncrementTick>
    127a:	88 23       	and	r24, r24
    127c:	19 f0       	breq	.+6      	; 0x1284 <xTaskResumeAll+0xac>
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xYieldPending>
    1284:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxPendedTicks>
    1288:	81 50       	subi	r24, 0x01	; 1
    128a:	80 93 c8 05 	sts	0x05C8, r24	; 0x8005c8 <uxPendedTicks>
    128e:	80 91 c8 05 	lds	r24, 0x05C8	; 0x8005c8 <uxPendedTicks>
    1292:	81 11       	cpse	r24, r1
    1294:	f0 cf       	rjmp	.-32     	; 0x1276 <xTaskResumeAll+0x9e>
    1296:	80 91 c7 05 	lds	r24, 0x05C7	; 0x8005c7 <xYieldPending>
    129a:	81 30       	cpi	r24, 0x01	; 1
    129c:	31 f4       	brne	.+12     	; 0x12aa <xTaskResumeAll+0xd2>
    129e:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	03 c0       	rjmp	.+6      	; 0x12ac <xTaskResumeAll+0xd4>
    12a6:	80 e0       	ldi	r24, 0x00	; 0
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <xTaskResumeAll+0xd4>
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	0f 90       	pop	r0
    12ae:	0f be       	out	0x3f, r0	; 63
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	1f 91       	pop	r17
    12b6:	0f 91       	pop	r16
    12b8:	08 95       	ret

000012ba <vTaskDelay>:
    12ba:	cf 93       	push	r28
    12bc:	df 93       	push	r29
    12be:	ec 01       	movw	r28, r24
    12c0:	89 2b       	or	r24, r25
    12c2:	a9 f0       	breq	.+42     	; 0x12ee <vTaskDelay+0x34>
    12c4:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
    12c8:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xTickCount>
    12cc:	90 91 cc 05 	lds	r25, 0x05CC	; 0x8005cc <xTickCount+0x1>
    12d0:	c8 0f       	add	r28, r24
    12d2:	d9 1f       	adc	r29, r25
    12d4:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxCurrentTCB>
    12d8:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    12dc:	02 96       	adiw	r24, 0x02	; 2
    12de:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    12e2:	ce 01       	movw	r24, r28
    12e4:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    12e8:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
    12ec:	01 c0       	rjmp	.+2      	; 0x12f0 <vTaskDelay+0x36>
    12ee:	80 e0       	ldi	r24, 0x00	; 0
    12f0:	81 11       	cpse	r24, r1
    12f2:	02 c0       	rjmp	.+4      	; 0x12f8 <vTaskDelay+0x3e>
    12f4:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
    12fc:	08 95       	ret

000012fe <prvCheckTasksWaitingTermination>:
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	24 c0       	rjmp	.+72     	; 0x134c <prvCheckTasksWaitingTermination+0x4e>
    1304:	0e 94 2a 08 	call	0x1054	; 0x1054 <vTaskSuspendAll>
    1308:	c0 91 cf 05 	lds	r28, 0x05CF	; 0x8005cf <xTasksWaitingTermination>
    130c:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <xTaskResumeAll>
    1310:	cc 23       	and	r28, r28
    1312:	e1 f0       	breq	.+56     	; 0x134c <prvCheckTasksWaitingTermination+0x4e>
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	0f 92       	push	r0
    131a:	e0 91 d4 05 	lds	r30, 0x05D4	; 0x8005d4 <xTasksWaitingTermination+0x5>
    131e:	f0 91 d5 05 	lds	r31, 0x05D5	; 0x8005d5 <xTasksWaitingTermination+0x6>
    1322:	c6 81       	ldd	r28, Z+6	; 0x06
    1324:	d7 81       	ldd	r29, Z+7	; 0x07
    1326:	ce 01       	movw	r24, r28
    1328:	02 96       	adiw	r24, 0x02	; 2
    132a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    132e:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <uxCurrentNumberOfTasks>
    1332:	81 50       	subi	r24, 0x01	; 1
    1334:	80 93 cd 05 	sts	0x05CD, r24	; 0x8005cd <uxCurrentNumberOfTasks>
    1338:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <uxTasksDeleted>
    133c:	81 50       	subi	r24, 0x01	; 1
    133e:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <uxTasksDeleted>
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63
    1346:	ce 01       	movw	r24, r28
    1348:	0e 94 9b 06 	call	0xd36	; 0xd36 <prvDeleteTCB>
    134c:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <uxTasksDeleted>
    1350:	81 11       	cpse	r24, r1
    1352:	d8 cf       	rjmp	.-80     	; 0x1304 <prvCheckTasksWaitingTermination+0x6>
    1354:	df 91       	pop	r29
    1356:	cf 91       	pop	r28
    1358:	08 95       	ret

0000135a <prvIdleTask>:
    135a:	0e 94 7f 09 	call	0x12fe	; 0x12fe <prvCheckTasksWaitingTermination>
    135e:	80 91 f7 05 	lds	r24, 0x05F7	; 0x8005f7 <pxReadyTasksLists>
    1362:	82 30       	cpi	r24, 0x02	; 2
    1364:	d0 f3       	brcs	.-12     	; 0x135a <prvIdleTask>
    1366:	0e 94 e5 02 	call	0x5ca	; 0x5ca <vPortYield>
    136a:	f7 cf       	rjmp	.-18     	; 0x135a <prvIdleTask>

0000136c <vTaskSwitchContext>:
    136c:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <uxSchedulerSuspended>
    1370:	88 23       	and	r24, r24
    1372:	21 f0       	breq	.+8      	; 0x137c <vTaskSwitchContext+0x10>
    1374:	81 e0       	ldi	r24, 0x01	; 1
    1376:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xYieldPending>
    137a:	08 95       	ret
    137c:	10 92 c7 05 	sts	0x05C7, r1	; 0x8005c7 <xYieldPending>
    1380:	05 c0       	rjmp	.+10     	; 0x138c <vTaskSwitchContext+0x20>
    1382:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    1386:	81 50       	subi	r24, 0x01	; 1
    1388:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    138c:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    1390:	90 e0       	ldi	r25, 0x00	; 0
    1392:	fc 01       	movw	r30, r24
    1394:	ee 0f       	add	r30, r30
    1396:	ff 1f       	adc	r31, r31
    1398:	ee 0f       	add	r30, r30
    139a:	ff 1f       	adc	r31, r31
    139c:	ee 0f       	add	r30, r30
    139e:	ff 1f       	adc	r31, r31
    13a0:	8e 0f       	add	r24, r30
    13a2:	9f 1f       	adc	r25, r31
    13a4:	fc 01       	movw	r30, r24
    13a6:	e9 50       	subi	r30, 0x09	; 9
    13a8:	fa 4f       	sbci	r31, 0xFA	; 250
    13aa:	80 81       	ld	r24, Z
    13ac:	88 23       	and	r24, r24
    13ae:	49 f3       	breq	.-46     	; 0x1382 <vTaskSwitchContext+0x16>
    13b0:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	9c 01       	movw	r18, r24
    13b8:	22 0f       	add	r18, r18
    13ba:	33 1f       	adc	r19, r19
    13bc:	22 0f       	add	r18, r18
    13be:	33 1f       	adc	r19, r19
    13c0:	22 0f       	add	r18, r18
    13c2:	33 1f       	adc	r19, r19
    13c4:	28 0f       	add	r18, r24
    13c6:	39 1f       	adc	r19, r25
    13c8:	d9 01       	movw	r26, r18
    13ca:	a9 50       	subi	r26, 0x09	; 9
    13cc:	ba 4f       	sbci	r27, 0xFA	; 250
    13ce:	11 96       	adiw	r26, 0x01	; 1
    13d0:	ed 91       	ld	r30, X+
    13d2:	fc 91       	ld	r31, X
    13d4:	12 97       	sbiw	r26, 0x02	; 2
    13d6:	02 80       	ldd	r0, Z+2	; 0x02
    13d8:	f3 81       	ldd	r31, Z+3	; 0x03
    13da:	e0 2d       	mov	r30, r0
    13dc:	12 96       	adiw	r26, 0x02	; 2
    13de:	fc 93       	st	X, r31
    13e0:	ee 93       	st	-X, r30
    13e2:	11 97       	sbiw	r26, 0x01	; 1
    13e4:	26 50       	subi	r18, 0x06	; 6
    13e6:	3a 4f       	sbci	r19, 0xFA	; 250
    13e8:	e2 17       	cp	r30, r18
    13ea:	f3 07       	cpc	r31, r19
    13ec:	29 f4       	brne	.+10     	; 0x13f8 <vTaskSwitchContext+0x8c>
    13ee:	22 81       	ldd	r18, Z+2	; 0x02
    13f0:	33 81       	ldd	r19, Z+3	; 0x03
    13f2:	fd 01       	movw	r30, r26
    13f4:	32 83       	std	Z+2, r19	; 0x02
    13f6:	21 83       	std	Z+1, r18	; 0x01
    13f8:	fc 01       	movw	r30, r24
    13fa:	ee 0f       	add	r30, r30
    13fc:	ff 1f       	adc	r31, r31
    13fe:	ee 0f       	add	r30, r30
    1400:	ff 1f       	adc	r31, r31
    1402:	ee 0f       	add	r30, r30
    1404:	ff 1f       	adc	r31, r31
    1406:	8e 0f       	add	r24, r30
    1408:	9f 1f       	adc	r25, r31
    140a:	fc 01       	movw	r30, r24
    140c:	e9 50       	subi	r30, 0x09	; 9
    140e:	fa 4f       	sbci	r31, 0xFA	; 250
    1410:	01 80       	ldd	r0, Z+1	; 0x01
    1412:	f2 81       	ldd	r31, Z+2	; 0x02
    1414:	e0 2d       	mov	r30, r0
    1416:	86 81       	ldd	r24, Z+6	; 0x06
    1418:	97 81       	ldd	r25, Z+7	; 0x07
    141a:	90 93 2e 06 	sts	0x062E, r25	; 0x80062e <pxCurrentTCB+0x1>
    141e:	80 93 2d 06 	sts	0x062D, r24	; 0x80062d <pxCurrentTCB>
    1422:	08 95       	ret

00001424 <vTaskPlaceOnEventList>:
    1424:	cf 93       	push	r28
    1426:	df 93       	push	r29
    1428:	eb 01       	movw	r28, r22
    142a:	60 91 2d 06 	lds	r22, 0x062D	; 0x80062d <pxCurrentTCB>
    142e:	70 91 2e 06 	lds	r23, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1432:	64 5f       	subi	r22, 0xF4	; 244
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInsert>
    143a:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxCurrentTCB>
    143e:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1442:	02 96       	adiw	r24, 0x02	; 2
    1444:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1448:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xTickCount>
    144c:	90 91 cc 05 	lds	r25, 0x05CC	; 0x8005cc <xTickCount+0x1>
    1450:	8c 0f       	add	r24, r28
    1452:	9d 1f       	adc	r25, r29
    1454:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	08 95       	ret

0000145e <vTaskPlaceOnUnorderedEventList>:
    145e:	cf 93       	push	r28
    1460:	df 93       	push	r29
    1462:	ea 01       	movw	r28, r20
    1464:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    1468:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    146c:	70 68       	ori	r23, 0x80	; 128
    146e:	75 87       	std	Z+13, r23	; 0x0d
    1470:	64 87       	std	Z+12, r22	; 0x0c
    1472:	60 91 2d 06 	lds	r22, 0x062D	; 0x80062d <pxCurrentTCB>
    1476:	70 91 2e 06 	lds	r23, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    147a:	64 5f       	subi	r22, 0xF4	; 244
    147c:	7f 4f       	sbci	r23, 0xFF	; 255
    147e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1482:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxCurrentTCB>
    1486:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    148a:	02 96       	adiw	r24, 0x02	; 2
    148c:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    1490:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <xTickCount>
    1494:	90 91 cc 05 	lds	r25, 0x05CC	; 0x8005cc <xTickCount+0x1>
    1498:	8c 0f       	add	r24, r28
    149a:	9d 1f       	adc	r25, r29
    149c:	0e 94 10 07 	call	0xe20	; 0xe20 <prvAddCurrentTaskToDelayedList>
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	08 95       	ret

000014a6 <xTaskRemoveFromEventList>:
    14a6:	0f 93       	push	r16
    14a8:	1f 93       	push	r17
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	dc 01       	movw	r26, r24
    14b0:	15 96       	adiw	r26, 0x05	; 5
    14b2:	ed 91       	ld	r30, X+
    14b4:	fc 91       	ld	r31, X
    14b6:	16 97       	sbiw	r26, 0x06	; 6
    14b8:	c6 81       	ldd	r28, Z+6	; 0x06
    14ba:	d7 81       	ldd	r29, Z+7	; 0x07
    14bc:	8e 01       	movw	r16, r28
    14be:	04 5f       	subi	r16, 0xF4	; 244
    14c0:	1f 4f       	sbci	r17, 0xFF	; 255
    14c2:	c8 01       	movw	r24, r16
    14c4:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    14c8:	80 91 c4 05 	lds	r24, 0x05C4	; 0x8005c4 <uxSchedulerSuspended>
    14cc:	81 11       	cpse	r24, r1
    14ce:	1c c0       	rjmp	.+56     	; 0x1508 <xTaskRemoveFromEventList+0x62>
    14d0:	0a 50       	subi	r16, 0x0A	; 10
    14d2:	11 09       	sbc	r17, r1
    14d4:	c8 01       	movw	r24, r16
    14d6:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    14da:	8e 89       	ldd	r24, Y+22	; 0x16
    14dc:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    14e0:	98 17       	cp	r25, r24
    14e2:	10 f4       	brcc	.+4      	; 0x14e8 <xTaskRemoveFromEventList+0x42>
    14e4:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    14e8:	90 e0       	ldi	r25, 0x00	; 0
    14ea:	9c 01       	movw	r18, r24
    14ec:	22 0f       	add	r18, r18
    14ee:	33 1f       	adc	r19, r19
    14f0:	22 0f       	add	r18, r18
    14f2:	33 1f       	adc	r19, r19
    14f4:	22 0f       	add	r18, r18
    14f6:	33 1f       	adc	r19, r19
    14f8:	82 0f       	add	r24, r18
    14fa:	93 1f       	adc	r25, r19
    14fc:	b8 01       	movw	r22, r16
    14fe:	89 50       	subi	r24, 0x09	; 9
    1500:	9a 4f       	sbci	r25, 0xFA	; 250
    1502:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1506:	05 c0       	rjmp	.+10     	; 0x1512 <xTaskRemoveFromEventList+0x6c>
    1508:	b8 01       	movw	r22, r16
    150a:	88 ed       	ldi	r24, 0xD8	; 216
    150c:	95 e0       	ldi	r25, 0x05	; 5
    150e:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1512:	9e 89       	ldd	r25, Y+22	; 0x16
    1514:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    1518:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    151c:	86 89       	ldd	r24, Z+22	; 0x16
    151e:	89 17       	cp	r24, r25
    1520:	20 f4       	brcc	.+8      	; 0x152a <xTaskRemoveFromEventList+0x84>
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xYieldPending>
    1528:	01 c0       	rjmp	.+2      	; 0x152c <xTaskRemoveFromEventList+0x86>
    152a:	80 e0       	ldi	r24, 0x00	; 0
    152c:	df 91       	pop	r29
    152e:	cf 91       	pop	r28
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	08 95       	ret

00001536 <xTaskRemoveFromUnorderedEventList>:
    1536:	0f 93       	push	r16
    1538:	1f 93       	push	r17
    153a:	cf 93       	push	r28
    153c:	df 93       	push	r29
    153e:	70 68       	ori	r23, 0x80	; 128
    1540:	fc 01       	movw	r30, r24
    1542:	71 83       	std	Z+1, r23	; 0x01
    1544:	60 83       	st	Z, r22
    1546:	c6 81       	ldd	r28, Z+6	; 0x06
    1548:	d7 81       	ldd	r29, Z+7	; 0x07
    154a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    154e:	8e 01       	movw	r16, r28
    1550:	0e 5f       	subi	r16, 0xFE	; 254
    1552:	1f 4f       	sbci	r17, 0xFF	; 255
    1554:	c8 01       	movw	r24, r16
    1556:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
    155a:	8e 89       	ldd	r24, Y+22	; 0x16
    155c:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    1560:	98 17       	cp	r25, r24
    1562:	10 f4       	brcc	.+4      	; 0x1568 <xTaskRemoveFromUnorderedEventList+0x32>
    1564:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	9c 01       	movw	r18, r24
    156c:	22 0f       	add	r18, r18
    156e:	33 1f       	adc	r19, r19
    1570:	22 0f       	add	r18, r18
    1572:	33 1f       	adc	r19, r19
    1574:	22 0f       	add	r18, r18
    1576:	33 1f       	adc	r19, r19
    1578:	82 0f       	add	r24, r18
    157a:	93 1f       	adc	r25, r19
    157c:	b8 01       	movw	r22, r16
    157e:	89 50       	subi	r24, 0x09	; 9
    1580:	9a 4f       	sbci	r25, 0xFA	; 250
    1582:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    1586:	9e 89       	ldd	r25, Y+22	; 0x16
    1588:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    158c:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1590:	86 89       	ldd	r24, Z+22	; 0x16
    1592:	89 17       	cp	r24, r25
    1594:	20 f4       	brcc	.+8      	; 0x159e <xTaskRemoveFromUnorderedEventList+0x68>
    1596:	81 e0       	ldi	r24, 0x01	; 1
    1598:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xYieldPending>
    159c:	01 c0       	rjmp	.+2      	; 0x15a0 <xTaskRemoveFromUnorderedEventList+0x6a>
    159e:	80 e0       	ldi	r24, 0x00	; 0
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	08 95       	ret

000015aa <vTaskSetTimeOutState>:
    15aa:	20 91 c6 05 	lds	r18, 0x05C6	; 0x8005c6 <xNumOfOverflows>
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
    15b2:	20 91 cb 05 	lds	r18, 0x05CB	; 0x8005cb <xTickCount>
    15b6:	30 91 cc 05 	lds	r19, 0x05CC	; 0x8005cc <xTickCount+0x1>
    15ba:	32 83       	std	Z+2, r19	; 0x02
    15bc:	21 83       	std	Z+1, r18	; 0x01
    15be:	08 95       	ret

000015c0 <xTaskCheckForTimeOut>:
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	fc 01       	movw	r30, r24
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
    15cc:	40 91 cb 05 	lds	r20, 0x05CB	; 0x8005cb <xTickCount>
    15d0:	50 91 cc 05 	lds	r21, 0x05CC	; 0x8005cc <xTickCount+0x1>
    15d4:	90 81       	ld	r25, Z
    15d6:	80 91 c6 05 	lds	r24, 0x05C6	; 0x8005c6 <xNumOfOverflows>
    15da:	98 17       	cp	r25, r24
    15dc:	29 f0       	breq	.+10     	; 0x15e8 <xTaskCheckForTimeOut+0x28>
    15de:	81 81       	ldd	r24, Z+1	; 0x01
    15e0:	92 81       	ldd	r25, Z+2	; 0x02
    15e2:	48 17       	cp	r20, r24
    15e4:	59 07       	cpc	r21, r25
    15e6:	b0 f4       	brcc	.+44     	; 0x1614 <xTaskCheckForTimeOut+0x54>
    15e8:	21 81       	ldd	r18, Z+1	; 0x01
    15ea:	32 81       	ldd	r19, Z+2	; 0x02
    15ec:	ca 01       	movw	r24, r20
    15ee:	82 1b       	sub	r24, r18
    15f0:	93 0b       	sbc	r25, r19
    15f2:	eb 01       	movw	r28, r22
    15f4:	a8 81       	ld	r26, Y
    15f6:	b9 81       	ldd	r27, Y+1	; 0x01
    15f8:	8a 17       	cp	r24, r26
    15fa:	9b 07       	cpc	r25, r27
    15fc:	68 f4       	brcc	.+26     	; 0x1618 <xTaskCheckForTimeOut+0x58>
    15fe:	cf 01       	movw	r24, r30
    1600:	24 1b       	sub	r18, r20
    1602:	35 0b       	sbc	r19, r21
    1604:	2a 0f       	add	r18, r26
    1606:	3b 1f       	adc	r19, r27
    1608:	39 83       	std	Y+1, r19	; 0x01
    160a:	28 83       	st	Y, r18
    160c:	0e 94 d5 0a 	call	0x15aa	; 0x15aa <vTaskSetTimeOutState>
    1610:	80 e0       	ldi	r24, 0x00	; 0
    1612:	03 c0       	rjmp	.+6      	; 0x161a <xTaskCheckForTimeOut+0x5a>
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	01 c0       	rjmp	.+2      	; 0x161a <xTaskCheckForTimeOut+0x5a>
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	df 91       	pop	r29
    1620:	cf 91       	pop	r28
    1622:	08 95       	ret

00001624 <vTaskMissedYield>:
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <xYieldPending>
    162a:	08 95       	ret

0000162c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    1636:	89 2b       	or	r24, r25
    1638:	09 f4       	brne	.+2      	; 0x163c <vTaskPriorityInherit+0x10>
    163a:	55 c0       	rjmp	.+170    	; 0x16e6 <vTaskPriorityInherit+0xba>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    163c:	26 89       	ldd	r18, Z+22	; 0x16
    163e:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
    1642:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1646:	56 96       	adiw	r26, 0x16	; 22
    1648:	8c 91       	ld	r24, X
    164a:	28 17       	cp	r18, r24
    164c:	08 f0       	brcs	.+2      	; 0x1650 <vTaskPriorityInherit+0x24>
    164e:	4b c0       	rjmp	.+150    	; 0x16e6 <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1650:	84 85       	ldd	r24, Z+12	; 0x0c
    1652:	95 85       	ldd	r25, Z+13	; 0x0d
    1654:	99 23       	and	r25, r25
    1656:	64 f0       	brlt	.+24     	; 0x1670 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1658:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
    165c:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1660:	56 96       	adiw	r26, 0x16	; 22
    1662:	3c 91       	ld	r19, X
    1664:	86 e0       	ldi	r24, 0x06	; 6
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	83 1b       	sub	r24, r19
    166a:	91 09       	sbc	r25, r1
    166c:	95 87       	std	Z+13, r25	; 0x0d
    166e:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1670:	82 85       	ldd	r24, Z+10	; 0x0a
    1672:	93 85       	ldd	r25, Z+11	; 0x0b
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	a9 01       	movw	r20, r18
    1678:	44 0f       	add	r20, r20
    167a:	55 1f       	adc	r21, r21
    167c:	44 0f       	add	r20, r20
    167e:	55 1f       	adc	r21, r21
    1680:	44 0f       	add	r20, r20
    1682:	55 1f       	adc	r21, r21
    1684:	24 0f       	add	r18, r20
    1686:	35 1f       	adc	r19, r21
    1688:	29 50       	subi	r18, 0x09	; 9
    168a:	3a 4f       	sbci	r19, 0xFA	; 250
    168c:	82 17       	cp	r24, r18
    168e:	93 07       	cpc	r25, r19
    1690:	19 f5       	brne	.+70     	; 0x16d8 <vTaskPriorityInherit+0xac>
    1692:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1694:	ef 01       	movw	r28, r30
    1696:	22 96       	adiw	r28, 0x02	; 2
    1698:	ce 01       	movw	r24, r28
    169a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    169e:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    16a2:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    16a6:	86 89       	ldd	r24, Z+22	; 0x16
    16a8:	f8 01       	movw	r30, r16
    16aa:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    16ac:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    16b0:	98 17       	cp	r25, r24
    16b2:	10 f4       	brcc	.+4      	; 0x16b8 <vTaskPriorityInherit+0x8c>
    16b4:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	9c 01       	movw	r18, r24
    16bc:	22 0f       	add	r18, r18
    16be:	33 1f       	adc	r19, r19
    16c0:	22 0f       	add	r18, r18
    16c2:	33 1f       	adc	r19, r19
    16c4:	22 0f       	add	r18, r18
    16c6:	33 1f       	adc	r19, r19
    16c8:	82 0f       	add	r24, r18
    16ca:	93 1f       	adc	r25, r19
    16cc:	be 01       	movw	r22, r28
    16ce:	89 50       	subi	r24, 0x09	; 9
    16d0:	9a 4f       	sbci	r25, 0xFA	; 250
    16d2:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>
    16d6:	07 c0       	rjmp	.+14     	; 0x16e6 <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    16d8:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
    16dc:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    16e0:	56 96       	adiw	r26, 0x16	; 22
    16e2:	8c 91       	ld	r24, X
    16e4:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    16e6:	df 91       	pop	r29
    16e8:	cf 91       	pop	r28
    16ea:	1f 91       	pop	r17
    16ec:	0f 91       	pop	r16
    16ee:	08 95       	ret

000016f0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    16fa:	89 2b       	or	r24, r25
    16fc:	79 f1       	breq	.+94     	; 0x175c <xTaskPriorityDisinherit+0x6c>
		{
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    16fe:	83 a9       	ldd	r24, Z+51	; 0x33
    1700:	81 50       	subi	r24, 0x01	; 1
    1702:	83 ab       	std	Z+51, r24	; 0x33

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1704:	26 89       	ldd	r18, Z+22	; 0x16
    1706:	92 a9       	ldd	r25, Z+50	; 0x32
    1708:	29 17       	cp	r18, r25
    170a:	51 f1       	breq	.+84     	; 0x1760 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    170c:	81 11       	cpse	r24, r1
    170e:	2a c0       	rjmp	.+84     	; 0x1764 <xTaskPriorityDisinherit+0x74>
    1710:	ef 01       	movw	r28, r30
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1712:	8f 01       	movw	r16, r30
    1714:	0e 5f       	subi	r16, 0xFE	; 254
    1716:	1f 4f       	sbci	r17, 0xFF	; 255
    1718:	c8 01       	movw	r24, r16
    171a:	0e 94 1b 02 	call	0x436	; 0x436 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    171e:	8a a9       	ldd	r24, Y+50	; 0x32
    1720:	8e 8b       	std	Y+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1722:	26 e0       	ldi	r18, 0x06	; 6
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	28 1b       	sub	r18, r24
    1728:	31 09       	sbc	r19, r1
    172a:	3d 87       	std	Y+13, r19	; 0x0d
    172c:	2c 87       	std	Y+12, r18	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    172e:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <uxTopReadyPriority>
    1732:	98 17       	cp	r25, r24
    1734:	10 f4       	brcc	.+4      	; 0x173a <xTaskPriorityDisinherit+0x4a>
    1736:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <uxTopReadyPriority>
    173a:	90 e0       	ldi	r25, 0x00	; 0
    173c:	9c 01       	movw	r18, r24
    173e:	22 0f       	add	r18, r18
    1740:	33 1f       	adc	r19, r19
    1742:	22 0f       	add	r18, r18
    1744:	33 1f       	adc	r19, r19
    1746:	22 0f       	add	r18, r18
    1748:	33 1f       	adc	r19, r19
    174a:	82 0f       	add	r24, r18
    174c:	93 1f       	adc	r25, r19
    174e:	b8 01       	movw	r22, r16
    1750:	89 50       	subi	r24, 0x09	; 9
    1752:	9a 4f       	sbci	r25, 0xFA	; 250
    1754:	0e 94 c9 01 	call	0x392	; 0x392 <vListInsertEnd>

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	05 c0       	rjmp	.+10     	; 0x1766 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    175c:	80 e0       	ldi	r24, 0x00	; 0
    175e:	03 c0       	rjmp	.+6      	; 0x1766 <xTaskPriorityDisinherit+0x76>
    1760:	80 e0       	ldi	r24, 0x00	; 0
    1762:	01 c0       	rjmp	.+2      	; 0x1766 <xTaskPriorityDisinherit+0x76>
    1764:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    1766:	df 91       	pop	r29
    1768:	cf 91       	pop	r28
    176a:	1f 91       	pop	r17
    176c:	0f 91       	pop	r16
    176e:	08 95       	ret

00001770 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    1770:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    1774:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1778:	84 85       	ldd	r24, Z+12	; 0x0c
    177a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    177c:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    1780:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    1784:	a0 91 2d 06 	lds	r26, 0x062D	; 0x80062d <pxCurrentTCB>
    1788:	b0 91 2e 06 	lds	r27, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    178c:	56 96       	adiw	r26, 0x16	; 22
    178e:	4c 91       	ld	r20, X
    1790:	26 e0       	ldi	r18, 0x06	; 6
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	24 1b       	sub	r18, r20
    1796:	31 09       	sbc	r19, r1
    1798:	35 87       	std	Z+13, r19	; 0x0d
    179a:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    179c:	08 95       	ret

0000179e <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    179e:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxCurrentTCB>
    17a2:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    17a6:	89 2b       	or	r24, r25
    17a8:	39 f0       	breq	.+14     	; 0x17b8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17aa:	e0 91 2d 06 	lds	r30, 0x062D	; 0x80062d <pxCurrentTCB>
    17ae:	f0 91 2e 06 	lds	r31, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
    17b2:	83 a9       	ldd	r24, Z+51	; 0x33
    17b4:	8f 5f       	subi	r24, 0xFF	; 255
    17b6:	83 ab       	std	Z+51, r24	; 0x33
		}

		return pxCurrentTCB;
    17b8:	80 91 2d 06 	lds	r24, 0x062D	; 0x80062d <pxCurrentTCB>
    17bc:	90 91 2e 06 	lds	r25, 0x062E	; 0x80062e <pxCurrentTCB+0x1>
	}
    17c0:	08 95       	ret

000017c2 <LCD_SendCommand>:

void LCD_DisplayCustomCharacterRowCol(uint8 location , uint8 row ,uint8 col)
{
    LCD_MoveCursor(row,col);
    LCD_DisplayCharacter(location);
}
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	c8 2f       	mov	r28, r24
    17c8:	40 e0       	ldi	r20, 0x00	; 0
    17ca:	63 e0       	ldi	r22, 0x03	; 3
    17cc:	80 e0       	ldi	r24, 0x00	; 0
    17ce:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    17d2:	8f ec       	ldi	r24, 0xCF	; 207
    17d4:	97 e0       	ldi	r25, 0x07	; 7
    17d6:	01 97       	sbiw	r24, 0x01	; 1
    17d8:	f1 f7       	brne	.-4      	; 0x17d6 <LCD_SendCommand+0x14>
    17da:	00 c0       	rjmp	.+0      	; 0x17dc <LCD_SendCommand+0x1a>
    17dc:	00 00       	nop
    17de:	41 e0       	ldi	r20, 0x01	; 1
    17e0:	62 e0       	ldi	r22, 0x02	; 2
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    17e8:	8f ec       	ldi	r24, 0xCF	; 207
    17ea:	97 e0       	ldi	r25, 0x07	; 7
    17ec:	01 97       	sbiw	r24, 0x01	; 1
    17ee:	f1 f7       	brne	.-4      	; 0x17ec <LCD_SendCommand+0x2a>
    17f0:	00 c0       	rjmp	.+0      	; 0x17f2 <LCD_SendCommand+0x30>
    17f2:	00 00       	nop
    17f4:	dc 2f       	mov	r29, r28
    17f6:	d2 95       	swap	r29
    17f8:	df 70       	andi	r29, 0x0F	; 15
    17fa:	4d 2f       	mov	r20, r29
    17fc:	41 70       	andi	r20, 0x01	; 1
    17fe:	60 e0       	ldi	r22, 0x00	; 0
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1806:	d1 fb       	bst	r29, 1
    1808:	44 27       	eor	r20, r20
    180a:	40 f9       	bld	r20, 0
    180c:	61 e0       	ldi	r22, 0x01	; 1
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1814:	d2 fb       	bst	r29, 2
    1816:	44 27       	eor	r20, r20
    1818:	40 f9       	bld	r20, 0
    181a:	62 e0       	ldi	r22, 0x02	; 2
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1822:	4c 2f       	mov	r20, r28
    1824:	44 1f       	adc	r20, r20
    1826:	44 27       	eor	r20, r20
    1828:	44 1f       	adc	r20, r20
    182a:	64 e0       	ldi	r22, 0x04	; 4
    182c:	81 e0       	ldi	r24, 0x01	; 1
    182e:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1832:	8f ec       	ldi	r24, 0xCF	; 207
    1834:	97 e0       	ldi	r25, 0x07	; 7
    1836:	01 97       	sbiw	r24, 0x01	; 1
    1838:	f1 f7       	brne	.-4      	; 0x1836 <LCD_SendCommand+0x74>
    183a:	00 c0       	rjmp	.+0      	; 0x183c <LCD_SendCommand+0x7a>
    183c:	00 00       	nop
    183e:	40 e0       	ldi	r20, 0x00	; 0
    1840:	62 e0       	ldi	r22, 0x02	; 2
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1848:	8f ec       	ldi	r24, 0xCF	; 207
    184a:	97 e0       	ldi	r25, 0x07	; 7
    184c:	01 97       	sbiw	r24, 0x01	; 1
    184e:	f1 f7       	brne	.-4      	; 0x184c <LCD_SendCommand+0x8a>
    1850:	00 c0       	rjmp	.+0      	; 0x1852 <LCD_SendCommand+0x90>
    1852:	00 00       	nop
    1854:	41 e0       	ldi	r20, 0x01	; 1
    1856:	62 e0       	ldi	r22, 0x02	; 2
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    185e:	8f ec       	ldi	r24, 0xCF	; 207
    1860:	97 e0       	ldi	r25, 0x07	; 7
    1862:	01 97       	sbiw	r24, 0x01	; 1
    1864:	f1 f7       	brne	.-4      	; 0x1862 <LCD_SendCommand+0xa0>
    1866:	00 c0       	rjmp	.+0      	; 0x1868 <LCD_SendCommand+0xa6>
    1868:	00 00       	nop
    186a:	dc 2f       	mov	r29, r28
    186c:	df 70       	andi	r29, 0x0F	; 15
    186e:	4c 2f       	mov	r20, r28
    1870:	41 70       	andi	r20, 0x01	; 1
    1872:	60 e0       	ldi	r22, 0x00	; 0
    1874:	81 e0       	ldi	r24, 0x01	; 1
    1876:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    187a:	d1 fb       	bst	r29, 1
    187c:	44 27       	eor	r20, r20
    187e:	40 f9       	bld	r20, 0
    1880:	61 e0       	ldi	r22, 0x01	; 1
    1882:	81 e0       	ldi	r24, 0x01	; 1
    1884:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1888:	d2 fb       	bst	r29, 2
    188a:	44 27       	eor	r20, r20
    188c:	40 f9       	bld	r20, 0
    188e:	62 e0       	ldi	r22, 0x02	; 2
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1896:	4d 2f       	mov	r20, r29
    1898:	46 95       	lsr	r20
    189a:	46 95       	lsr	r20
    189c:	46 95       	lsr	r20
    189e:	64 e0       	ldi	r22, 0x04	; 4
    18a0:	81 e0       	ldi	r24, 0x01	; 1
    18a2:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    18a6:	8f ec       	ldi	r24, 0xCF	; 207
    18a8:	97 e0       	ldi	r25, 0x07	; 7
    18aa:	01 97       	sbiw	r24, 0x01	; 1
    18ac:	f1 f7       	brne	.-4      	; 0x18aa <LCD_SendCommand+0xe8>
    18ae:	00 c0       	rjmp	.+0      	; 0x18b0 <LCD_SendCommand+0xee>
    18b0:	00 00       	nop
    18b2:	40 e0       	ldi	r20, 0x00	; 0
    18b4:	62 e0       	ldi	r22, 0x02	; 2
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    18bc:	8f ec       	ldi	r24, 0xCF	; 207
    18be:	97 e0       	ldi	r25, 0x07	; 7
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	f1 f7       	brne	.-4      	; 0x18c0 <LCD_SendCommand+0xfe>
    18c4:	00 c0       	rjmp	.+0      	; 0x18c6 <LCD_SendCommand+0x104>
    18c6:	00 00       	nop
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	08 95       	ret

000018ce <LCD_init>:
    18ce:	42 e0       	ldi	r20, 0x02	; 2
    18d0:	63 e0       	ldi	r22, 0x03	; 3
    18d2:	80 e0       	ldi	r24, 0x00	; 0
    18d4:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    18d8:	42 e0       	ldi	r20, 0x02	; 2
    18da:	62 e0       	ldi	r22, 0x02	; 2
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    18e2:	42 e0       	ldi	r20, 0x02	; 2
    18e4:	60 e0       	ldi	r22, 0x00	; 0
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    18ec:	42 e0       	ldi	r20, 0x02	; 2
    18ee:	61 e0       	ldi	r22, 0x01	; 1
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    18f6:	42 e0       	ldi	r20, 0x02	; 2
    18f8:	62 e0       	ldi	r22, 0x02	; 2
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    1900:	42 e0       	ldi	r20, 0x02	; 2
    1902:	64 e0       	ldi	r22, 0x04	; 4
    1904:	81 e0       	ldi	r24, 0x01	; 1
    1906:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    190a:	82 e0       	ldi	r24, 0x02	; 2
    190c:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1910:	88 e2       	ldi	r24, 0x28	; 40
    1912:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1916:	8c e0       	ldi	r24, 0x0C	; 12
    1918:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1922:	08 95       	ret

00001924 <LCD_DisplayCharacter>:
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	c8 2f       	mov	r28, r24
    192a:	41 e0       	ldi	r20, 0x01	; 1
    192c:	63 e0       	ldi	r22, 0x03	; 3
    192e:	80 e0       	ldi	r24, 0x00	; 0
    1930:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1934:	8f ec       	ldi	r24, 0xCF	; 207
    1936:	97 e0       	ldi	r25, 0x07	; 7
    1938:	01 97       	sbiw	r24, 0x01	; 1
    193a:	f1 f7       	brne	.-4      	; 0x1938 <LCD_DisplayCharacter+0x14>
    193c:	00 c0       	rjmp	.+0      	; 0x193e <LCD_DisplayCharacter+0x1a>
    193e:	00 00       	nop
    1940:	41 e0       	ldi	r20, 0x01	; 1
    1942:	62 e0       	ldi	r22, 0x02	; 2
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    194a:	8f ec       	ldi	r24, 0xCF	; 207
    194c:	97 e0       	ldi	r25, 0x07	; 7
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	f1 f7       	brne	.-4      	; 0x194e <LCD_DisplayCharacter+0x2a>
    1952:	00 c0       	rjmp	.+0      	; 0x1954 <LCD_DisplayCharacter+0x30>
    1954:	00 00       	nop
    1956:	dc 2f       	mov	r29, r28
    1958:	d2 95       	swap	r29
    195a:	df 70       	andi	r29, 0x0F	; 15
    195c:	4d 2f       	mov	r20, r29
    195e:	41 70       	andi	r20, 0x01	; 1
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1968:	d1 fb       	bst	r29, 1
    196a:	44 27       	eor	r20, r20
    196c:	40 f9       	bld	r20, 0
    196e:	61 e0       	ldi	r22, 0x01	; 1
    1970:	81 e0       	ldi	r24, 0x01	; 1
    1972:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1976:	d2 fb       	bst	r29, 2
    1978:	44 27       	eor	r20, r20
    197a:	40 f9       	bld	r20, 0
    197c:	62 e0       	ldi	r22, 0x02	; 2
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1984:	4c 2f       	mov	r20, r28
    1986:	44 1f       	adc	r20, r20
    1988:	44 27       	eor	r20, r20
    198a:	44 1f       	adc	r20, r20
    198c:	64 e0       	ldi	r22, 0x04	; 4
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1994:	8f ec       	ldi	r24, 0xCF	; 207
    1996:	97 e0       	ldi	r25, 0x07	; 7
    1998:	01 97       	sbiw	r24, 0x01	; 1
    199a:	f1 f7       	brne	.-4      	; 0x1998 <LCD_DisplayCharacter+0x74>
    199c:	00 c0       	rjmp	.+0      	; 0x199e <LCD_DisplayCharacter+0x7a>
    199e:	00 00       	nop
    19a0:	40 e0       	ldi	r20, 0x00	; 0
    19a2:	62 e0       	ldi	r22, 0x02	; 2
    19a4:	80 e0       	ldi	r24, 0x00	; 0
    19a6:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    19aa:	8f ec       	ldi	r24, 0xCF	; 207
    19ac:	97 e0       	ldi	r25, 0x07	; 7
    19ae:	01 97       	sbiw	r24, 0x01	; 1
    19b0:	f1 f7       	brne	.-4      	; 0x19ae <LCD_DisplayCharacter+0x8a>
    19b2:	00 c0       	rjmp	.+0      	; 0x19b4 <LCD_DisplayCharacter+0x90>
    19b4:	00 00       	nop
    19b6:	41 e0       	ldi	r20, 0x01	; 1
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    19c0:	8f ec       	ldi	r24, 0xCF	; 207
    19c2:	97 e0       	ldi	r25, 0x07	; 7
    19c4:	01 97       	sbiw	r24, 0x01	; 1
    19c6:	f1 f7       	brne	.-4      	; 0x19c4 <LCD_DisplayCharacter+0xa0>
    19c8:	00 c0       	rjmp	.+0      	; 0x19ca <LCD_DisplayCharacter+0xa6>
    19ca:	00 00       	nop
    19cc:	dc 2f       	mov	r29, r28
    19ce:	df 70       	andi	r29, 0x0F	; 15
    19d0:	4c 2f       	mov	r20, r28
    19d2:	41 70       	andi	r20, 0x01	; 1
    19d4:	60 e0       	ldi	r22, 0x00	; 0
    19d6:	81 e0       	ldi	r24, 0x01	; 1
    19d8:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    19dc:	d1 fb       	bst	r29, 1
    19de:	44 27       	eor	r20, r20
    19e0:	40 f9       	bld	r20, 0
    19e2:	61 e0       	ldi	r22, 0x01	; 1
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    19ea:	d2 fb       	bst	r29, 2
    19ec:	44 27       	eor	r20, r20
    19ee:	40 f9       	bld	r20, 0
    19f0:	62 e0       	ldi	r22, 0x02	; 2
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    19f8:	4d 2f       	mov	r20, r29
    19fa:	46 95       	lsr	r20
    19fc:	46 95       	lsr	r20
    19fe:	46 95       	lsr	r20
    1a00:	64 e0       	ldi	r22, 0x04	; 4
    1a02:	81 e0       	ldi	r24, 0x01	; 1
    1a04:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1a08:	8f ec       	ldi	r24, 0xCF	; 207
    1a0a:	97 e0       	ldi	r25, 0x07	; 7
    1a0c:	01 97       	sbiw	r24, 0x01	; 1
    1a0e:	f1 f7       	brne	.-4      	; 0x1a0c <LCD_DisplayCharacter+0xe8>
    1a10:	00 c0       	rjmp	.+0      	; 0x1a12 <LCD_DisplayCharacter+0xee>
    1a12:	00 00       	nop
    1a14:	40 e0       	ldi	r20, 0x00	; 0
    1a16:	62 e0       	ldi	r22, 0x02	; 2
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1a1e:	8f ec       	ldi	r24, 0xCF	; 207
    1a20:	97 e0       	ldi	r25, 0x07	; 7
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	f1 f7       	brne	.-4      	; 0x1a22 <LCD_DisplayCharacter+0xfe>
    1a26:	00 c0       	rjmp	.+0      	; 0x1a28 <LCD_DisplayCharacter+0x104>
    1a28:	00 00       	nop
    1a2a:	80 91 2f 06 	lds	r24, 0x062F	; 0x80062f <col_global>
    1a2e:	8f 5f       	subi	r24, 0xFF	; 255
    1a30:	80 93 2f 06 	sts	0x062F, r24	; 0x80062f <col_global>
    1a34:	84 31       	cpi	r24, 0x14	; 20
    1a36:	59 f4       	brne	.+22     	; 0x1a4e <LCD_DisplayCharacter+0x12a>
    1a38:	80 91 30 06 	lds	r24, 0x0630	; 0x800630 <row_global>
    1a3c:	8f 5f       	subi	r24, 0xFF	; 255
    1a3e:	80 93 30 06 	sts	0x0630, r24	; 0x800630 <row_global>
    1a42:	10 92 2f 06 	sts	0x062F, r1	; 0x80062f <col_global>
    1a46:	84 31       	cpi	r24, 0x14	; 20
    1a48:	11 f4       	brne	.+4      	; 0x1a4e <LCD_DisplayCharacter+0x12a>
    1a4a:	10 92 30 06 	sts	0x0630, r1	; 0x800630 <row_global>
    1a4e:	df 91       	pop	r29
    1a50:	cf 91       	pop	r28
    1a52:	08 95       	ret

00001a54 <LCD_DisplayString>:
    1a54:	0f 93       	push	r16
    1a56:	1f 93       	push	r17
    1a58:	cf 93       	push	r28
    1a5a:	8c 01       	movw	r16, r24
    1a5c:	c0 e0       	ldi	r28, 0x00	; 0
    1a5e:	03 c0       	rjmp	.+6      	; 0x1a66 <LCD_DisplayString+0x12>
    1a60:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    1a64:	cf 5f       	subi	r28, 0xFF	; 255
    1a66:	f8 01       	movw	r30, r16
    1a68:	ec 0f       	add	r30, r28
    1a6a:	f1 1d       	adc	r31, r1
    1a6c:	80 81       	ld	r24, Z
    1a6e:	81 11       	cpse	r24, r1
    1a70:	f7 cf       	rjmp	.-18     	; 0x1a60 <LCD_DisplayString+0xc>
    1a72:	cf 91       	pop	r28
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	08 95       	ret

00001a7a <LCD_MoveCursor>:
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	61 f0       	breq	.+24     	; 0x1a96 <LCD_MoveCursor+0x1c>
    1a7e:	28 f0       	brcs	.+10     	; 0x1a8a <LCD_MoveCursor+0x10>
    1a80:	82 30       	cpi	r24, 0x02	; 2
    1a82:	89 f0       	breq	.+34     	; 0x1aa6 <LCD_MoveCursor+0x2c>
    1a84:	83 30       	cpi	r24, 0x03	; 3
    1a86:	b9 f0       	breq	.+46     	; 0x1ab6 <LCD_MoveCursor+0x3c>
    1a88:	1d c0       	rjmp	.+58     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1a8a:	60 93 2f 06 	sts	0x062F, r22	; 0x80062f <col_global>
    1a8e:	10 92 30 06 	sts	0x0630, r1	; 0x800630 <row_global>
    1a92:	96 2f       	mov	r25, r22
    1a94:	17 c0       	rjmp	.+46     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1a96:	90 e4       	ldi	r25, 0x40	; 64
    1a98:	96 0f       	add	r25, r22
    1a9a:	60 93 2f 06 	sts	0x062F, r22	; 0x80062f <col_global>
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	80 93 30 06 	sts	0x0630, r24	; 0x800630 <row_global>
    1aa4:	0f c0       	rjmp	.+30     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1aa6:	94 e1       	ldi	r25, 0x14	; 20
    1aa8:	96 0f       	add	r25, r22
    1aaa:	60 93 2f 06 	sts	0x062F, r22	; 0x80062f <col_global>
    1aae:	82 e0       	ldi	r24, 0x02	; 2
    1ab0:	80 93 30 06 	sts	0x0630, r24	; 0x800630 <row_global>
    1ab4:	07 c0       	rjmp	.+14     	; 0x1ac4 <LCD_MoveCursor+0x4a>
    1ab6:	94 e5       	ldi	r25, 0x54	; 84
    1ab8:	96 0f       	add	r25, r22
    1aba:	60 93 2f 06 	sts	0x062F, r22	; 0x80062f <col_global>
    1abe:	83 e0       	ldi	r24, 0x03	; 3
    1ac0:	80 93 30 06 	sts	0x0630, r24	; 0x800630 <row_global>
    1ac4:	89 2f       	mov	r24, r25
    1ac6:	80 68       	ori	r24, 0x80	; 128
    1ac8:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1acc:	08 95       	ret

00001ace <LCD_DisplayStringRowCol>:
    1ace:	cf 93       	push	r28
    1ad0:	df 93       	push	r29
    1ad2:	ec 01       	movw	r28, r24
    1ad4:	86 2f       	mov	r24, r22
    1ad6:	64 2f       	mov	r22, r20
    1ad8:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
    1adc:	ce 01       	movw	r24, r28
    1ade:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <LCD_ClearScreen>:
    1ae8:	10 92 2f 06 	sts	0x062F, r1	; 0x80062f <col_global>
    1aec:	10 92 30 06 	sts	0x0630, r1	; 0x800630 <row_global>
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <LCD_SendCommand>
    1af6:	08 95       	ret

00001af8 <LCD_intToString>:




void LCD_intToString(uint32 data)
{
    1af8:	cf 93       	push	r28
    1afa:	df 93       	push	r29
    1afc:	cd b7       	in	r28, 0x3d	; 61
    1afe:	de b7       	in	r29, 0x3e	; 62
    1b00:	61 97       	sbiw	r28, 0x11	; 17
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	de bf       	out	0x3e, r29	; 62
    1b08:	0f be       	out	0x3f, r0	; 63
    1b0a:	cd bf       	out	0x3d, r28	; 61
    1b0c:	dc 01       	movw	r26, r24
    1b0e:	cb 01       	movw	r24, r22
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    1b10:	4a e0       	ldi	r20, 0x0A	; 10
    1b12:	be 01       	movw	r22, r28
    1b14:	6f 5f       	subi	r22, 0xFF	; 255
    1b16:	7f 4f       	sbci	r23, 0xFF	; 255
    1b18:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <__itoa_ncheck>
	 uint8 string_buff[17];// I write char not sint8_t(signed char ) to avoid warning
	 itoa(data , string_buff , 10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
	 LCD_DisplayString( (uint8_t *)string_buff);
    1b1c:	ce 01       	movw	r24, r28
    1b1e:	01 96       	adiw	r24, 0x01	; 1
    1b20:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
}
    1b24:	61 96       	adiw	r28, 0x11	; 17
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	f8 94       	cli
    1b2a:	de bf       	out	0x3e, r29	; 62
    1b2c:	0f be       	out	0x3f, r0	; 63
    1b2e:	cd bf       	out	0x3d, r28	; 61
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	08 95       	ret

00001b36 <LED_Init>:
#include "LED_interface.h"


void LED_Init(uint8 PORTX , uint8 PIN  )
{
    GPIO_SetPinDirection(PORTX , PIN , OUTPUT_PIN);
    1b36:	42 e0       	ldi	r20, 0x02	; 2
    1b38:	0e 94 40 11 	call	0x2280	; 0x2280 <GPIO_SetPinDirection>
    1b3c:	08 95       	ret

00001b3e <LED_OnOffPositiveLogic>:
}

void LED_OnOffPositiveLogic(uint8 PORTX , uint8 PIN ,LEDState_config State_value)
{
    if(State_value == LED_OFF)
    1b3e:	41 11       	cpse	r20, r1
    1b40:	03 c0       	rjmp	.+6      	; 0x1b48 <LED_OnOffPositiveLogic+0xa>
    {
        GPIO_WritePin(PORTX,PIN,LOGIC_LOW);
    1b42:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1b46:	08 95       	ret
    }
    else if(State_value == LED_ON)
    1b48:	41 30       	cpi	r20, 0x01	; 1
    1b4a:	11 f4       	brne	.+4      	; 0x1b50 <LED_OnOffPositiveLogic+0x12>
    {
        GPIO_WritePin(PORTX,PIN,LOGIC_HIGH);
    1b4c:	0e 94 16 12 	call	0x242c	; 0x242c <GPIO_WritePin>
    1b50:	08 95       	ret

00001b52 <NTC_GetTemperature>:
#include "../../MCAL/ADC/ADC_interface.h"
#include <math.h>


uint8 NTC_GetTemperature(void)
{
    1b52:	8f 92       	push	r8
    1b54:	9f 92       	push	r9
    1b56:	af 92       	push	r10
    1b58:	bf 92       	push	r11
    1b5a:	cf 92       	push	r12
    1b5c:	df 92       	push	r13
    1b5e:	ef 92       	push	r14
    1b60:	ff 92       	push	r15
    uint16 V_out = ADC_ReadChannelSingleConvertion(NTC_PIN);
    1b62:	81 e0       	ldi	r24, 0x01	; 1
    1b64:	0e 94 36 11 	call	0x226c	; 0x226c <ADC_ReadChannelSingleConvertion>
    /*  Apply voltage divider to get Current resistance for NTC     */
    float32 R1 = R2 * ( (ADC_MAX_VALUE / (float32)V_out) - 1.0 ) ;
    1b68:	bc 01       	movw	r22, r24
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	0e 94 33 14 	call	0x2866	; 0x2866 <__floatunsisf>
    1b72:	9b 01       	movw	r18, r22
    1b74:	ac 01       	movw	r20, r24
    1b76:	60 e0       	ldi	r22, 0x00	; 0
    1b78:	70 ec       	ldi	r23, 0xC0	; 192
    1b7a:	8f e7       	ldi	r24, 0x7F	; 127
    1b7c:	94 e4       	ldi	r25, 0x44	; 68
    1b7e:	0e 94 92 13 	call	0x2724	; 0x2724 <__divsf3>
    1b82:	20 e0       	ldi	r18, 0x00	; 0
    1b84:	30 e0       	ldi	r19, 0x00	; 0
    1b86:	40 e8       	ldi	r20, 0x80	; 128
    1b88:	5f e3       	ldi	r21, 0x3F	; 63
    1b8a:	0e 94 25 13 	call	0x264a	; 0x264a <__subsf3>
    1b8e:	20 e0       	ldi	r18, 0x00	; 0
    1b90:	30 e4       	ldi	r19, 0x40	; 64
    1b92:	4c e1       	ldi	r20, 0x1C	; 28
    1b94:	56 e4       	ldi	r21, 0x46	; 70
    1b96:	0e 94 11 15 	call	0x2a22	; 0x2a22 <__mulsf3>
    float32 LogR1 = log(R1) ;
    1b9a:	0e 94 c9 14 	call	0x2992	; 0x2992 <log>
    1b9e:	6b 01       	movw	r12, r22
    1ba0:	7c 01       	movw	r14, r24
    float32 T = (1.0 / ( C1 + (C2 *LogR1) + (C3 * LogR1 * LogR1 * LogR1) ) ) ;
    1ba2:	26 ed       	ldi	r18, 0xD6	; 214
    1ba4:	34 e6       	ldi	r19, 0x64	; 100
    1ba6:	49 e7       	ldi	r20, 0x79	; 121
    1ba8:	59 e3       	ldi	r21, 0x39	; 57
    1baa:	0e 94 11 15 	call	0x2a22	; 0x2a22 <__mulsf3>
    1bae:	2b ec       	ldi	r18, 0xCB	; 203
    1bb0:	38 e4       	ldi	r19, 0x48	; 72
    1bb2:	44 e8       	ldi	r20, 0x84	; 132
    1bb4:	5a e3       	ldi	r21, 0x3A	; 58
    1bb6:	0e 94 26 13 	call	0x264c	; 0x264c <__addsf3>
    1bba:	4b 01       	movw	r8, r22
    1bbc:	5c 01       	movw	r10, r24
    1bbe:	2c e6       	ldi	r18, 0x6C	; 108
    1bc0:	3f ec       	ldi	r19, 0xCF	; 207
    1bc2:	48 e5       	ldi	r20, 0x58	; 88
    1bc4:	54 e3       	ldi	r21, 0x34	; 52
    1bc6:	c7 01       	movw	r24, r14
    1bc8:	b6 01       	movw	r22, r12
    1bca:	0e 94 11 15 	call	0x2a22	; 0x2a22 <__mulsf3>
    1bce:	9b 01       	movw	r18, r22
    1bd0:	ac 01       	movw	r20, r24
    1bd2:	c7 01       	movw	r24, r14
    1bd4:	b6 01       	movw	r22, r12
    1bd6:	0e 94 11 15 	call	0x2a22	; 0x2a22 <__mulsf3>
    1bda:	9b 01       	movw	r18, r22
    1bdc:	ac 01       	movw	r20, r24
    1bde:	c7 01       	movw	r24, r14
    1be0:	b6 01       	movw	r22, r12
    1be2:	0e 94 11 15 	call	0x2a22	; 0x2a22 <__mulsf3>
    1be6:	9b 01       	movw	r18, r22
    1be8:	ac 01       	movw	r20, r24
    1bea:	c5 01       	movw	r24, r10
    1bec:	b4 01       	movw	r22, r8
    1bee:	0e 94 26 13 	call	0x264c	; 0x264c <__addsf3>
    1bf2:	9b 01       	movw	r18, r22
    1bf4:	ac 01       	movw	r20, r24
    1bf6:	60 e0       	ldi	r22, 0x00	; 0
    1bf8:	70 e0       	ldi	r23, 0x00	; 0
    1bfa:	80 e8       	ldi	r24, 0x80	; 128
    1bfc:	9f e3       	ldi	r25, 0x3F	; 63
    1bfe:	0e 94 92 13 	call	0x2724	; 0x2724 <__divsf3>
    T -= 273.15 ;
    1c02:	23 e3       	ldi	r18, 0x33	; 51
    1c04:	33 e9       	ldi	r19, 0x93	; 147
    1c06:	48 e8       	ldi	r20, 0x88	; 136
    1c08:	53 e4       	ldi	r21, 0x43	; 67
    1c0a:	0e 94 25 13 	call	0x264a	; 0x264a <__subsf3>
    return T ;
    1c0e:	0e 94 04 14 	call	0x2808	; 0x2808 <__fixunssfsi>
    1c12:	86 2f       	mov	r24, r22
}
    1c14:	ff 90       	pop	r15
    1c16:	ef 90       	pop	r14
    1c18:	df 90       	pop	r13
    1c1a:	cf 90       	pop	r12
    1c1c:	bf 90       	pop	r11
    1c1e:	af 90       	pop	r10
    1c20:	9f 90       	pop	r9
    1c22:	8f 90       	pop	r8
    1c24:	08 95       	ret

00001c26 <T_T3_Catch_Update_Temp>:
{
	
	while(1)
	{
		/*	Read Current temperature sensor value*/
		Current_Temp = NTC_GetTemperature();
    1c26:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <NTC_GetTemperature>
    1c2a:	80 93 3d 06 	sts	0x063D, r24	; 0x80063d <Current_Temp>
		
		/*	Check if current temperature >= Threshold temperature*/
		if(Current_Temp >= thresold_Temp )
    1c2e:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <thresold_Temp>
    1c32:	89 17       	cp	r24, r25
    1c34:	48 f0       	brcs	.+18     	; 0x1c48 <T_T3_Catch_Update_Temp+0x22>
		{
			/*	set event of exceeding temperature	*/
			xEventGroupSetBits(egEvents,ExceedTemperature);
    1c36:	61 e0       	ldi	r22, 0x01	; 1
    1c38:	70 e0       	ldi	r23, 0x00	; 0
    1c3a:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1c3e:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1c42:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
    1c46:	08 c0       	rjmp	.+16     	; 0x1c58 <T_T3_Catch_Update_Temp+0x32>
		}
		else
		{
			/*	Clear event of exceeding temperature	*/
			xEventGroupClearBits(egEvents,ExceedTemperature);
    1c48:	61 e0       	ldi	r22, 0x01	; 1
    1c4a:	70 e0       	ldi	r23, 0x00	; 0
    1c4c:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1c50:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1c54:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>

		}

		/*	take mutex to access LCD shared resource*/
		if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 100 ) == pdTRUE )
    1c58:	20 e0       	ldi	r18, 0x00	; 0
    1c5a:	44 e6       	ldi	r20, 0x64	; 100
    1c5c:	50 e0       	ldi	r21, 0x00	; 0
    1c5e:	60 e0       	ldi	r22, 0x00	; 0
    1c60:	70 e0       	ldi	r23, 0x00	; 0
    1c62:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1c66:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1c6a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1c6e:	81 30       	cpi	r24, 0x01	; 1
    1c70:	f9 f4       	brne	.+62     	; 0x1cb0 <T_T3_Catch_Update_Temp+0x8a>
		{
			/*	Dispalay value of current Temperature in LCD */
			LCD_MoveCursor(0,10);
    1c72:	6a e0       	ldi	r22, 0x0A	; 10
    1c74:	80 e0       	ldi	r24, 0x00	; 0
    1c76:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
			LCD_intToString(Current_Temp);
    1c7a:	60 91 3d 06 	lds	r22, 0x063D	; 0x80063d <Current_Temp>
    1c7e:	70 e0       	ldi	r23, 0x00	; 0
    1c80:	80 e0       	ldi	r24, 0x00	; 0
    1c82:	90 e0       	ldi	r25, 0x00	; 0
    1c84:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
			if(Current_Temp < 100)
    1c88:	80 91 3d 06 	lds	r24, 0x063D	; 0x80063d <Current_Temp>
    1c8c:	84 36       	cpi	r24, 0x64	; 100
    1c8e:	20 f4       	brcc	.+8      	; 0x1c98 <T_T3_Catch_Update_Temp+0x72>
			{
				LCD_DisplayString((uint8 *)" ");
    1c90:	86 ee       	ldi	r24, 0xE6	; 230
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <LCD_DisplayString>
			}
			// USART_SendStringPolling((uint8 *)"ADC update lcd\r");
			xSemaphoreGive( xMutexLCD );
    1c98:	20 e0       	ldi	r18, 0x00	; 0
    1c9a:	40 e0       	ldi	r20, 0x00	; 0
    1c9c:	50 e0       	ldi	r21, 0x00	; 0
    1c9e:	60 e0       	ldi	r22, 0x00	; 0
    1ca0:	70 e0       	ldi	r23, 0x00	; 0
    1ca2:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1ca6:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1caa:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1cae:	04 c0       	rjmp	.+8      	; 0x1cb8 <T_T3_Catch_Update_Temp+0x92>
		}
		/*	Failed to take mutex*/
		else
		{
			/*	tell that failled to update LCD	*/
			USART_SendStringPolling((uint8 *)"ADC Failed update lcd\r");
    1cb0:	84 e7       	ldi	r24, 0x74	; 116
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	0e 94 08 13 	call	0x2610	; 0x2610 <USART_SendStringPolling>
		}

		vTaskDelay(200);/*	As I want to take new Temperature Value every half second	*/
    1cb8:	88 ec       	ldi	r24, 0xC8	; 200
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskDelay>
	}
    1cc0:	b2 cf       	rjmp	.-156    	; 0x1c26 <T_T3_Catch_Update_Temp>

00001cc2 <T_T4_UART_listen>:
}


void T_T4_UART_listen(void * pvparam)
{
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	00 d0       	rcall	.+0      	; 0x1cc8 <T_T4_UART_listen+0x6>
    1cc8:	00 d0       	rcall	.+0      	; 0x1cca <T_T4_UART_listen+0x8>
    1cca:	1f 92       	push	r1
    1ccc:	cd b7       	in	r28, 0x3d	; 61
    1cce:	de b7       	in	r29, 0x3e	; 62
	
	uint8 u8Ind = 0;
	uint8 txMsg_UART[4] ={};
    1cd0:	19 82       	std	Y+1, r1	; 0x01
    1cd2:	1a 82       	std	Y+2, r1	; 0x02
    1cd4:	1b 82       	std	Y+3, r1	; 0x03
    1cd6:	1c 82       	std	Y+4, r1	; 0x04
	uint8 u8Data = 0;
    1cd8:	1d 82       	std	Y+5, r1	; 0x05
	boolean update_thresould_temp = FALSE ;
    1cda:	10 e0       	ldi	r17, 0x00	; 0


void T_T4_UART_listen(void * pvparam)
{
	
	uint8 u8Ind = 0;
    1cdc:	00 e0       	ldi	r16, 0x00	; 0
    1cde:	04 c0       	rjmp	.+8      	; 0x1ce8 <T_T4_UART_listen+0x26>
			
			
			
			if(u8Data == 'G') /*	Will update flag of Threshold Temperature */
			{
				update_thresould_temp = TRUE ;
    1ce0:	11 e0       	ldi	r17, 0x01	; 1
    1ce2:	02 c0       	rjmp	.+4      	; 0x1ce8 <T_T4_UART_listen+0x26>
				update_thresould_temp = FALSE ;
				u8Ind = 0;	
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'C')) /*	Cancel new threshold temperature value*/
			{
				update_thresould_temp = FALSE ;
    1ce4:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;
    1ce6:	00 e0       	ldi	r16, 0x00	; 0
	uint8 txMsg_UART[4] ={};
	uint8 u8Data = 0;
	boolean update_thresould_temp = FALSE ;
	while(1){
		/*	Check if received any new data */
		if(UART_receiveByteUnblocking(&u8Data)){
    1ce8:	ce 01       	movw	r24, r28
    1cea:	05 96       	adiw	r24, 0x05	; 5
    1cec:	0e 94 1c 13 	call	0x2638	; 0x2638 <UART_receiveByteUnblocking>
    1cf0:	88 23       	and	r24, r24
    1cf2:	d1 f3       	breq	.-12     	; 0x1ce8 <T_T4_UART_listen+0x26>
			
			
			
			if(u8Data == 'G') /*	Will update flag of Threshold Temperature */
    1cf4:	8d 81       	ldd	r24, Y+5	; 0x05
    1cf6:	87 34       	cpi	r24, 0x47	; 71
    1cf8:	99 f3       	breq	.-26     	; 0x1ce0 <T_T4_UART_listen+0x1e>
			{
				update_thresould_temp = TRUE ;
			}
			else if( (update_thresould_temp == TRUE) && ((u8Data >= '0') && (u8Data <= '9')) )
    1cfa:	11 30       	cpi	r17, 0x01	; 1
    1cfc:	69 f4       	brne	.+26     	; 0x1d18 <T_T4_UART_listen+0x56>
    1cfe:	90 ed       	ldi	r25, 0xD0	; 208
    1d00:	98 0f       	add	r25, r24
    1d02:	9a 30       	cpi	r25, 0x0A	; 10
    1d04:	48 f4       	brcc	.+18     	; 0x1d18 <T_T4_UART_listen+0x56>
			{
				txMsg_UART[u8Ind] = u8Data;
    1d06:	e1 e0       	ldi	r30, 0x01	; 1
    1d08:	f0 e0       	ldi	r31, 0x00	; 0
    1d0a:	ec 0f       	add	r30, r28
    1d0c:	fd 1f       	adc	r31, r29
    1d0e:	e0 0f       	add	r30, r16
    1d10:	f1 1d       	adc	r31, r1
    1d12:	80 83       	st	Z, r24
				u8Ind++;
    1d14:	0f 5f       	subi	r16, 0xFF	; 255
    1d16:	e8 cf       	rjmp	.-48     	; 0x1ce8 <T_T4_UART_listen+0x26>
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'K')) /*	Accept new threshold temperature value*/
    1d18:	11 30       	cpi	r17, 0x01	; 1
    1d1a:	c1 f4       	brne	.+48     	; 0x1d4c <T_T4_UART_listen+0x8a>
    1d1c:	8b 34       	cpi	r24, 0x4B	; 75
    1d1e:	b1 f4       	brne	.+44     	; 0x1d4c <T_T4_UART_listen+0x8a>
			{
				txMsg_UART[u8Ind] = 0;
    1d20:	e1 e0       	ldi	r30, 0x01	; 1
    1d22:	f0 e0       	ldi	r31, 0x00	; 0
    1d24:	ec 0f       	add	r30, r28
    1d26:	fd 1f       	adc	r31, r29
    1d28:	e0 0f       	add	r30, r16
    1d2a:	f1 1d       	adc	r31, r1
    1d2c:	10 82       	st	Z, r1
				xQueueSend(MessQUart_Thres_temp, txMsg_UART, portMAX_DELAY);
    1d2e:	20 e0       	ldi	r18, 0x00	; 0
    1d30:	4f ef       	ldi	r20, 0xFF	; 255
    1d32:	5f ef       	ldi	r21, 0xFF	; 255
    1d34:	be 01       	movw	r22, r28
    1d36:	6f 5f       	subi	r22, 0xFF	; 255
    1d38:	7f 4f       	sbci	r23, 0xFF	; 255
    1d3a:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <MessQUart_Thres_temp>
    1d3e:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <MessQUart_Thres_temp+0x1>
    1d42:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
				update_thresould_temp = FALSE ;
    1d46:	10 e0       	ldi	r17, 0x00	; 0
				u8Ind = 0;	
    1d48:	00 e0       	ldi	r16, 0x00	; 0
    1d4a:	ce cf       	rjmp	.-100    	; 0x1ce8 <T_T4_UART_listen+0x26>
			}
			else if( (update_thresould_temp == TRUE) && (u8Data == 'C')) /*	Cancel new threshold temperature value*/
    1d4c:	11 30       	cpi	r17, 0x01	; 1
    1d4e:	11 f4       	brne	.+4      	; 0x1d54 <T_T4_UART_listen+0x92>
    1d50:	83 34       	cpi	r24, 0x43	; 67
    1d52:	41 f2       	breq	.-112    	; 0x1ce4 <T_T4_UART_listen+0x22>
			{
				update_thresould_temp = FALSE ;
				u8Ind = 0;
			}
			else if(u8Data == 'T') /*	Will toggle state of Alarm system*/
    1d54:	84 35       	cpi	r24, 0x54	; 84
    1d56:	69 f4       	brne	.+26     	; 0x1d72 <T_T4_UART_listen+0xb0>
			{
				xQueueSend(MessMailuart_fireState, &u8Data, portMAX_DELAY);
    1d58:	20 e0       	ldi	r18, 0x00	; 0
    1d5a:	4f ef       	ldi	r20, 0xFF	; 255
    1d5c:	5f ef       	ldi	r21, 0xFF	; 255
    1d5e:	be 01       	movw	r22, r28
    1d60:	6b 5f       	subi	r22, 0xFB	; 251
    1d62:	7f 4f       	sbci	r23, 0xFF	; 255
    1d64:	80 91 35 06 	lds	r24, 0x0635	; 0x800635 <MessMailuart_fireState>
    1d68:	90 91 36 06 	lds	r25, 0x0636	; 0x800636 <MessMailuart_fireState+0x1>
    1d6c:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1d70:	bb cf       	rjmp	.-138    	; 0x1ce8 <T_T4_UART_listen+0x26>
			}
			else if(u8Data == 'D') /*	Will Disbale Alarm system*/
    1d72:	84 34       	cpi	r24, 0x44	; 68
    1d74:	09 f0       	breq	.+2      	; 0x1d78 <T_T4_UART_listen+0xb6>
    1d76:	b8 cf       	rjmp	.-144    	; 0x1ce8 <T_T4_UART_listen+0x26>
			{
				xQueueSend(MessMailuart_fireState, &u8Data, portMAX_DELAY);
    1d78:	20 e0       	ldi	r18, 0x00	; 0
    1d7a:	4f ef       	ldi	r20, 0xFF	; 255
    1d7c:	5f ef       	ldi	r21, 0xFF	; 255
    1d7e:	be 01       	movw	r22, r28
    1d80:	6b 5f       	subi	r22, 0xFB	; 251
    1d82:	7f 4f       	sbci	r23, 0xFF	; 255
    1d84:	80 91 35 06 	lds	r24, 0x0635	; 0x800635 <MessMailuart_fireState>
    1d88:	90 91 36 06 	lds	r25, 0x0636	; 0x800636 <MessMailuart_fireState+0x1>
    1d8c:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1d90:	ab cf       	rjmp	.-170    	; 0x1ce8 <T_T4_UART_listen+0x26>

00001d92 <T_T5_Update_LCD>:
	}
}


void T_T5_Update_LCD(void *pvparam)
{
    1d92:	cf 93       	push	r28
    1d94:	df 93       	push	r29
    1d96:	00 d0       	rcall	.+0      	; 0x1d98 <T_T5_Update_LCD+0x6>
    1d98:	00 d0       	rcall	.+0      	; 0x1d9a <T_T5_Update_LCD+0x8>
    1d9a:	1f 92       	push	r1
    1d9c:	cd b7       	in	r28, 0x3d	; 61
    1d9e:	de b7       	in	r29, 0x3e	; 62
	uint8 rxMsg_thresholdTemp[4] = {};
    1da0:	19 82       	std	Y+1, r1	; 0x01
    1da2:	1a 82       	std	Y+2, r1	; 0x02
    1da4:	1b 82       	std	Y+3, r1	; 0x03
    1da6:	1c 82       	std	Y+4, r1	; 0x04
	uint8 rxmsg_fireState ;
	while(1)
	{
		/*	handle received thresould temperature value and display it */
		if(xQueueReceive(MessQUart_Thres_temp, rxMsg_thresholdTemp, 100))
    1da8:	20 e0       	ldi	r18, 0x00	; 0
    1daa:	44 e6       	ldi	r20, 0x64	; 100
    1dac:	50 e0       	ldi	r21, 0x00	; 0
    1dae:	be 01       	movw	r22, r28
    1db0:	6f 5f       	subi	r22, 0xFF	; 255
    1db2:	7f 4f       	sbci	r23, 0xFF	; 255
    1db4:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <MessQUart_Thres_temp>
    1db8:	90 91 38 06 	lds	r25, 0x0638	; 0x800638 <MessQUart_Thres_temp+0x1>
    1dbc:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1dc0:	88 23       	and	r24, r24
    1dc2:	09 f4       	brne	.+2      	; 0x1dc6 <T_T5_Update_LCD+0x34>
    1dc4:	48 c0       	rjmp	.+144    	; 0x1e56 <T_T5_Update_LCD+0xc4>
		{
			thresold_Temp = rxMsg_thresholdTemp[0] - '0';
    1dc6:	89 81       	ldd	r24, Y+1	; 0x01
    1dc8:	80 53       	subi	r24, 0x30	; 48
			thresold_Temp *= 10 ;
    1dca:	88 0f       	add	r24, r24
    1dcc:	98 2f       	mov	r25, r24
    1dce:	99 0f       	add	r25, r25
    1dd0:	99 0f       	add	r25, r25
    1dd2:	89 0f       	add	r24, r25
			thresold_Temp += rxMsg_thresholdTemp[1] - '0';
    1dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd6:	89 0f       	add	r24, r25
    1dd8:	80 53       	subi	r24, 0x30	; 48
    1dda:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <thresold_Temp>

			/*	Update Event state if thresold_Temp <= Current_Temp */
			if(thresold_Temp <= Current_Temp)
    1dde:	90 91 3d 06 	lds	r25, 0x063D	; 0x80063d <Current_Temp>
    1de2:	98 17       	cp	r25, r24
    1de4:	48 f0       	brcs	.+18     	; 0x1df8 <T_T5_Update_LCD+0x66>
			{
				/*	set event of exceeding temperature	*/
				xEventGroupSetBits(egEvents,ExceedTemperature);
    1de6:	61 e0       	ldi	r22, 0x01	; 1
    1de8:	70 e0       	ldi	r23, 0x00	; 0
    1dea:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1dee:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1df2:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
    1df6:	08 c0       	rjmp	.+16     	; 0x1e08 <T_T5_Update_LCD+0x76>
			}
			/*	No need to update threshold value	*/
			else
			{
				/*	Clear event of exceeding temperature	*/
				xEventGroupClearBits(egEvents,ExceedTemperature);
    1df8:	61 e0       	ldi	r22, 0x01	; 1
    1dfa:	70 e0       	ldi	r23, 0x00	; 0
    1dfc:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1e00:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1e04:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
			}

			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 100 ) == pdTRUE )
    1e08:	20 e0       	ldi	r18, 0x00	; 0
    1e0a:	44 e6       	ldi	r20, 0x64	; 100
    1e0c:	50 e0       	ldi	r21, 0x00	; 0
    1e0e:	60 e0       	ldi	r22, 0x00	; 0
    1e10:	70 e0       	ldi	r23, 0x00	; 0
    1e12:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1e16:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1e1a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e1e:	81 30       	cpi	r24, 0x01	; 1
    1e20:	b1 f4       	brne	.+44     	; 0x1e4e <T_T5_Update_LCD+0xbc>
			{
				LCD_DisplayStringRowCol(rxMsg_thresholdTemp,1,16);
    1e22:	40 e1       	ldi	r20, 0x10	; 16
    1e24:	61 e0       	ldi	r22, 0x01	; 1
    1e26:	ce 01       	movw	r24, r28
    1e28:	01 96       	adiw	r24, 0x01	; 1
    1e2a:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
				USART_SendStringPolling((uint8 *)"Thre update lcd\r");
    1e2e:	8b e8       	ldi	r24, 0x8B	; 139
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	0e 94 08 13 	call	0x2610	; 0x2610 <USART_SendStringPolling>
				xSemaphoreGive( xMutexLCD );
    1e36:	20 e0       	ldi	r18, 0x00	; 0
    1e38:	40 e0       	ldi	r20, 0x00	; 0
    1e3a:	50 e0       	ldi	r21, 0x00	; 0
    1e3c:	60 e0       	ldi	r22, 0x00	; 0
    1e3e:	70 e0       	ldi	r23, 0x00	; 0
    1e40:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1e44:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1e48:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1e4c:	04 c0       	rjmp	.+8      	; 0x1e56 <T_T5_Update_LCD+0xc4>
			}
			else
			{
				USART_SendStringPolling((uint8 *)"thre Failed update lcd\r");
    1e4e:	8c e9       	ldi	r24, 0x9C	; 156
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	0e 94 08 13 	call	0x2610	; 0x2610 <USART_SendStringPolling>
		{

		}

		/*	handle state of firing system if it enabled or disabled and update lcd with this change	*/
		if(xQueueReceive(MessMailuart_fireState, &rxmsg_fireState, 100))
    1e56:	20 e0       	ldi	r18, 0x00	; 0
    1e58:	44 e6       	ldi	r20, 0x64	; 100
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
    1e5c:	be 01       	movw	r22, r28
    1e5e:	6b 5f       	subi	r22, 0xFB	; 251
    1e60:	7f 4f       	sbci	r23, 0xFF	; 255
    1e62:	80 91 35 06 	lds	r24, 0x0635	; 0x800635 <MessMailuart_fireState>
    1e66:	90 91 36 06 	lds	r25, 0x0636	; 0x800636 <MessMailuart_fireState+0x1>
    1e6a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1e6e:	88 23       	and	r24, r24
    1e70:	09 f4       	brne	.+2      	; 0x1e74 <T_T5_Update_LCD+0xe2>
    1e72:	9a cf       	rjmp	.-204    	; 0x1da8 <T_T5_Update_LCD+0x16>
		{
			/*	Disable state of fire system */
			if(rxmsg_fireState == 'D')
    1e74:	8d 81       	ldd	r24, Y+5	; 0x05
    1e76:	84 34       	cpi	r24, 0x44	; 68
    1e78:	51 f5       	brne	.+84     	; 0x1ece <T_T5_Update_LCD+0x13c>
			{
				AlarmState = FALSE ;
    1e7a:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <AlarmState>
				xEventGroupClearBits(egEvents,SystemFireState);
    1e7e:	62 e0       	ldi	r22, 0x02	; 2
    1e80:	70 e0       	ldi	r23, 0x00	; 0
    1e82:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1e86:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1e8a:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
				if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 400 ) == pdTRUE )
    1e8e:	20 e0       	ldi	r18, 0x00	; 0
    1e90:	40 e9       	ldi	r20, 0x90	; 144
    1e92:	51 e0       	ldi	r21, 0x01	; 1
    1e94:	60 e0       	ldi	r22, 0x00	; 0
    1e96:	70 e0       	ldi	r23, 0x00	; 0
    1e98:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1e9c:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1ea0:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1ea4:	81 30       	cpi	r24, 0x01	; 1
    1ea6:	09 f0       	breq	.+2      	; 0x1eaa <T_T5_Update_LCD+0x118>
    1ea8:	7f cf       	rjmp	.-258    	; 0x1da8 <T_T5_Update_LCD+0x16>
				{
					LCD_DisplayStringRowCol((uint8 *)"D",2,13);	
    1eaa:	4d e0       	ldi	r20, 0x0D	; 13
    1eac:	62 e0       	ldi	r22, 0x02	; 2
    1eae:	84 eb       	ldi	r24, 0xB4	; 180
    1eb0:	90 e0       	ldi	r25, 0x00	; 0
    1eb2:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
					xSemaphoreGive( xMutexLCD );
    1eb6:	20 e0       	ldi	r18, 0x00	; 0
    1eb8:	40 e0       	ldi	r20, 0x00	; 0
    1eba:	50 e0       	ldi	r21, 0x00	; 0
    1ebc:	60 e0       	ldi	r22, 0x00	; 0
    1ebe:	70 e0       	ldi	r23, 0x00	; 0
    1ec0:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1ec4:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1ec8:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1ecc:	6d cf       	rjmp	.-294    	; 0x1da8 <T_T5_Update_LCD+0x16>
				{

				}
			}
			/*	Toggle state of fire system */
			else if(rxmsg_fireState == 'T')
    1ece:	84 35       	cpi	r24, 0x54	; 84
    1ed0:	09 f0       	breq	.+2      	; 0x1ed4 <T_T5_Update_LCD+0x142>
    1ed2:	6a cf       	rjmp	.-300    	; 0x1da8 <T_T5_Update_LCD+0x16>
			{
				
				if(AlarmState == TRUE)
    1ed4:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <AlarmState>
    1ed8:	81 30       	cpi	r24, 0x01	; 1
    1eda:	51 f5       	brne	.+84     	; 0x1f30 <T_T5_Update_LCD+0x19e>
				{
					AlarmState = FALSE ;
    1edc:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <AlarmState>
					xEventGroupClearBits(egEvents,SystemFireState);
    1ee0:	62 e0       	ldi	r22, 0x02	; 2
    1ee2:	70 e0       	ldi	r23, 0x00	; 0
    1ee4:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1ee8:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1eec:	0e 94 0e 01 	call	0x21c	; 0x21c <xEventGroupClearBits>
					if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 400 ) == pdTRUE )
    1ef0:	20 e0       	ldi	r18, 0x00	; 0
    1ef2:	40 e9       	ldi	r20, 0x90	; 144
    1ef4:	51 e0       	ldi	r21, 0x01	; 1
    1ef6:	60 e0       	ldi	r22, 0x00	; 0
    1ef8:	70 e0       	ldi	r23, 0x00	; 0
    1efa:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1efe:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1f02:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1f06:	81 30       	cpi	r24, 0x01	; 1
    1f08:	09 f0       	breq	.+2      	; 0x1f0c <T_T5_Update_LCD+0x17a>
    1f0a:	4e cf       	rjmp	.-356    	; 0x1da8 <T_T5_Update_LCD+0x16>
					{
						LCD_DisplayStringRowCol((uint8 *)"D",2,13);	
    1f0c:	4d e0       	ldi	r20, 0x0D	; 13
    1f0e:	62 e0       	ldi	r22, 0x02	; 2
    1f10:	84 eb       	ldi	r24, 0xB4	; 180
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
						xSemaphoreGive( xMutexLCD );
    1f18:	20 e0       	ldi	r18, 0x00	; 0
    1f1a:	40 e0       	ldi	r20, 0x00	; 0
    1f1c:	50 e0       	ldi	r21, 0x00	; 0
    1f1e:	60 e0       	ldi	r22, 0x00	; 0
    1f20:	70 e0       	ldi	r23, 0x00	; 0
    1f22:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1f26:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1f2a:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1f2e:	3c cf       	rjmp	.-392    	; 0x1da8 <T_T5_Update_LCD+0x16>
					else 
					{

					}
				}
				else if(AlarmState == FALSE)
    1f30:	81 11       	cpse	r24, r1
    1f32:	3a cf       	rjmp	.-396    	; 0x1da8 <T_T5_Update_LCD+0x16>
				{
					AlarmState = TRUE ;
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <AlarmState>
					xEventGroupSetBits(egEvents,SystemFireState);
    1f3a:	62 e0       	ldi	r22, 0x02	; 2
    1f3c:	70 e0       	ldi	r23, 0x00	; 0
    1f3e:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    1f42:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    1f46:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>
					if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 400 ) == pdTRUE )
    1f4a:	20 e0       	ldi	r18, 0x00	; 0
    1f4c:	40 e9       	ldi	r20, 0x90	; 144
    1f4e:	51 e0       	ldi	r21, 0x01	; 1
    1f50:	60 e0       	ldi	r22, 0x00	; 0
    1f52:	70 e0       	ldi	r23, 0x00	; 0
    1f54:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1f58:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1f5c:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    1f60:	81 30       	cpi	r24, 0x01	; 1
    1f62:	09 f0       	breq	.+2      	; 0x1f66 <T_T5_Update_LCD+0x1d4>
    1f64:	21 cf       	rjmp	.-446    	; 0x1da8 <T_T5_Update_LCD+0x16>
					{
						LCD_DisplayStringRowCol((uint8 *)"E",2,13);	
    1f66:	4d e0       	ldi	r20, 0x0D	; 13
    1f68:	62 e0       	ldi	r22, 0x02	; 2
    1f6a:	82 e7       	ldi	r24, 0x72	; 114
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
						xSemaphoreGive( xMutexLCD );
    1f72:	20 e0       	ldi	r18, 0x00	; 0
    1f74:	40 e0       	ldi	r20, 0x00	; 0
    1f76:	50 e0       	ldi	r21, 0x00	; 0
    1f78:	60 e0       	ldi	r22, 0x00	; 0
    1f7a:	70 e0       	ldi	r23, 0x00	; 0
    1f7c:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    1f80:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    1f84:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
    1f88:	0f cf       	rjmp	.-482    	; 0x1da8 <T_T5_Update_LCD+0x16>

00001f8a <System_Init>:
}


void System_Init(void)
{
	LCD_init();
    1f8a:	0e 94 67 0c 	call	0x18ce	; 0x18ce <LCD_init>
	USART_Init();
    1f8e:	0e 94 ba 12 	call	0x2574	; 0x2574 <USART_Init>
    ADC_Init();
    1f92:	0e 94 d5 10 	call	0x21aa	; 0x21aa <ADC_Init>
    LED_Init(PORTC_ID,PIN0_ID);
    1f96:	60 e0       	ldi	r22, 0x00	; 0
    1f98:	82 e0       	ldi	r24, 0x02	; 2
    1f9a:	0e 94 9b 0d 	call	0x1b36	; 0x1b36 <LED_Init>
    1f9e:	08 95       	ret

00001fa0 <LCD_MAINInit>:

}

void LCD_MAINInit(void)
{
	LCD_ClearScreen();
    1fa0:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_ClearScreen>
	LCD_DisplayStringRowCol((uint8 *)"Cur Temp:    C",0,0);	
    1fa4:	40 e0       	ldi	r20, 0x00	; 0
    1fa6:	60 e0       	ldi	r22, 0x00	; 0
    1fa8:	86 eb       	ldi	r24, 0xB6	; 182
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	/*	Catch value for Temperature and Display it  */
	Current_Temp = NTC_GetTemperature();
    1fb0:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <NTC_GetTemperature>
    1fb4:	80 93 3d 06 	sts	0x063D, r24	; 0x80063d <Current_Temp>
	LCD_MoveCursor(0,10);
    1fb8:	6a e0       	ldi	r22, 0x0A	; 10
    1fba:	80 e0       	ldi	r24, 0x00	; 0
    1fbc:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	LCD_intToString(Current_Temp);
    1fc0:	60 91 3d 06 	lds	r22, 0x063D	; 0x80063d <Current_Temp>
    1fc4:	70 e0       	ldi	r23, 0x00	; 0
    1fc6:	80 e0       	ldi	r24, 0x00	; 0
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
	LCD_DisplayStringRowCol((uint8 *)"Threshold Temp:    C",1,0);	
    1fce:	40 e0       	ldi	r20, 0x00	; 0
    1fd0:	61 e0       	ldi	r22, 0x01	; 1
    1fd2:	85 ec       	ldi	r24, 0xC5	; 197
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	LCD_MoveCursor(1,16);
    1fda:	60 e1       	ldi	r22, 0x10	; 16
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	LCD_intToString(thresold_Temp);
    1fe2:	60 91 63 00 	lds	r22, 0x0063	; 0x800063 <thresold_Temp>
    1fe6:	70 e0       	ldi	r23, 0x00	; 0
    1fe8:	80 e0       	ldi	r24, 0x00	; 0
    1fea:	90 e0       	ldi	r25, 0x00	; 0
    1fec:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <LCD_intToString>
	LCD_DisplayStringRowCol((uint8 *)"Alarm State: ",2,0);	
    1ff0:	40 e0       	ldi	r20, 0x00	; 0
    1ff2:	62 e0       	ldi	r22, 0x02	; 2
    1ff4:	8a ed       	ldi	r24, 0xDA	; 218
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
	LCD_MoveCursor(2,13);
    1ffc:	6d e0       	ldi	r22, 0x0D	; 13
    1ffe:	82 e0       	ldi	r24, 0x02	; 2
    2000:	0e 94 3d 0d 	call	0x1a7a	; 0x1a7a <LCD_MoveCursor>
	if(AlarmState == TRUE)
    2004:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <AlarmState>
    2008:	81 30       	cpi	r24, 0x01	; 1
    200a:	21 f4       	brne	.+8      	; 0x2014 <LCD_MAINInit+0x74>
	{
		LCD_DisplayCharacter('E');
    200c:	85 e4       	ldi	r24, 0x45	; 69
    200e:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    2012:	08 95       	ret
	}
	else 
	{
		LCD_DisplayCharacter('D');
    2014:	84 e4       	ldi	r24, 0x44	; 68
    2016:	0e 94 92 0c 	call	0x1924	; 0x1924 <LCD_DisplayCharacter>
    201a:	08 95       	ret

0000201c <main>:

EventGroupHandle_t 	egEvents = NULL;
EventBits_t			ebValues = 0;

int main(void)
{
    201c:	af 92       	push	r10
    201e:	bf 92       	push	r11
    2020:	cf 92       	push	r12
    2022:	df 92       	push	r13
    2024:	ef 92       	push	r14
    2026:	ff 92       	push	r15
    2028:	0f 93       	push	r16

	System_Init();
    202a:	0e 94 c5 0f 	call	0x1f8a	; 0x1f8a <System_Init>
	LCD_MAINInit();
    202e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <LCD_MAINInit>
	
	xMutexLCD = xSemaphoreCreateMutex();
    2032:	81 e0       	ldi	r24, 0x01	; 1
    2034:	0e 94 6e 05 	call	0xadc	; 0xadc <xQueueCreateMutex>
    2038:	90 93 3c 06 	sts	0x063C, r25	; 0x80063c <xMutexLCD+0x1>
    203c:	80 93 3b 06 	sts	0x063B, r24	; 0x80063b <xMutexLCD>
	// XFiresystemState_Semph = xSemaphoreCreateBinary();
	MessQUart_Thres_temp = xQueueCreate(3,3 * sizeof(uint8) );	
    2040:	40 e0       	ldi	r20, 0x00	; 0
    2042:	63 e0       	ldi	r22, 0x03	; 3
    2044:	83 e0       	ldi	r24, 0x03	; 3
    2046:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericCreate>
    204a:	90 93 38 06 	sts	0x0638, r25	; 0x800638 <MessQUart_Thres_temp+0x1>
    204e:	80 93 37 06 	sts	0x0637, r24	; 0x800637 <MessQUart_Thres_temp>
	MessMailuart_fireState = xQueueCreate(3, sizeof(uint8));
    2052:	40 e0       	ldi	r20, 0x00	; 0
    2054:	61 e0       	ldi	r22, 0x01	; 1
    2056:	83 e0       	ldi	r24, 0x03	; 3
    2058:	0e 94 ae 04 	call	0x95c	; 0x95c <xQueueGenericCreate>
    205c:	90 93 36 06 	sts	0x0636, r25	; 0x800636 <MessMailuart_fireState+0x1>
    2060:	80 93 35 06 	sts	0x0635, r24	; 0x800635 <MessMailuart_fireState>

	egEvents = xEventGroupCreate();
    2064:	0e 94 89 00 	call	0x112	; 0x112 <xEventGroupCreate>
    2068:	90 93 34 06 	sts	0x0634, r25	; 0x800634 <egEvents+0x1>
    206c:	80 93 33 06 	sts	0x0633, r24	; 0x800633 <egEvents>



	xTaskCreate(T_T6_SwitchBetHaz_Nor, "Emergency_normal", 200, NULL, 4, NULL);
    2070:	a1 2c       	mov	r10, r1
    2072:	b1 2c       	mov	r11, r1
    2074:	c1 2c       	mov	r12, r1
    2076:	d1 2c       	mov	r13, r1
    2078:	e1 2c       	mov	r14, r1
    207a:	f1 2c       	mov	r15, r1
    207c:	04 e0       	ldi	r16, 0x04	; 4
    207e:	20 e0       	ldi	r18, 0x00	; 0
    2080:	30 e0       	ldi	r19, 0x00	; 0
    2082:	48 ec       	ldi	r20, 0xC8	; 200
    2084:	50 e0       	ldi	r21, 0x00	; 0
    2086:	68 ee       	ldi	r22, 0xE8	; 232
    2088:	70 e0       	ldi	r23, 0x00	; 0
    208a:	87 e8       	ldi	r24, 0x87	; 135
    208c:	90 e1       	ldi	r25, 0x10	; 16
    208e:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T3_Catch_Update_Temp, "Update Current Temp", 100, &Current_Temp, 3, NULL);
    2092:	03 e0       	ldi	r16, 0x03	; 3
    2094:	2d e3       	ldi	r18, 0x3D	; 61
    2096:	36 e0       	ldi	r19, 0x06	; 6
    2098:	44 e6       	ldi	r20, 0x64	; 100
    209a:	50 e0       	ldi	r21, 0x00	; 0
    209c:	69 ef       	ldi	r22, 0xF9	; 249
    209e:	70 e0       	ldi	r23, 0x00	; 0
    20a0:	83 e1       	ldi	r24, 0x13	; 19
    20a2:	9e e0       	ldi	r25, 0x0E	; 14
    20a4:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T5_Update_LCD, "update Threshold_state", 100, NULL, 2, NULL);
    20a8:	02 e0       	ldi	r16, 0x02	; 2
    20aa:	20 e0       	ldi	r18, 0x00	; 0
    20ac:	30 e0       	ldi	r19, 0x00	; 0
    20ae:	44 e6       	ldi	r20, 0x64	; 100
    20b0:	50 e0       	ldi	r21, 0x00	; 0
    20b2:	6d e0       	ldi	r22, 0x0D	; 13
    20b4:	71 e0       	ldi	r23, 0x01	; 1
    20b6:	89 ec       	ldi	r24, 0xC9	; 201
    20b8:	9e e0       	ldi	r25, 0x0E	; 14
    20ba:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>
	xTaskCreate(T_T4_UART_listen, "Recieve UART Mess", 100, NULL, 1, NULL);
    20be:	01 e0       	ldi	r16, 0x01	; 1
    20c0:	20 e0       	ldi	r18, 0x00	; 0
    20c2:	30 e0       	ldi	r19, 0x00	; 0
    20c4:	44 e6       	ldi	r20, 0x64	; 100
    20c6:	50 e0       	ldi	r21, 0x00	; 0
    20c8:	64 e2       	ldi	r22, 0x24	; 36
    20ca:	71 e0       	ldi	r23, 0x01	; 1
    20cc:	81 e6       	ldi	r24, 0x61	; 97
    20ce:	9e e0       	ldi	r25, 0x0E	; 14
    20d0:	0e 94 47 07 	call	0xe8e	; 0xe8e <xTaskGenericCreate>

	xEventGroupSetBits(egEvents,SystemFireState); // As I by defualt make system Fire Enable
    20d4:	62 e0       	ldi	r22, 0x02	; 2
    20d6:	70 e0       	ldi	r23, 0x00	; 0
    20d8:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    20dc:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    20e0:	0e 94 1d 01 	call	0x23a	; 0x23a <xEventGroupSetBits>

	vTaskStartScheduler();
    20e4:	0e 94 ff 07 	call	0xffe	; 0xffe <vTaskStartScheduler>

	return 0 ;
}
    20e8:	80 e0       	ldi	r24, 0x00	; 0
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	0f 91       	pop	r16
    20ee:	ff 90       	pop	r15
    20f0:	ef 90       	pop	r14
    20f2:	df 90       	pop	r13
    20f4:	cf 90       	pop	r12
    20f6:	bf 90       	pop	r11
    20f8:	af 90       	pop	r10
    20fa:	08 95       	ret

000020fc <F_fireStateScreen>:
}


void F_fireStateScreen(void)
{
	LCD_ClearScreen();
    20fc:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <LCD_ClearScreen>
	LCD_DisplayStringRowCol((uint8 *)"!! ALARM !!", 1 , 4);
    2100:	44 e0       	ldi	r20, 0x04	; 4
    2102:	61 e0       	ldi	r22, 0x01	; 1
    2104:	86 e3       	ldi	r24, 0x36	; 54
    2106:	91 e0       	ldi	r25, 0x01	; 1
    2108:	0e 94 67 0d 	call	0x1ace	; 0x1ace <LCD_DisplayStringRowCol>
    210c:	08 95       	ret

0000210e <T_T6_SwitchBetHaz_Nor>:
}


void T_T6_SwitchBetHaz_Nor(void *pvparam)
{
	boolean Mutex_Taken_Already = FALSE ;
    210e:	c0 e0       	ldi	r28, 0x00	; 0
	while (1)
	{
		ebValues = xEventGroupWaitBits(egEvents,
    2110:	04 e6       	ldi	r16, 0x64	; 100
    2112:	10 e0       	ldi	r17, 0x00	; 0
    2114:	21 e0       	ldi	r18, 0x01	; 1
    2116:	40 e0       	ldi	r20, 0x00	; 0
    2118:	63 e0       	ldi	r22, 0x03	; 3
    211a:	70 e0       	ldi	r23, 0x00	; 0
    211c:	80 91 33 06 	lds	r24, 0x0633	; 0x800633 <egEvents>
    2120:	90 91 34 06 	lds	r25, 0x0634	; 0x800634 <egEvents+0x1>
    2124:	0e 94 9c 00 	call	0x138	; 0x138 <xEventGroupWaitBits>
    2128:	90 93 32 06 	sts	0x0632, r25	; 0x800632 <ebValues+0x1>
    212c:	80 93 31 06 	sts	0x0631, r24	; 0x800631 <ebValues>
										(SystemFireState | ExceedTemperature),
										0,
										1,//AND
										100);

		if( ( ebValues & (SystemFireState | ExceedTemperature) )== (SystemFireState | ExceedTemperature) )
    2130:	83 70       	andi	r24, 0x03	; 3
    2132:	99 27       	eor	r25, r25
    2134:	03 97       	sbiw	r24, 0x03	; 3
    2136:	b1 f4       	brne	.+44     	; 0x2164 <T_T6_SwitchBetHaz_Nor+0x56>
		{
			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 1000 ) == pdTRUE )
    2138:	20 e0       	ldi	r18, 0x00	; 0
    213a:	48 ee       	ldi	r20, 0xE8	; 232
    213c:	53 e0       	ldi	r21, 0x03	; 3
    213e:	60 e0       	ldi	r22, 0x00	; 0
    2140:	70 e0       	ldi	r23, 0x00	; 0
    2142:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    2146:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    214a:	0e 94 9a 05 	call	0xb34	; 0xb34 <xQueueGenericReceive>
    214e:	81 30       	cpi	r24, 0x01	; 1
    2150:	f1 f4       	brne	.+60     	; 0x218e <T_T6_SwitchBetHaz_Nor+0x80>
			{
				Mutex_Taken_Already = TRUE ;
				LED_OnOffPositiveLogic(PORTC_ID,PIN0_ID,LED_ON);
    2152:	41 e0       	ldi	r20, 0x01	; 1
    2154:	60 e0       	ldi	r22, 0x00	; 0
    2156:	82 e0       	ldi	r24, 0x02	; 2
    2158:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <LED_OnOffPositiveLogic>
				F_fireStateScreen();
    215c:	0e 94 7e 10 	call	0x20fc	; 0x20fc <F_fireStateScreen>

		if( ( ebValues & (SystemFireState | ExceedTemperature) )== (SystemFireState | ExceedTemperature) )
		{
			if( xSemaphoreTake( xMutexLCD, ( TickType_t ) 1000 ) == pdTRUE )
			{
				Mutex_Taken_Already = TRUE ;
    2160:	c1 e0       	ldi	r28, 0x01	; 1
    2162:	15 c0       	rjmp	.+42     	; 0x218e <T_T6_SwitchBetHaz_Nor+0x80>
			}
			
		}
		else
		{
			if(Mutex_Taken_Already == TRUE)
    2164:	c1 30       	cpi	r28, 0x01	; 1
    2166:	99 f4       	brne	.+38     	; 0x218e <T_T6_SwitchBetHaz_Nor+0x80>
			{
				Mutex_Taken_Already = FALSE ;
				LED_OnOffPositiveLogic(PORTC_ID,PIN0_ID,LED_OFF);
    2168:	40 e0       	ldi	r20, 0x00	; 0
    216a:	60 e0       	ldi	r22, 0x00	; 0
    216c:	82 e0       	ldi	r24, 0x02	; 2
    216e:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <LED_OnOffPositiveLogic>
				xSemaphoreGive( xMutexLCD );
    2172:	20 e0       	ldi	r18, 0x00	; 0
    2174:	40 e0       	ldi	r20, 0x00	; 0
    2176:	50 e0       	ldi	r21, 0x00	; 0
    2178:	60 e0       	ldi	r22, 0x00	; 0
    217a:	70 e0       	ldi	r23, 0x00	; 0
    217c:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <xMutexLCD>
    2180:	90 91 3c 06 	lds	r25, 0x063C	; 0x80063c <xMutexLCD+0x1>
    2184:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <xQueueGenericSend>
				/*	Should be here to avoid continous update LCD without go from Fire state to normal state*/
				LCD_MAINInit();	
    2188:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <LCD_MAINInit>
		}
		else
		{
			if(Mutex_Taken_Already == TRUE)
			{
				Mutex_Taken_Already = FALSE ;
    218c:	c0 e0       	ldi	r28, 0x00	; 0
				/*	Should be here to avoid continous update LCD without go from Fire state to normal state*/
				LCD_MAINInit();	
			}
		
		}
		vTaskDelay(100);
    218e:	84 e6       	ldi	r24, 0x64	; 100
    2190:	90 e0       	ldi	r25, 0x00	; 0
    2192:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vTaskDelay>
	}
    2196:	bc cf       	rjmp	.-136    	; 0x2110 <T_T6_SwitchBetHaz_Nor+0x2>

00002198 <ADC_OnlyStartConversionGeneral>:
    return ADC_conversion_value;
}

void ADC_FreeRunningStart (uint8 Channel_NUM)
{
    ADC_OnlyStartConversionGeneral(Channel_NUM);
    2198:	87 70       	andi	r24, 0x07	; 7
    219a:	97 b1       	in	r25, 0x07	; 7
    219c:	90 7e       	andi	r25, 0xE0	; 224
    219e:	89 2b       	or	r24, r25
    21a0:	87 b9       	out	0x07, r24	; 7
    21a2:	86 b1       	in	r24, 0x06	; 6
    21a4:	80 64       	ori	r24, 0x40	; 64
    21a6:	86 b9       	out	0x06, r24	; 6
    21a8:	08 95       	ret

000021aa <ADC_Init>:
    21aa:	27 b1       	in	r18, 0x07	; 7
    21ac:	e4 e6       	ldi	r30, 0x64	; 100
    21ae:	f0 e0       	ldi	r31, 0x00	; 0
    21b0:	91 81       	ldd	r25, Z+1	; 0x01
    21b2:	30 e4       	ldi	r19, 0x40	; 64
    21b4:	93 9f       	mul	r25, r19
    21b6:	c0 01       	movw	r24, r0
    21b8:	11 24       	eor	r1, r1
    21ba:	92 2f       	mov	r25, r18
    21bc:	9f 73       	andi	r25, 0x3F	; 63
    21be:	89 2b       	or	r24, r25
    21c0:	87 b9       	out	0x07, r24	; 7
    21c2:	82 81       	ldd	r24, Z+2	; 0x02
    21c4:	81 11       	cpse	r24, r1
    21c6:	04 c0       	rjmp	.+8      	; 0x21d0 <ADC_Init+0x26>
    21c8:	87 b1       	in	r24, 0x07	; 7
    21ca:	8f 7d       	andi	r24, 0xDF	; 223
    21cc:	87 b9       	out	0x07, r24	; 7
    21ce:	05 c0       	rjmp	.+10     	; 0x21da <ADC_Init+0x30>
    21d0:	81 30       	cpi	r24, 0x01	; 1
    21d2:	19 f4       	brne	.+6      	; 0x21da <ADC_Init+0x30>
    21d4:	87 b1       	in	r24, 0x07	; 7
    21d6:	80 62       	ori	r24, 0x20	; 32
    21d8:	87 b9       	out	0x07, r24	; 7
    21da:	86 b1       	in	r24, 0x06	; 6
    21dc:	80 68       	ori	r24, 0x80	; 128
    21de:	86 b9       	out	0x06, r24	; 6
    21e0:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <ADC_ConfigTypeParam>
    21e4:	88 23       	and	r24, r24
    21e6:	c9 f0       	breq	.+50     	; 0x221a <ADC_Init+0x70>
    21e8:	81 30       	cpi	r24, 0x01	; 1
    21ea:	39 f4       	brne	.+14     	; 0x21fa <ADC_Init+0x50>
    21ec:	86 b1       	in	r24, 0x06	; 6
    21ee:	80 62       	ori	r24, 0x20	; 32
    21f0:	86 b9       	out	0x06, r24	; 6
    21f2:	80 b7       	in	r24, 0x30	; 48
    21f4:	8f 70       	andi	r24, 0x0F	; 15
    21f6:	80 bf       	out	0x30, r24	; 48
    21f8:	10 c0       	rjmp	.+32     	; 0x221a <ADC_Init+0x70>
    21fa:	82 30       	cpi	r24, 0x02	; 2
    21fc:	71 f4       	brne	.+28     	; 0x221a <ADC_Init+0x70>
    21fe:	86 b1       	in	r24, 0x06	; 6
    2200:	80 62       	ori	r24, 0x20	; 32
    2202:	86 b9       	out	0x06, r24	; 6
    2204:	20 b7       	in	r18, 0x30	; 48
    2206:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <ADC_ConfigTypeParam+0x4>
    220a:	30 e2       	ldi	r19, 0x20	; 32
    220c:	93 9f       	mul	r25, r19
    220e:	c0 01       	movw	r24, r0
    2210:	11 24       	eor	r1, r1
    2212:	92 2f       	mov	r25, r18
    2214:	9f 70       	andi	r25, 0x0F	; 15
    2216:	89 2b       	or	r24, r25
    2218:	80 bf       	out	0x30, r24	; 48
    221a:	96 b1       	in	r25, 0x06	; 6
    221c:	80 91 67 00 	lds	r24, 0x0067	; 0x800067 <ADC_ConfigTypeParam+0x3>
    2220:	98 7f       	andi	r25, 0xF8	; 248
    2222:	87 70       	andi	r24, 0x07	; 7
    2224:	89 2b       	or	r24, r25
    2226:	86 b9       	out	0x06, r24	; 6
    2228:	86 b1       	in	r24, 0x06	; 6
    222a:	87 7f       	andi	r24, 0xF7	; 247
    222c:	86 b9       	out	0x06, r24	; 6
    222e:	08 95       	ret

00002230 <ADC_ReadConversionRegister>:

uint16 ADC_ReadConversionRegister(void)
{   
    /* NOTE if I use #define ADC (* (volatile uint16 *) (0x24) )  will reduce all below steps */
    uint16 RegisterValue = 0 ;
    if(ADC_ConfigTypeParam.ADC_ValueAdjustment_value == ADC_Adjust_Right)
    2230:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <ADC_ConfigTypeParam+0x2>
    2234:	81 11       	cpse	r24, r1
    2236:	08 c0       	rjmp	.+16     	; 0x2248 <ADC_ReadConversionRegister+0x18>
    {
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ADCL;
    2238:	24 b1       	in	r18, 0x04	; 4
        RegisterValue = (( (uint16)(ADCH & 0x03) ) << 8) | RegisterValue ;
    223a:	85 b1       	in	r24, 0x05	; 5
    223c:	83 70       	andi	r24, 0x03	; 3
    223e:	90 e0       	ldi	r25, 0x00	; 0
    2240:	98 2f       	mov	r25, r24
    2242:	88 27       	eor	r24, r24
    2244:	82 2b       	or	r24, r18
    2246:	08 95       	ret
    }
    else if(ADC_ConfigTypeParam.ADC_ValueAdjustment_value == ADC_Adjust_Left)
    2248:	81 30       	cpi	r24, 0x01	; 1
    224a:	69 f4       	brne	.+26     	; 0x2266 <ADC_ReadConversionRegister+0x36>
    {
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ((ADCL & 0xC0) ) >> 6 ;
    224c:	24 b1       	in	r18, 0x04	; 4
    224e:	22 95       	swap	r18
    2250:	26 95       	lsr	r18
    2252:	26 95       	lsr	r18
    2254:	23 70       	andi	r18, 0x03	; 3
        RegisterValue = (( (uint16)ADCH ) << 2) | RegisterValue ;
    2256:	85 b1       	in	r24, 0x05	; 5
    2258:	90 e0       	ldi	r25, 0x00	; 0
    225a:	88 0f       	add	r24, r24
    225c:	99 1f       	adc	r25, r25
    225e:	88 0f       	add	r24, r24
    2260:	99 1f       	adc	r25, r25
    2262:	82 2b       	or	r24, r18
    2264:	08 95       	ret
}

uint16 ADC_ReadConversionRegister(void)
{   
    /* NOTE if I use #define ADC (* (volatile uint16 *) (0x24) )  will reduce all below steps */
    uint16 RegisterValue = 0 ;
    2266:	80 e0       	ldi	r24, 0x00	; 0
    2268:	90 e0       	ldi	r25, 0x00	; 0
        /*  When ADCL is read, the ADC Data Register is not updated until ADCH is read */
        RegisterValue = ((ADCL & 0xC0) ) >> 6 ;
        RegisterValue = (( (uint16)ADCH ) << 2) | RegisterValue ;
    }
    return RegisterValue ;
}
    226a:	08 95       	ret

0000226c <ADC_ReadChannelSingleConvertion>:


uint16 ADC_ReadChannelSingleConvertion(uint8 Channel_NUM)
{
    uint16 ADC_conversion_value = 0 ;
    ADC_OnlyStartConversionGeneral(Channel_NUM);
    226c:	0e 94 cc 10 	call	0x2198	; 0x2198 <ADC_OnlyStartConversionGeneral>
    /*  wait uintil ADIF (conversion flag) in ADCSRA register convert from Low to High As that mean conversion completed  */
    while (BIT_IS_CLEAR(ADCSRA,ADIF));
    2270:	34 9b       	sbis	0x06, 4	; 6
    2272:	fe cf       	rjmp	.-4      	; 0x2270 <ADC_ReadChannelSingleConvertion+0x4>
    ADC_conversion_value = ADC_ReadConversionRegister();
    2274:	0e 94 18 11 	call	0x2230	; 0x2230 <ADC_ReadConversionRegister>
    /*  Clear ADIF (conversion flag) in ADCSRA register by write one when use Polling Technique     */
    SET_BIT(ADCSRA,ADIF);
    2278:	26 b1       	in	r18, 0x06	; 6
    227a:	20 61       	ori	r18, 0x10	; 16
    227c:	26 b9       	out	0x06, r18	; 6
    return ADC_conversion_value;
}
    227e:	08 95       	ret

00002280 <GPIO_SetPinDirection>:

        }
    }

    return returned_value ;
}
    2280:	84 30       	cpi	r24, 0x04	; 4
    2282:	08 f0       	brcs	.+2      	; 0x2286 <GPIO_SetPinDirection+0x6>
    2284:	d2 c0       	rjmp	.+420    	; 0x242a <GPIO_SetPinDirection+0x1aa>
    2286:	68 30       	cpi	r22, 0x08	; 8
    2288:	08 f0       	brcs	.+2      	; 0x228c <GPIO_SetPinDirection+0xc>
    228a:	cf c0       	rjmp	.+414    	; 0x242a <GPIO_SetPinDirection+0x1aa>
    228c:	81 30       	cpi	r24, 0x01	; 1
    228e:	d1 f1       	breq	.+116    	; 0x2304 <GPIO_SetPinDirection+0x84>
    2290:	38 f0       	brcs	.+14     	; 0x22a0 <GPIO_SetPinDirection+0x20>
    2292:	82 30       	cpi	r24, 0x02	; 2
    2294:	09 f4       	brne	.+2      	; 0x2298 <GPIO_SetPinDirection+0x18>
    2296:	68 c0       	rjmp	.+208    	; 0x2368 <GPIO_SetPinDirection+0xe8>
    2298:	83 30       	cpi	r24, 0x03	; 3
    229a:	09 f4       	brne	.+2      	; 0x229e <GPIO_SetPinDirection+0x1e>
    229c:	96 c0       	rjmp	.+300    	; 0x23ca <GPIO_SetPinDirection+0x14a>
    229e:	08 95       	ret
    22a0:	41 11       	cpse	r20, r1
    22a2:	10 c0       	rjmp	.+32     	; 0x22c4 <GPIO_SetPinDirection+0x44>
    22a4:	2a b3       	in	r18, 0x1a	; 26
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	02 c0       	rjmp	.+4      	; 0x22b0 <GPIO_SetPinDirection+0x30>
    22ac:	88 0f       	add	r24, r24
    22ae:	99 1f       	adc	r25, r25
    22b0:	6a 95       	dec	r22
    22b2:	e2 f7       	brpl	.-8      	; 0x22ac <GPIO_SetPinDirection+0x2c>
    22b4:	80 95       	com	r24
    22b6:	92 2f       	mov	r25, r18
    22b8:	98 23       	and	r25, r24
    22ba:	9a bb       	out	0x1a, r25	; 26
    22bc:	9b b3       	in	r25, 0x1b	; 27
    22be:	89 23       	and	r24, r25
    22c0:	8b bb       	out	0x1b, r24	; 27
    22c2:	08 95       	ret
    22c4:	41 30       	cpi	r20, 0x01	; 1
    22c6:	81 f4       	brne	.+32     	; 0x22e8 <GPIO_SetPinDirection+0x68>
    22c8:	2a b3       	in	r18, 0x1a	; 26
    22ca:	81 e0       	ldi	r24, 0x01	; 1
    22cc:	90 e0       	ldi	r25, 0x00	; 0
    22ce:	02 c0       	rjmp	.+4      	; 0x22d4 <GPIO_SetPinDirection+0x54>
    22d0:	88 0f       	add	r24, r24
    22d2:	99 1f       	adc	r25, r25
    22d4:	6a 95       	dec	r22
    22d6:	e2 f7       	brpl	.-8      	; 0x22d0 <GPIO_SetPinDirection+0x50>
    22d8:	98 2f       	mov	r25, r24
    22da:	90 95       	com	r25
    22dc:	92 23       	and	r25, r18
    22de:	9a bb       	out	0x1a, r25	; 26
    22e0:	9b b3       	in	r25, 0x1b	; 27
    22e2:	89 2b       	or	r24, r25
    22e4:	8b bb       	out	0x1b, r24	; 27
    22e6:	08 95       	ret
    22e8:	42 30       	cpi	r20, 0x02	; 2
    22ea:	09 f0       	breq	.+2      	; 0x22ee <GPIO_SetPinDirection+0x6e>
    22ec:	9e c0       	rjmp	.+316    	; 0x242a <GPIO_SetPinDirection+0x1aa>
    22ee:	2a b3       	in	r18, 0x1a	; 26
    22f0:	81 e0       	ldi	r24, 0x01	; 1
    22f2:	90 e0       	ldi	r25, 0x00	; 0
    22f4:	02 c0       	rjmp	.+4      	; 0x22fa <GPIO_SetPinDirection+0x7a>
    22f6:	88 0f       	add	r24, r24
    22f8:	99 1f       	adc	r25, r25
    22fa:	6a 95       	dec	r22
    22fc:	e2 f7       	brpl	.-8      	; 0x22f6 <GPIO_SetPinDirection+0x76>
    22fe:	82 2b       	or	r24, r18
    2300:	8a bb       	out	0x1a, r24	; 26
    2302:	08 95       	ret
    2304:	41 11       	cpse	r20, r1
    2306:	10 c0       	rjmp	.+32     	; 0x2328 <GPIO_SetPinDirection+0xa8>
    2308:	27 b3       	in	r18, 0x17	; 23
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	02 c0       	rjmp	.+4      	; 0x2314 <GPIO_SetPinDirection+0x94>
    2310:	88 0f       	add	r24, r24
    2312:	99 1f       	adc	r25, r25
    2314:	6a 95       	dec	r22
    2316:	e2 f7       	brpl	.-8      	; 0x2310 <GPIO_SetPinDirection+0x90>
    2318:	80 95       	com	r24
    231a:	92 2f       	mov	r25, r18
    231c:	98 23       	and	r25, r24
    231e:	97 bb       	out	0x17, r25	; 23
    2320:	98 b3       	in	r25, 0x18	; 24
    2322:	89 23       	and	r24, r25
    2324:	88 bb       	out	0x18, r24	; 24
    2326:	08 95       	ret
    2328:	41 30       	cpi	r20, 0x01	; 1
    232a:	81 f4       	brne	.+32     	; 0x234c <GPIO_SetPinDirection+0xcc>
    232c:	27 b3       	in	r18, 0x17	; 23
    232e:	81 e0       	ldi	r24, 0x01	; 1
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	02 c0       	rjmp	.+4      	; 0x2338 <GPIO_SetPinDirection+0xb8>
    2334:	88 0f       	add	r24, r24
    2336:	99 1f       	adc	r25, r25
    2338:	6a 95       	dec	r22
    233a:	e2 f7       	brpl	.-8      	; 0x2334 <GPIO_SetPinDirection+0xb4>
    233c:	98 2f       	mov	r25, r24
    233e:	90 95       	com	r25
    2340:	92 23       	and	r25, r18
    2342:	97 bb       	out	0x17, r25	; 23
    2344:	98 b3       	in	r25, 0x18	; 24
    2346:	89 2b       	or	r24, r25
    2348:	88 bb       	out	0x18, r24	; 24
    234a:	08 95       	ret
    234c:	42 30       	cpi	r20, 0x02	; 2
    234e:	09 f0       	breq	.+2      	; 0x2352 <GPIO_SetPinDirection+0xd2>
    2350:	6c c0       	rjmp	.+216    	; 0x242a <GPIO_SetPinDirection+0x1aa>
    2352:	27 b3       	in	r18, 0x17	; 23
    2354:	81 e0       	ldi	r24, 0x01	; 1
    2356:	90 e0       	ldi	r25, 0x00	; 0
    2358:	02 c0       	rjmp	.+4      	; 0x235e <GPIO_SetPinDirection+0xde>
    235a:	88 0f       	add	r24, r24
    235c:	99 1f       	adc	r25, r25
    235e:	6a 95       	dec	r22
    2360:	e2 f7       	brpl	.-8      	; 0x235a <GPIO_SetPinDirection+0xda>
    2362:	82 2b       	or	r24, r18
    2364:	87 bb       	out	0x17, r24	; 23
    2366:	08 95       	ret
    2368:	41 11       	cpse	r20, r1
    236a:	10 c0       	rjmp	.+32     	; 0x238c <GPIO_SetPinDirection+0x10c>
    236c:	24 b3       	in	r18, 0x14	; 20
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	90 e0       	ldi	r25, 0x00	; 0
    2372:	02 c0       	rjmp	.+4      	; 0x2378 <GPIO_SetPinDirection+0xf8>
    2374:	88 0f       	add	r24, r24
    2376:	99 1f       	adc	r25, r25
    2378:	6a 95       	dec	r22
    237a:	e2 f7       	brpl	.-8      	; 0x2374 <GPIO_SetPinDirection+0xf4>
    237c:	80 95       	com	r24
    237e:	92 2f       	mov	r25, r18
    2380:	98 23       	and	r25, r24
    2382:	94 bb       	out	0x14, r25	; 20
    2384:	95 b3       	in	r25, 0x15	; 21
    2386:	89 23       	and	r24, r25
    2388:	85 bb       	out	0x15, r24	; 21
    238a:	08 95       	ret
    238c:	41 30       	cpi	r20, 0x01	; 1
    238e:	81 f4       	brne	.+32     	; 0x23b0 <GPIO_SetPinDirection+0x130>
    2390:	24 b3       	in	r18, 0x14	; 20
    2392:	81 e0       	ldi	r24, 0x01	; 1
    2394:	90 e0       	ldi	r25, 0x00	; 0
    2396:	02 c0       	rjmp	.+4      	; 0x239c <GPIO_SetPinDirection+0x11c>
    2398:	88 0f       	add	r24, r24
    239a:	99 1f       	adc	r25, r25
    239c:	6a 95       	dec	r22
    239e:	e2 f7       	brpl	.-8      	; 0x2398 <GPIO_SetPinDirection+0x118>
    23a0:	98 2f       	mov	r25, r24
    23a2:	90 95       	com	r25
    23a4:	92 23       	and	r25, r18
    23a6:	94 bb       	out	0x14, r25	; 20
    23a8:	95 b3       	in	r25, 0x15	; 21
    23aa:	89 2b       	or	r24, r25
    23ac:	85 bb       	out	0x15, r24	; 21
    23ae:	08 95       	ret
    23b0:	42 30       	cpi	r20, 0x02	; 2
    23b2:	d9 f5       	brne	.+118    	; 0x242a <GPIO_SetPinDirection+0x1aa>
    23b4:	24 b3       	in	r18, 0x14	; 20
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	90 e0       	ldi	r25, 0x00	; 0
    23ba:	02 c0       	rjmp	.+4      	; 0x23c0 <GPIO_SetPinDirection+0x140>
    23bc:	88 0f       	add	r24, r24
    23be:	99 1f       	adc	r25, r25
    23c0:	6a 95       	dec	r22
    23c2:	e2 f7       	brpl	.-8      	; 0x23bc <GPIO_SetPinDirection+0x13c>
    23c4:	82 2b       	or	r24, r18
    23c6:	84 bb       	out	0x14, r24	; 20
    23c8:	08 95       	ret
    23ca:	41 11       	cpse	r20, r1
    23cc:	10 c0       	rjmp	.+32     	; 0x23ee <GPIO_SetPinDirection+0x16e>
    23ce:	21 b3       	in	r18, 0x11	; 17
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	02 c0       	rjmp	.+4      	; 0x23da <GPIO_SetPinDirection+0x15a>
    23d6:	88 0f       	add	r24, r24
    23d8:	99 1f       	adc	r25, r25
    23da:	6a 95       	dec	r22
    23dc:	e2 f7       	brpl	.-8      	; 0x23d6 <GPIO_SetPinDirection+0x156>
    23de:	80 95       	com	r24
    23e0:	92 2f       	mov	r25, r18
    23e2:	98 23       	and	r25, r24
    23e4:	91 bb       	out	0x11, r25	; 17
    23e6:	92 b3       	in	r25, 0x12	; 18
    23e8:	89 23       	and	r24, r25
    23ea:	82 bb       	out	0x12, r24	; 18
    23ec:	08 95       	ret
    23ee:	41 30       	cpi	r20, 0x01	; 1
    23f0:	81 f4       	brne	.+32     	; 0x2412 <GPIO_SetPinDirection+0x192>
    23f2:	21 b3       	in	r18, 0x11	; 17
    23f4:	81 e0       	ldi	r24, 0x01	; 1
    23f6:	90 e0       	ldi	r25, 0x00	; 0
    23f8:	02 c0       	rjmp	.+4      	; 0x23fe <GPIO_SetPinDirection+0x17e>
    23fa:	88 0f       	add	r24, r24
    23fc:	99 1f       	adc	r25, r25
    23fe:	6a 95       	dec	r22
    2400:	e2 f7       	brpl	.-8      	; 0x23fa <GPIO_SetPinDirection+0x17a>
    2402:	98 2f       	mov	r25, r24
    2404:	90 95       	com	r25
    2406:	92 23       	and	r25, r18
    2408:	91 bb       	out	0x11, r25	; 17
    240a:	92 b3       	in	r25, 0x12	; 18
    240c:	89 2b       	or	r24, r25
    240e:	82 bb       	out	0x12, r24	; 18
    2410:	08 95       	ret
    2412:	42 30       	cpi	r20, 0x02	; 2
    2414:	51 f4       	brne	.+20     	; 0x242a <GPIO_SetPinDirection+0x1aa>
    2416:	21 b3       	in	r18, 0x11	; 17
    2418:	81 e0       	ldi	r24, 0x01	; 1
    241a:	90 e0       	ldi	r25, 0x00	; 0
    241c:	02 c0       	rjmp	.+4      	; 0x2422 <GPIO_SetPinDirection+0x1a2>
    241e:	88 0f       	add	r24, r24
    2420:	99 1f       	adc	r25, r25
    2422:	6a 95       	dec	r22
    2424:	e2 f7       	brpl	.-8      	; 0x241e <GPIO_SetPinDirection+0x19e>
    2426:	82 2b       	or	r24, r18
    2428:	81 bb       	out	0x11, r24	; 17
    242a:	08 95       	ret

0000242c <GPIO_WritePin>:



void GPIO_WritePin(uint8 PORTX , uint8 PIN ,uint8 value)
{
    if(PORTX >= NUM_PORT  || PIN >= NUM_FOR_PINS_PER_PORT)
    242c:	84 30       	cpi	r24, 0x04	; 4
    242e:	08 f0       	brcs	.+2      	; 0x2432 <GPIO_WritePin+0x6>
    2430:	77 c0       	rjmp	.+238    	; 0x2520 <GPIO_WritePin+0xf4>
    2432:	68 30       	cpi	r22, 0x08	; 8
    2434:	08 f0       	brcs	.+2      	; 0x2438 <GPIO_WritePin+0xc>
    2436:	74 c0       	rjmp	.+232    	; 0x2520 <GPIO_WritePin+0xf4>
    {
        /* Do Nothing*/
    }
    else
    {
        switch(PORTX)
    2438:	81 30       	cpi	r24, 0x01	; 1
    243a:	11 f1       	breq	.+68     	; 0x2480 <GPIO_WritePin+0x54>
    243c:	30 f0       	brcs	.+12     	; 0x244a <GPIO_WritePin+0x1e>
    243e:	82 30       	cpi	r24, 0x02	; 2
    2440:	d1 f1       	breq	.+116    	; 0x24b6 <GPIO_WritePin+0x8a>
    2442:	83 30       	cpi	r24, 0x03	; 3
    2444:	09 f4       	brne	.+2      	; 0x2448 <GPIO_WritePin+0x1c>
    2446:	52 c0       	rjmp	.+164    	; 0x24ec <GPIO_WritePin+0xc0>
    2448:	08 95       	ret
        {
            case PORTA_ID :
                if(value == LOGIC_HIGH)
    244a:	41 30       	cpi	r20, 0x01	; 1
    244c:	59 f4       	brne	.+22     	; 0x2464 <GPIO_WritePin+0x38>
                    SET_BIT(PORTA,PIN);
    244e:	2b b3       	in	r18, 0x1b	; 27
    2450:	81 e0       	ldi	r24, 0x01	; 1
    2452:	90 e0       	ldi	r25, 0x00	; 0
    2454:	02 c0       	rjmp	.+4      	; 0x245a <GPIO_WritePin+0x2e>
    2456:	88 0f       	add	r24, r24
    2458:	99 1f       	adc	r25, r25
    245a:	6a 95       	dec	r22
    245c:	e2 f7       	brpl	.-8      	; 0x2456 <GPIO_WritePin+0x2a>
    245e:	82 2b       	or	r24, r18
    2460:	8b bb       	out	0x1b, r24	; 27
    2462:	08 95       	ret
                else if(value == LOGIC_LOW)
    2464:	41 11       	cpse	r20, r1
    2466:	5c c0       	rjmp	.+184    	; 0x2520 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTA,PIN);
    2468:	2b b3       	in	r18, 0x1b	; 27
    246a:	81 e0       	ldi	r24, 0x01	; 1
    246c:	90 e0       	ldi	r25, 0x00	; 0
    246e:	02 c0       	rjmp	.+4      	; 0x2474 <GPIO_WritePin+0x48>
    2470:	88 0f       	add	r24, r24
    2472:	99 1f       	adc	r25, r25
    2474:	6a 95       	dec	r22
    2476:	e2 f7       	brpl	.-8      	; 0x2470 <GPIO_WritePin+0x44>
    2478:	80 95       	com	r24
    247a:	82 23       	and	r24, r18
    247c:	8b bb       	out	0x1b, r24	; 27
    247e:	08 95       	ret
                break;


            case PORTB_ID :
                if(value == LOGIC_HIGH)
    2480:	41 30       	cpi	r20, 0x01	; 1
    2482:	59 f4       	brne	.+22     	; 0x249a <GPIO_WritePin+0x6e>
                    SET_BIT(PORTB,PIN);
    2484:	28 b3       	in	r18, 0x18	; 24
    2486:	81 e0       	ldi	r24, 0x01	; 1
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	02 c0       	rjmp	.+4      	; 0x2490 <GPIO_WritePin+0x64>
    248c:	88 0f       	add	r24, r24
    248e:	99 1f       	adc	r25, r25
    2490:	6a 95       	dec	r22
    2492:	e2 f7       	brpl	.-8      	; 0x248c <GPIO_WritePin+0x60>
    2494:	82 2b       	or	r24, r18
    2496:	88 bb       	out	0x18, r24	; 24
    2498:	08 95       	ret
                else if(value == LOGIC_LOW)
    249a:	41 11       	cpse	r20, r1
    249c:	41 c0       	rjmp	.+130    	; 0x2520 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTB,PIN);
    249e:	28 b3       	in	r18, 0x18	; 24
    24a0:	81 e0       	ldi	r24, 0x01	; 1
    24a2:	90 e0       	ldi	r25, 0x00	; 0
    24a4:	02 c0       	rjmp	.+4      	; 0x24aa <GPIO_WritePin+0x7e>
    24a6:	88 0f       	add	r24, r24
    24a8:	99 1f       	adc	r25, r25
    24aa:	6a 95       	dec	r22
    24ac:	e2 f7       	brpl	.-8      	; 0x24a6 <GPIO_WritePin+0x7a>
    24ae:	80 95       	com	r24
    24b0:	82 23       	and	r24, r18
    24b2:	88 bb       	out	0x18, r24	; 24
    24b4:	08 95       	ret
                break;  

            case PORTC_ID :
                if(value == LOGIC_HIGH)
    24b6:	41 30       	cpi	r20, 0x01	; 1
    24b8:	59 f4       	brne	.+22     	; 0x24d0 <GPIO_WritePin+0xa4>
                    SET_BIT(PORTC,PIN);
    24ba:	25 b3       	in	r18, 0x15	; 21
    24bc:	81 e0       	ldi	r24, 0x01	; 1
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	02 c0       	rjmp	.+4      	; 0x24c6 <GPIO_WritePin+0x9a>
    24c2:	88 0f       	add	r24, r24
    24c4:	99 1f       	adc	r25, r25
    24c6:	6a 95       	dec	r22
    24c8:	e2 f7       	brpl	.-8      	; 0x24c2 <GPIO_WritePin+0x96>
    24ca:	82 2b       	or	r24, r18
    24cc:	85 bb       	out	0x15, r24	; 21
    24ce:	08 95       	ret
                else if(value == LOGIC_LOW)
    24d0:	41 11       	cpse	r20, r1
    24d2:	26 c0       	rjmp	.+76     	; 0x2520 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTC,PIN);
    24d4:	25 b3       	in	r18, 0x15	; 21
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	90 e0       	ldi	r25, 0x00	; 0
    24da:	02 c0       	rjmp	.+4      	; 0x24e0 <GPIO_WritePin+0xb4>
    24dc:	88 0f       	add	r24, r24
    24de:	99 1f       	adc	r25, r25
    24e0:	6a 95       	dec	r22
    24e2:	e2 f7       	brpl	.-8      	; 0x24dc <GPIO_WritePin+0xb0>
    24e4:	80 95       	com	r24
    24e6:	82 23       	and	r24, r18
    24e8:	85 bb       	out	0x15, r24	; 21
    24ea:	08 95       	ret
                break;

            case PORTD_ID :
                if(value == LOGIC_HIGH)
    24ec:	41 30       	cpi	r20, 0x01	; 1
    24ee:	59 f4       	brne	.+22     	; 0x2506 <GPIO_WritePin+0xda>
                    SET_BIT(PORTD,PIN);
    24f0:	22 b3       	in	r18, 0x12	; 18
    24f2:	81 e0       	ldi	r24, 0x01	; 1
    24f4:	90 e0       	ldi	r25, 0x00	; 0
    24f6:	02 c0       	rjmp	.+4      	; 0x24fc <GPIO_WritePin+0xd0>
    24f8:	88 0f       	add	r24, r24
    24fa:	99 1f       	adc	r25, r25
    24fc:	6a 95       	dec	r22
    24fe:	e2 f7       	brpl	.-8      	; 0x24f8 <GPIO_WritePin+0xcc>
    2500:	82 2b       	or	r24, r18
    2502:	82 bb       	out	0x12, r24	; 18
    2504:	08 95       	ret
                else if(value == LOGIC_LOW)
    2506:	41 11       	cpse	r20, r1
    2508:	0b c0       	rjmp	.+22     	; 0x2520 <GPIO_WritePin+0xf4>
                    CLEAR_BIT(PORTD,PIN);
    250a:	22 b3       	in	r18, 0x12	; 18
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	90 e0       	ldi	r25, 0x00	; 0
    2510:	02 c0       	rjmp	.+4      	; 0x2516 <GPIO_WritePin+0xea>
    2512:	88 0f       	add	r24, r24
    2514:	99 1f       	adc	r25, r25
    2516:	6a 95       	dec	r22
    2518:	e2 f7       	brpl	.-8      	; 0x2512 <GPIO_WritePin+0xe6>
    251a:	80 95       	com	r24
    251c:	82 23       	and	r24, r18
    251e:	82 bb       	out	0x12, r24	; 18
    2520:	08 95       	ret

00002522 <__vector_13>:
    uint16 Returned_value = 0;
    /*  Should read 9th bit of data if use 9 bit data before UDR*/
    Returned_value = ( (UCSRB & 0x02) << 7) ;
    Returned_value |= UDR ;
    return Returned_value;
}
    2522:	1f 92       	push	r1
    2524:	0f 92       	push	r0
    2526:	0f b6       	in	r0, 0x3f	; 63
    2528:	0f 92       	push	r0
    252a:	11 24       	eor	r1, r1
    252c:	2f 93       	push	r18
    252e:	3f 93       	push	r19
    2530:	4f 93       	push	r20
    2532:	5f 93       	push	r21
    2534:	6f 93       	push	r22
    2536:	7f 93       	push	r23
    2538:	8f 93       	push	r24
    253a:	9f 93       	push	r25
    253c:	af 93       	push	r26
    253e:	bf 93       	push	r27
    2540:	ef 93       	push	r30
    2542:	ff 93       	push	r31
    2544:	e0 91 39 06 	lds	r30, 0x0639	; 0x800639 <g_CallBackPtr_Receive_USART>
    2548:	f0 91 3a 06 	lds	r31, 0x063A	; 0x80063a <g_CallBackPtr_Receive_USART+0x1>
    254c:	30 97       	sbiw	r30, 0x00	; 0
    254e:	09 f0       	breq	.+2      	; 0x2552 <__vector_13+0x30>
    2550:	09 95       	icall
    2552:	ff 91       	pop	r31
    2554:	ef 91       	pop	r30
    2556:	bf 91       	pop	r27
    2558:	af 91       	pop	r26
    255a:	9f 91       	pop	r25
    255c:	8f 91       	pop	r24
    255e:	7f 91       	pop	r23
    2560:	6f 91       	pop	r22
    2562:	5f 91       	pop	r21
    2564:	4f 91       	pop	r20
    2566:	3f 91       	pop	r19
    2568:	2f 91       	pop	r18
    256a:	0f 90       	pop	r0
    256c:	0f be       	out	0x3f, r0	; 63
    256e:	0f 90       	pop	r0
    2570:	1f 90       	pop	r1
    2572:	18 95       	reti

00002574 <USART_Init>:
    2574:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <USART_ConfigTypeParam+0x3>
    2578:	81 11       	cpse	r24, r1
    257a:	04 c0       	rjmp	.+8      	; 0x2584 <USART_Init+0x10>
    257c:	8a b1       	in	r24, 0x0a	; 10
    257e:	88 60       	ori	r24, 0x08	; 8
    2580:	8a b9       	out	0x0a, r24	; 10
    2582:	0e c0       	rjmp	.+28     	; 0x25a0 <USART_Init+0x2c>
    2584:	81 30       	cpi	r24, 0x01	; 1
    2586:	21 f4       	brne	.+8      	; 0x2590 <USART_Init+0x1c>
    2588:	8a b1       	in	r24, 0x0a	; 10
    258a:	80 61       	ori	r24, 0x10	; 16
    258c:	8a b9       	out	0x0a, r24	; 10
    258e:	08 c0       	rjmp	.+16     	; 0x25a0 <USART_Init+0x2c>
    2590:	82 30       	cpi	r24, 0x02	; 2
    2592:	31 f4       	brne	.+12     	; 0x25a0 <USART_Init+0x2c>
    2594:	8a b1       	in	r24, 0x0a	; 10
    2596:	80 61       	ori	r24, 0x10	; 16
    2598:	8a b9       	out	0x0a, r24	; 10
    259a:	8a b1       	in	r24, 0x0a	; 10
    259c:	88 60       	ori	r24, 0x08	; 8
    259e:	8a b9       	out	0x0a, r24	; 10
    25a0:	e9 e6       	ldi	r30, 0x69	; 105
    25a2:	f0 e0       	ldi	r31, 0x00	; 0
    25a4:	41 81       	ldd	r20, Z+1	; 0x01
    25a6:	80 e1       	ldi	r24, 0x10	; 16
    25a8:	48 9f       	mul	r20, r24
    25aa:	a0 01       	movw	r20, r0
    25ac:	11 24       	eor	r1, r1
    25ae:	92 81       	ldd	r25, Z+2	; 0x02
    25b0:	29 2f       	mov	r18, r25
    25b2:	30 e0       	ldi	r19, 0x00	; 0
    25b4:	22 0f       	add	r18, r18
    25b6:	33 1f       	adc	r19, r19
    25b8:	22 0f       	add	r18, r18
    25ba:	33 1f       	adc	r19, r19
    25bc:	22 0f       	add	r18, r18
    25be:	33 1f       	adc	r19, r19
    25c0:	90 81       	ld	r25, Z
    25c2:	89 2f       	mov	r24, r25
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	88 0f       	add	r24, r24
    25c8:	99 1f       	adc	r25, r25
    25ca:	40 68       	ori	r20, 0x80	; 128
    25cc:	24 2b       	or	r18, r20
    25ce:	82 2b       	or	r24, r18
    25d0:	80 bd       	out	0x20, r24	; 32
    25d2:	2a b1       	in	r18, 0x0a	; 10
    25d4:	90 81       	ld	r25, Z
    25d6:	94 70       	andi	r25, 0x04	; 4
    25d8:	89 2f       	mov	r24, r25
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	88 0f       	add	r24, r24
    25de:	99 1f       	adc	r25, r25
    25e0:	88 0f       	add	r24, r24
    25e2:	99 1f       	adc	r25, r25
    25e4:	92 2f       	mov	r25, r18
    25e6:	9b 7f       	andi	r25, 0xFB	; 251
    25e8:	89 2b       	or	r24, r25
    25ea:	8a b9       	out	0x0a, r24	; 10
    25ec:	85 81       	ldd	r24, Z+5	; 0x05
    25ee:	80 bd       	out	0x20, r24	; 32
    25f0:	84 81       	ldd	r24, Z+4	; 0x04
    25f2:	89 b9       	out	0x09, r24	; 9
    25f4:	08 95       	ret

000025f6 <USART_SendBytePolling>:
    25f6:	5d 9b       	sbis	0x0b, 5	; 11
    25f8:	fe cf       	rjmp	.-4      	; 0x25f6 <USART_SendBytePolling>
    25fa:	90 ff       	sbrs	r25, 0
    25fc:	04 c0       	rjmp	.+8      	; 0x2606 <USART_SendBytePolling+0x10>
    25fe:	2a b1       	in	r18, 0x0a	; 10
    2600:	21 60       	ori	r18, 0x01	; 1
    2602:	2a b9       	out	0x0a, r18	; 10
    2604:	03 c0       	rjmp	.+6      	; 0x260c <USART_SendBytePolling+0x16>
    2606:	2a b1       	in	r18, 0x0a	; 10
    2608:	2e 7f       	andi	r18, 0xFE	; 254
    260a:	2a b9       	out	0x0a, r18	; 10
    260c:	8c b9       	out	0x0c, r24	; 12
    260e:	08 95       	ret

00002610 <USART_SendStringPolling>:
    2610:	0f 93       	push	r16
    2612:	1f 93       	push	r17
    2614:	cf 93       	push	r28
    2616:	8c 01       	movw	r16, r24
    2618:	c0 e0       	ldi	r28, 0x00	; 0
    261a:	04 c0       	rjmp	.+8      	; 0x2624 <USART_SendStringPolling+0x14>
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <USART_SendBytePolling>
    2622:	cf 5f       	subi	r28, 0xFF	; 255
    2624:	f8 01       	movw	r30, r16
    2626:	ec 0f       	add	r30, r28
    2628:	f1 1d       	adc	r31, r1
    262a:	80 81       	ld	r24, Z
    262c:	81 11       	cpse	r24, r1
    262e:	f6 cf       	rjmp	.-20     	; 0x261c <USART_SendStringPolling+0xc>
    2630:	cf 91       	pop	r28
    2632:	1f 91       	pop	r17
    2634:	0f 91       	pop	r16
    2636:	08 95       	ret

00002638 <UART_receiveByteUnblocking>:


boolean UART_receiveByteUnblocking(uint8 * Data)
{
    boolean result = FALSE;
	if ( UCSRA & (1<<RXC) ){
    2638:	5f 9b       	sbis	0x0b, 7	; 11
    263a:	05 c0       	rjmp	.+10     	; 0x2646 <UART_receiveByteUnblocking+0xe>
		(*Data) = UDR;
    263c:	2c b1       	in	r18, 0x0c	; 12
    263e:	fc 01       	movw	r30, r24
    2640:	20 83       	st	Z, r18
		result =  TRUE;		
    2642:	81 e0       	ldi	r24, 0x01	; 1
    2644:	08 95       	ret
	}
	else{
		result = FALSE;
    2646:	80 e0       	ldi	r24, 0x00	; 0
	}
	return result;
    2648:	08 95       	ret

0000264a <__subsf3>:
    264a:	50 58       	subi	r21, 0x80	; 128

0000264c <__addsf3>:
    264c:	bb 27       	eor	r27, r27
    264e:	aa 27       	eor	r26, r26
    2650:	0e 94 3d 13 	call	0x267a	; 0x267a <__addsf3x>
    2654:	0c 94 87 14 	jmp	0x290e	; 0x290e <__fp_round>
    2658:	0e 94 79 14 	call	0x28f2	; 0x28f2 <__fp_pscA>
    265c:	38 f0       	brcs	.+14     	; 0x266c <__addsf3+0x20>
    265e:	0e 94 80 14 	call	0x2900	; 0x2900 <__fp_pscB>
    2662:	20 f0       	brcs	.+8      	; 0x266c <__addsf3+0x20>
    2664:	39 f4       	brne	.+14     	; 0x2674 <__addsf3+0x28>
    2666:	9f 3f       	cpi	r25, 0xFF	; 255
    2668:	19 f4       	brne	.+6      	; 0x2670 <__addsf3+0x24>
    266a:	26 f4       	brtc	.+8      	; 0x2674 <__addsf3+0x28>
    266c:	0c 94 76 14 	jmp	0x28ec	; 0x28ec <__fp_nan>
    2670:	0e f4       	brtc	.+2      	; 0x2674 <__addsf3+0x28>
    2672:	e0 95       	com	r30
    2674:	e7 fb       	bst	r30, 7
    2676:	0c 94 70 14 	jmp	0x28e0	; 0x28e0 <__fp_inf>

0000267a <__addsf3x>:
    267a:	e9 2f       	mov	r30, r25
    267c:	0e 94 98 14 	call	0x2930	; 0x2930 <__fp_split3>
    2680:	58 f3       	brcs	.-42     	; 0x2658 <__addsf3+0xc>
    2682:	ba 17       	cp	r27, r26
    2684:	62 07       	cpc	r22, r18
    2686:	73 07       	cpc	r23, r19
    2688:	84 07       	cpc	r24, r20
    268a:	95 07       	cpc	r25, r21
    268c:	20 f0       	brcs	.+8      	; 0x2696 <__addsf3x+0x1c>
    268e:	79 f4       	brne	.+30     	; 0x26ae <__addsf3x+0x34>
    2690:	a6 f5       	brtc	.+104    	; 0x26fa <__addsf3x+0x80>
    2692:	0c 94 ba 14 	jmp	0x2974	; 0x2974 <__fp_zero>
    2696:	0e f4       	brtc	.+2      	; 0x269a <__addsf3x+0x20>
    2698:	e0 95       	com	r30
    269a:	0b 2e       	mov	r0, r27
    269c:	ba 2f       	mov	r27, r26
    269e:	a0 2d       	mov	r26, r0
    26a0:	0b 01       	movw	r0, r22
    26a2:	b9 01       	movw	r22, r18
    26a4:	90 01       	movw	r18, r0
    26a6:	0c 01       	movw	r0, r24
    26a8:	ca 01       	movw	r24, r20
    26aa:	a0 01       	movw	r20, r0
    26ac:	11 24       	eor	r1, r1
    26ae:	ff 27       	eor	r31, r31
    26b0:	59 1b       	sub	r21, r25
    26b2:	99 f0       	breq	.+38     	; 0x26da <__addsf3x+0x60>
    26b4:	59 3f       	cpi	r21, 0xF9	; 249
    26b6:	50 f4       	brcc	.+20     	; 0x26cc <__addsf3x+0x52>
    26b8:	50 3e       	cpi	r21, 0xE0	; 224
    26ba:	68 f1       	brcs	.+90     	; 0x2716 <__addsf3x+0x9c>
    26bc:	1a 16       	cp	r1, r26
    26be:	f0 40       	sbci	r31, 0x00	; 0
    26c0:	a2 2f       	mov	r26, r18
    26c2:	23 2f       	mov	r18, r19
    26c4:	34 2f       	mov	r19, r20
    26c6:	44 27       	eor	r20, r20
    26c8:	58 5f       	subi	r21, 0xF8	; 248
    26ca:	f3 cf       	rjmp	.-26     	; 0x26b2 <__addsf3x+0x38>
    26cc:	46 95       	lsr	r20
    26ce:	37 95       	ror	r19
    26d0:	27 95       	ror	r18
    26d2:	a7 95       	ror	r26
    26d4:	f0 40       	sbci	r31, 0x00	; 0
    26d6:	53 95       	inc	r21
    26d8:	c9 f7       	brne	.-14     	; 0x26cc <__addsf3x+0x52>
    26da:	7e f4       	brtc	.+30     	; 0x26fa <__addsf3x+0x80>
    26dc:	1f 16       	cp	r1, r31
    26de:	ba 0b       	sbc	r27, r26
    26e0:	62 0b       	sbc	r22, r18
    26e2:	73 0b       	sbc	r23, r19
    26e4:	84 0b       	sbc	r24, r20
    26e6:	ba f0       	brmi	.+46     	; 0x2716 <__addsf3x+0x9c>
    26e8:	91 50       	subi	r25, 0x01	; 1
    26ea:	a1 f0       	breq	.+40     	; 0x2714 <__addsf3x+0x9a>
    26ec:	ff 0f       	add	r31, r31
    26ee:	bb 1f       	adc	r27, r27
    26f0:	66 1f       	adc	r22, r22
    26f2:	77 1f       	adc	r23, r23
    26f4:	88 1f       	adc	r24, r24
    26f6:	c2 f7       	brpl	.-16     	; 0x26e8 <__addsf3x+0x6e>
    26f8:	0e c0       	rjmp	.+28     	; 0x2716 <__addsf3x+0x9c>
    26fa:	ba 0f       	add	r27, r26
    26fc:	62 1f       	adc	r22, r18
    26fe:	73 1f       	adc	r23, r19
    2700:	84 1f       	adc	r24, r20
    2702:	48 f4       	brcc	.+18     	; 0x2716 <__addsf3x+0x9c>
    2704:	87 95       	ror	r24
    2706:	77 95       	ror	r23
    2708:	67 95       	ror	r22
    270a:	b7 95       	ror	r27
    270c:	f7 95       	ror	r31
    270e:	9e 3f       	cpi	r25, 0xFE	; 254
    2710:	08 f0       	brcs	.+2      	; 0x2714 <__addsf3x+0x9a>
    2712:	b0 cf       	rjmp	.-160    	; 0x2674 <__addsf3+0x28>
    2714:	93 95       	inc	r25
    2716:	88 0f       	add	r24, r24
    2718:	08 f0       	brcs	.+2      	; 0x271c <__addsf3x+0xa2>
    271a:	99 27       	eor	r25, r25
    271c:	ee 0f       	add	r30, r30
    271e:	97 95       	ror	r25
    2720:	87 95       	ror	r24
    2722:	08 95       	ret

00002724 <__divsf3>:
    2724:	0e 94 a6 13 	call	0x274c	; 0x274c <__divsf3x>
    2728:	0c 94 87 14 	jmp	0x290e	; 0x290e <__fp_round>
    272c:	0e 94 80 14 	call	0x2900	; 0x2900 <__fp_pscB>
    2730:	58 f0       	brcs	.+22     	; 0x2748 <__divsf3+0x24>
    2732:	0e 94 79 14 	call	0x28f2	; 0x28f2 <__fp_pscA>
    2736:	40 f0       	brcs	.+16     	; 0x2748 <__divsf3+0x24>
    2738:	29 f4       	brne	.+10     	; 0x2744 <__divsf3+0x20>
    273a:	5f 3f       	cpi	r21, 0xFF	; 255
    273c:	29 f0       	breq	.+10     	; 0x2748 <__divsf3+0x24>
    273e:	0c 94 70 14 	jmp	0x28e0	; 0x28e0 <__fp_inf>
    2742:	51 11       	cpse	r21, r1
    2744:	0c 94 bb 14 	jmp	0x2976	; 0x2976 <__fp_szero>
    2748:	0c 94 76 14 	jmp	0x28ec	; 0x28ec <__fp_nan>

0000274c <__divsf3x>:
    274c:	0e 94 98 14 	call	0x2930	; 0x2930 <__fp_split3>
    2750:	68 f3       	brcs	.-38     	; 0x272c <__divsf3+0x8>

00002752 <__divsf3_pse>:
    2752:	99 23       	and	r25, r25
    2754:	b1 f3       	breq	.-20     	; 0x2742 <__divsf3+0x1e>
    2756:	55 23       	and	r21, r21
    2758:	91 f3       	breq	.-28     	; 0x273e <__divsf3+0x1a>
    275a:	95 1b       	sub	r25, r21
    275c:	55 0b       	sbc	r21, r21
    275e:	bb 27       	eor	r27, r27
    2760:	aa 27       	eor	r26, r26
    2762:	62 17       	cp	r22, r18
    2764:	73 07       	cpc	r23, r19
    2766:	84 07       	cpc	r24, r20
    2768:	38 f0       	brcs	.+14     	; 0x2778 <__divsf3_pse+0x26>
    276a:	9f 5f       	subi	r25, 0xFF	; 255
    276c:	5f 4f       	sbci	r21, 0xFF	; 255
    276e:	22 0f       	add	r18, r18
    2770:	33 1f       	adc	r19, r19
    2772:	44 1f       	adc	r20, r20
    2774:	aa 1f       	adc	r26, r26
    2776:	a9 f3       	breq	.-22     	; 0x2762 <__divsf3_pse+0x10>
    2778:	35 d0       	rcall	.+106    	; 0x27e4 <__divsf3_pse+0x92>
    277a:	0e 2e       	mov	r0, r30
    277c:	3a f0       	brmi	.+14     	; 0x278c <__divsf3_pse+0x3a>
    277e:	e0 e8       	ldi	r30, 0x80	; 128
    2780:	32 d0       	rcall	.+100    	; 0x27e6 <__divsf3_pse+0x94>
    2782:	91 50       	subi	r25, 0x01	; 1
    2784:	50 40       	sbci	r21, 0x00	; 0
    2786:	e6 95       	lsr	r30
    2788:	00 1c       	adc	r0, r0
    278a:	ca f7       	brpl	.-14     	; 0x277e <__divsf3_pse+0x2c>
    278c:	2b d0       	rcall	.+86     	; 0x27e4 <__divsf3_pse+0x92>
    278e:	fe 2f       	mov	r31, r30
    2790:	29 d0       	rcall	.+82     	; 0x27e4 <__divsf3_pse+0x92>
    2792:	66 0f       	add	r22, r22
    2794:	77 1f       	adc	r23, r23
    2796:	88 1f       	adc	r24, r24
    2798:	bb 1f       	adc	r27, r27
    279a:	26 17       	cp	r18, r22
    279c:	37 07       	cpc	r19, r23
    279e:	48 07       	cpc	r20, r24
    27a0:	ab 07       	cpc	r26, r27
    27a2:	b0 e8       	ldi	r27, 0x80	; 128
    27a4:	09 f0       	breq	.+2      	; 0x27a8 <__divsf3_pse+0x56>
    27a6:	bb 0b       	sbc	r27, r27
    27a8:	80 2d       	mov	r24, r0
    27aa:	bf 01       	movw	r22, r30
    27ac:	ff 27       	eor	r31, r31
    27ae:	93 58       	subi	r25, 0x83	; 131
    27b0:	5f 4f       	sbci	r21, 0xFF	; 255
    27b2:	3a f0       	brmi	.+14     	; 0x27c2 <__divsf3_pse+0x70>
    27b4:	9e 3f       	cpi	r25, 0xFE	; 254
    27b6:	51 05       	cpc	r21, r1
    27b8:	78 f0       	brcs	.+30     	; 0x27d8 <__divsf3_pse+0x86>
    27ba:	0c 94 70 14 	jmp	0x28e0	; 0x28e0 <__fp_inf>
    27be:	0c 94 bb 14 	jmp	0x2976	; 0x2976 <__fp_szero>
    27c2:	5f 3f       	cpi	r21, 0xFF	; 255
    27c4:	e4 f3       	brlt	.-8      	; 0x27be <__divsf3_pse+0x6c>
    27c6:	98 3e       	cpi	r25, 0xE8	; 232
    27c8:	d4 f3       	brlt	.-12     	; 0x27be <__divsf3_pse+0x6c>
    27ca:	86 95       	lsr	r24
    27cc:	77 95       	ror	r23
    27ce:	67 95       	ror	r22
    27d0:	b7 95       	ror	r27
    27d2:	f7 95       	ror	r31
    27d4:	9f 5f       	subi	r25, 0xFF	; 255
    27d6:	c9 f7       	brne	.-14     	; 0x27ca <__divsf3_pse+0x78>
    27d8:	88 0f       	add	r24, r24
    27da:	91 1d       	adc	r25, r1
    27dc:	96 95       	lsr	r25
    27de:	87 95       	ror	r24
    27e0:	97 f9       	bld	r25, 7
    27e2:	08 95       	ret
    27e4:	e1 e0       	ldi	r30, 0x01	; 1
    27e6:	66 0f       	add	r22, r22
    27e8:	77 1f       	adc	r23, r23
    27ea:	88 1f       	adc	r24, r24
    27ec:	bb 1f       	adc	r27, r27
    27ee:	62 17       	cp	r22, r18
    27f0:	73 07       	cpc	r23, r19
    27f2:	84 07       	cpc	r24, r20
    27f4:	ba 07       	cpc	r27, r26
    27f6:	20 f0       	brcs	.+8      	; 0x2800 <__divsf3_pse+0xae>
    27f8:	62 1b       	sub	r22, r18
    27fa:	73 0b       	sbc	r23, r19
    27fc:	84 0b       	sbc	r24, r20
    27fe:	ba 0b       	sbc	r27, r26
    2800:	ee 1f       	adc	r30, r30
    2802:	88 f7       	brcc	.-30     	; 0x27e6 <__divsf3_pse+0x94>
    2804:	e0 95       	com	r30
    2806:	08 95       	ret

00002808 <__fixunssfsi>:
    2808:	0e 94 a0 14 	call	0x2940	; 0x2940 <__fp_splitA>
    280c:	88 f0       	brcs	.+34     	; 0x2830 <__fixunssfsi+0x28>
    280e:	9f 57       	subi	r25, 0x7F	; 127
    2810:	98 f0       	brcs	.+38     	; 0x2838 <__fixunssfsi+0x30>
    2812:	b9 2f       	mov	r27, r25
    2814:	99 27       	eor	r25, r25
    2816:	b7 51       	subi	r27, 0x17	; 23
    2818:	b0 f0       	brcs	.+44     	; 0x2846 <__fixunssfsi+0x3e>
    281a:	e1 f0       	breq	.+56     	; 0x2854 <__fixunssfsi+0x4c>
    281c:	66 0f       	add	r22, r22
    281e:	77 1f       	adc	r23, r23
    2820:	88 1f       	adc	r24, r24
    2822:	99 1f       	adc	r25, r25
    2824:	1a f0       	brmi	.+6      	; 0x282c <__fixunssfsi+0x24>
    2826:	ba 95       	dec	r27
    2828:	c9 f7       	brne	.-14     	; 0x281c <__fixunssfsi+0x14>
    282a:	14 c0       	rjmp	.+40     	; 0x2854 <__fixunssfsi+0x4c>
    282c:	b1 30       	cpi	r27, 0x01	; 1
    282e:	91 f0       	breq	.+36     	; 0x2854 <__fixunssfsi+0x4c>
    2830:	0e 94 ba 14 	call	0x2974	; 0x2974 <__fp_zero>
    2834:	b1 e0       	ldi	r27, 0x01	; 1
    2836:	08 95       	ret
    2838:	0c 94 ba 14 	jmp	0x2974	; 0x2974 <__fp_zero>
    283c:	67 2f       	mov	r22, r23
    283e:	78 2f       	mov	r23, r24
    2840:	88 27       	eor	r24, r24
    2842:	b8 5f       	subi	r27, 0xF8	; 248
    2844:	39 f0       	breq	.+14     	; 0x2854 <__fixunssfsi+0x4c>
    2846:	b9 3f       	cpi	r27, 0xF9	; 249
    2848:	cc f3       	brlt	.-14     	; 0x283c <__fixunssfsi+0x34>
    284a:	86 95       	lsr	r24
    284c:	77 95       	ror	r23
    284e:	67 95       	ror	r22
    2850:	b3 95       	inc	r27
    2852:	d9 f7       	brne	.-10     	; 0x284a <__fixunssfsi+0x42>
    2854:	3e f4       	brtc	.+14     	; 0x2864 <__fixunssfsi+0x5c>
    2856:	90 95       	com	r25
    2858:	80 95       	com	r24
    285a:	70 95       	com	r23
    285c:	61 95       	neg	r22
    285e:	7f 4f       	sbci	r23, 0xFF	; 255
    2860:	8f 4f       	sbci	r24, 0xFF	; 255
    2862:	9f 4f       	sbci	r25, 0xFF	; 255
    2864:	08 95       	ret

00002866 <__floatunsisf>:
    2866:	e8 94       	clt
    2868:	09 c0       	rjmp	.+18     	; 0x287c <__floatsisf+0x12>

0000286a <__floatsisf>:
    286a:	97 fb       	bst	r25, 7
    286c:	3e f4       	brtc	.+14     	; 0x287c <__floatsisf+0x12>
    286e:	90 95       	com	r25
    2870:	80 95       	com	r24
    2872:	70 95       	com	r23
    2874:	61 95       	neg	r22
    2876:	7f 4f       	sbci	r23, 0xFF	; 255
    2878:	8f 4f       	sbci	r24, 0xFF	; 255
    287a:	9f 4f       	sbci	r25, 0xFF	; 255
    287c:	99 23       	and	r25, r25
    287e:	a9 f0       	breq	.+42     	; 0x28aa <__floatsisf+0x40>
    2880:	f9 2f       	mov	r31, r25
    2882:	96 e9       	ldi	r25, 0x96	; 150
    2884:	bb 27       	eor	r27, r27
    2886:	93 95       	inc	r25
    2888:	f6 95       	lsr	r31
    288a:	87 95       	ror	r24
    288c:	77 95       	ror	r23
    288e:	67 95       	ror	r22
    2890:	b7 95       	ror	r27
    2892:	f1 11       	cpse	r31, r1
    2894:	f8 cf       	rjmp	.-16     	; 0x2886 <__floatsisf+0x1c>
    2896:	fa f4       	brpl	.+62     	; 0x28d6 <__floatsisf+0x6c>
    2898:	bb 0f       	add	r27, r27
    289a:	11 f4       	brne	.+4      	; 0x28a0 <__floatsisf+0x36>
    289c:	60 ff       	sbrs	r22, 0
    289e:	1b c0       	rjmp	.+54     	; 0x28d6 <__floatsisf+0x6c>
    28a0:	6f 5f       	subi	r22, 0xFF	; 255
    28a2:	7f 4f       	sbci	r23, 0xFF	; 255
    28a4:	8f 4f       	sbci	r24, 0xFF	; 255
    28a6:	9f 4f       	sbci	r25, 0xFF	; 255
    28a8:	16 c0       	rjmp	.+44     	; 0x28d6 <__floatsisf+0x6c>
    28aa:	88 23       	and	r24, r24
    28ac:	11 f0       	breq	.+4      	; 0x28b2 <__floatsisf+0x48>
    28ae:	96 e9       	ldi	r25, 0x96	; 150
    28b0:	11 c0       	rjmp	.+34     	; 0x28d4 <__floatsisf+0x6a>
    28b2:	77 23       	and	r23, r23
    28b4:	21 f0       	breq	.+8      	; 0x28be <__floatsisf+0x54>
    28b6:	9e e8       	ldi	r25, 0x8E	; 142
    28b8:	87 2f       	mov	r24, r23
    28ba:	76 2f       	mov	r23, r22
    28bc:	05 c0       	rjmp	.+10     	; 0x28c8 <__floatsisf+0x5e>
    28be:	66 23       	and	r22, r22
    28c0:	71 f0       	breq	.+28     	; 0x28de <__floatsisf+0x74>
    28c2:	96 e8       	ldi	r25, 0x86	; 134
    28c4:	86 2f       	mov	r24, r22
    28c6:	70 e0       	ldi	r23, 0x00	; 0
    28c8:	60 e0       	ldi	r22, 0x00	; 0
    28ca:	2a f0       	brmi	.+10     	; 0x28d6 <__floatsisf+0x6c>
    28cc:	9a 95       	dec	r25
    28ce:	66 0f       	add	r22, r22
    28d0:	77 1f       	adc	r23, r23
    28d2:	88 1f       	adc	r24, r24
    28d4:	da f7       	brpl	.-10     	; 0x28cc <__floatsisf+0x62>
    28d6:	88 0f       	add	r24, r24
    28d8:	96 95       	lsr	r25
    28da:	87 95       	ror	r24
    28dc:	97 f9       	bld	r25, 7
    28de:	08 95       	ret

000028e0 <__fp_inf>:
    28e0:	97 f9       	bld	r25, 7
    28e2:	9f 67       	ori	r25, 0x7F	; 127
    28e4:	80 e8       	ldi	r24, 0x80	; 128
    28e6:	70 e0       	ldi	r23, 0x00	; 0
    28e8:	60 e0       	ldi	r22, 0x00	; 0
    28ea:	08 95       	ret

000028ec <__fp_nan>:
    28ec:	9f ef       	ldi	r25, 0xFF	; 255
    28ee:	80 ec       	ldi	r24, 0xC0	; 192
    28f0:	08 95       	ret

000028f2 <__fp_pscA>:
    28f2:	00 24       	eor	r0, r0
    28f4:	0a 94       	dec	r0
    28f6:	16 16       	cp	r1, r22
    28f8:	17 06       	cpc	r1, r23
    28fa:	18 06       	cpc	r1, r24
    28fc:	09 06       	cpc	r0, r25
    28fe:	08 95       	ret

00002900 <__fp_pscB>:
    2900:	00 24       	eor	r0, r0
    2902:	0a 94       	dec	r0
    2904:	12 16       	cp	r1, r18
    2906:	13 06       	cpc	r1, r19
    2908:	14 06       	cpc	r1, r20
    290a:	05 06       	cpc	r0, r21
    290c:	08 95       	ret

0000290e <__fp_round>:
    290e:	09 2e       	mov	r0, r25
    2910:	03 94       	inc	r0
    2912:	00 0c       	add	r0, r0
    2914:	11 f4       	brne	.+4      	; 0x291a <__fp_round+0xc>
    2916:	88 23       	and	r24, r24
    2918:	52 f0       	brmi	.+20     	; 0x292e <__fp_round+0x20>
    291a:	bb 0f       	add	r27, r27
    291c:	40 f4       	brcc	.+16     	; 0x292e <__fp_round+0x20>
    291e:	bf 2b       	or	r27, r31
    2920:	11 f4       	brne	.+4      	; 0x2926 <__fp_round+0x18>
    2922:	60 ff       	sbrs	r22, 0
    2924:	04 c0       	rjmp	.+8      	; 0x292e <__fp_round+0x20>
    2926:	6f 5f       	subi	r22, 0xFF	; 255
    2928:	7f 4f       	sbci	r23, 0xFF	; 255
    292a:	8f 4f       	sbci	r24, 0xFF	; 255
    292c:	9f 4f       	sbci	r25, 0xFF	; 255
    292e:	08 95       	ret

00002930 <__fp_split3>:
    2930:	57 fd       	sbrc	r21, 7
    2932:	90 58       	subi	r25, 0x80	; 128
    2934:	44 0f       	add	r20, r20
    2936:	55 1f       	adc	r21, r21
    2938:	59 f0       	breq	.+22     	; 0x2950 <__fp_splitA+0x10>
    293a:	5f 3f       	cpi	r21, 0xFF	; 255
    293c:	71 f0       	breq	.+28     	; 0x295a <__fp_splitA+0x1a>
    293e:	47 95       	ror	r20

00002940 <__fp_splitA>:
    2940:	88 0f       	add	r24, r24
    2942:	97 fb       	bst	r25, 7
    2944:	99 1f       	adc	r25, r25
    2946:	61 f0       	breq	.+24     	; 0x2960 <__fp_splitA+0x20>
    2948:	9f 3f       	cpi	r25, 0xFF	; 255
    294a:	79 f0       	breq	.+30     	; 0x296a <__fp_splitA+0x2a>
    294c:	87 95       	ror	r24
    294e:	08 95       	ret
    2950:	12 16       	cp	r1, r18
    2952:	13 06       	cpc	r1, r19
    2954:	14 06       	cpc	r1, r20
    2956:	55 1f       	adc	r21, r21
    2958:	f2 cf       	rjmp	.-28     	; 0x293e <__fp_split3+0xe>
    295a:	46 95       	lsr	r20
    295c:	f1 df       	rcall	.-30     	; 0x2940 <__fp_splitA>
    295e:	08 c0       	rjmp	.+16     	; 0x2970 <__fp_splitA+0x30>
    2960:	16 16       	cp	r1, r22
    2962:	17 06       	cpc	r1, r23
    2964:	18 06       	cpc	r1, r24
    2966:	99 1f       	adc	r25, r25
    2968:	f1 cf       	rjmp	.-30     	; 0x294c <__fp_splitA+0xc>
    296a:	86 95       	lsr	r24
    296c:	71 05       	cpc	r23, r1
    296e:	61 05       	cpc	r22, r1
    2970:	08 94       	sec
    2972:	08 95       	ret

00002974 <__fp_zero>:
    2974:	e8 94       	clt

00002976 <__fp_szero>:
    2976:	bb 27       	eor	r27, r27
    2978:	66 27       	eor	r22, r22
    297a:	77 27       	eor	r23, r23
    297c:	cb 01       	movw	r24, r22
    297e:	97 f9       	bld	r25, 7
    2980:	08 95       	ret
    2982:	16 f0       	brts	.+4      	; 0x2988 <__fp_szero+0x12>
    2984:	0c 94 7e 15 	jmp	0x2afc	; 0x2afc <__fp_mpack>
    2988:	0c 94 76 14 	jmp	0x28ec	; 0x28ec <__fp_nan>
    298c:	68 94       	set
    298e:	0c 94 70 14 	jmp	0x28e0	; 0x28e0 <__fp_inf>

00002992 <log>:
    2992:	0e 94 a0 14 	call	0x2940	; 0x2940 <__fp_splitA>
    2996:	a8 f3       	brcs	.-22     	; 0x2982 <__fp_szero+0xc>
    2998:	99 23       	and	r25, r25
    299a:	c1 f3       	breq	.-16     	; 0x298c <__fp_szero+0x16>
    299c:	ae f3       	brts	.-22     	; 0x2988 <__fp_szero+0x12>
    299e:	df 93       	push	r29
    29a0:	cf 93       	push	r28
    29a2:	1f 93       	push	r17
    29a4:	0f 93       	push	r16
    29a6:	ff 92       	push	r15
    29a8:	c9 2f       	mov	r28, r25
    29aa:	dd 27       	eor	r29, r29
    29ac:	88 23       	and	r24, r24
    29ae:	2a f0       	brmi	.+10     	; 0x29ba <log+0x28>
    29b0:	21 97       	sbiw	r28, 0x01	; 1
    29b2:	66 0f       	add	r22, r22
    29b4:	77 1f       	adc	r23, r23
    29b6:	88 1f       	adc	r24, r24
    29b8:	da f7       	brpl	.-10     	; 0x29b0 <log+0x1e>
    29ba:	20 e0       	ldi	r18, 0x00	; 0
    29bc:	30 e0       	ldi	r19, 0x00	; 0
    29be:	40 e8       	ldi	r20, 0x80	; 128
    29c0:	5f eb       	ldi	r21, 0xBF	; 191
    29c2:	9f e3       	ldi	r25, 0x3F	; 63
    29c4:	88 39       	cpi	r24, 0x98	; 152
    29c6:	20 f0       	brcs	.+8      	; 0x29d0 <log+0x3e>
    29c8:	80 3e       	cpi	r24, 0xE0	; 224
    29ca:	38 f0       	brcs	.+14     	; 0x29da <log+0x48>
    29cc:	21 96       	adiw	r28, 0x01	; 1
    29ce:	8f 77       	andi	r24, 0x7F	; 127
    29d0:	0e 94 26 13 	call	0x264c	; 0x264c <__addsf3>
    29d4:	e4 e5       	ldi	r30, 0x54	; 84
    29d6:	f0 e0       	ldi	r31, 0x00	; 0
    29d8:	04 c0       	rjmp	.+8      	; 0x29e2 <log+0x50>
    29da:	0e 94 26 13 	call	0x264c	; 0x264c <__addsf3>
    29de:	e1 e8       	ldi	r30, 0x81	; 129
    29e0:	f0 e0       	ldi	r31, 0x00	; 0
    29e2:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <__fp_powser>
    29e6:	8b 01       	movw	r16, r22
    29e8:	be 01       	movw	r22, r28
    29ea:	ec 01       	movw	r28, r24
    29ec:	fb 2e       	mov	r15, r27
    29ee:	6f 57       	subi	r22, 0x7F	; 127
    29f0:	71 09       	sbc	r23, r1
    29f2:	75 95       	asr	r23
    29f4:	77 1f       	adc	r23, r23
    29f6:	88 0b       	sbc	r24, r24
    29f8:	99 0b       	sbc	r25, r25
    29fa:	0e 94 35 14 	call	0x286a	; 0x286a <__floatsisf>
    29fe:	28 e1       	ldi	r18, 0x18	; 24
    2a00:	32 e7       	ldi	r19, 0x72	; 114
    2a02:	41 e3       	ldi	r20, 0x31	; 49
    2a04:	5f e3       	ldi	r21, 0x3F	; 63
    2a06:	0e 94 24 15 	call	0x2a48	; 0x2a48 <__mulsf3x>
    2a0a:	af 2d       	mov	r26, r15
    2a0c:	98 01       	movw	r18, r16
    2a0e:	ae 01       	movw	r20, r28
    2a10:	ff 90       	pop	r15
    2a12:	0f 91       	pop	r16
    2a14:	1f 91       	pop	r17
    2a16:	cf 91       	pop	r28
    2a18:	df 91       	pop	r29
    2a1a:	0e 94 3d 13 	call	0x267a	; 0x267a <__addsf3x>
    2a1e:	0c 94 87 14 	jmp	0x290e	; 0x290e <__fp_round>

00002a22 <__mulsf3>:
    2a22:	0e 94 24 15 	call	0x2a48	; 0x2a48 <__mulsf3x>
    2a26:	0c 94 87 14 	jmp	0x290e	; 0x290e <__fp_round>
    2a2a:	0e 94 79 14 	call	0x28f2	; 0x28f2 <__fp_pscA>
    2a2e:	38 f0       	brcs	.+14     	; 0x2a3e <__mulsf3+0x1c>
    2a30:	0e 94 80 14 	call	0x2900	; 0x2900 <__fp_pscB>
    2a34:	20 f0       	brcs	.+8      	; 0x2a3e <__mulsf3+0x1c>
    2a36:	95 23       	and	r25, r21
    2a38:	11 f0       	breq	.+4      	; 0x2a3e <__mulsf3+0x1c>
    2a3a:	0c 94 70 14 	jmp	0x28e0	; 0x28e0 <__fp_inf>
    2a3e:	0c 94 76 14 	jmp	0x28ec	; 0x28ec <__fp_nan>
    2a42:	11 24       	eor	r1, r1
    2a44:	0c 94 bb 14 	jmp	0x2976	; 0x2976 <__fp_szero>

00002a48 <__mulsf3x>:
    2a48:	0e 94 98 14 	call	0x2930	; 0x2930 <__fp_split3>
    2a4c:	70 f3       	brcs	.-36     	; 0x2a2a <__mulsf3+0x8>

00002a4e <__mulsf3_pse>:
    2a4e:	95 9f       	mul	r25, r21
    2a50:	c1 f3       	breq	.-16     	; 0x2a42 <__mulsf3+0x20>
    2a52:	95 0f       	add	r25, r21
    2a54:	50 e0       	ldi	r21, 0x00	; 0
    2a56:	55 1f       	adc	r21, r21
    2a58:	62 9f       	mul	r22, r18
    2a5a:	f0 01       	movw	r30, r0
    2a5c:	72 9f       	mul	r23, r18
    2a5e:	bb 27       	eor	r27, r27
    2a60:	f0 0d       	add	r31, r0
    2a62:	b1 1d       	adc	r27, r1
    2a64:	63 9f       	mul	r22, r19
    2a66:	aa 27       	eor	r26, r26
    2a68:	f0 0d       	add	r31, r0
    2a6a:	b1 1d       	adc	r27, r1
    2a6c:	aa 1f       	adc	r26, r26
    2a6e:	64 9f       	mul	r22, r20
    2a70:	66 27       	eor	r22, r22
    2a72:	b0 0d       	add	r27, r0
    2a74:	a1 1d       	adc	r26, r1
    2a76:	66 1f       	adc	r22, r22
    2a78:	82 9f       	mul	r24, r18
    2a7a:	22 27       	eor	r18, r18
    2a7c:	b0 0d       	add	r27, r0
    2a7e:	a1 1d       	adc	r26, r1
    2a80:	62 1f       	adc	r22, r18
    2a82:	73 9f       	mul	r23, r19
    2a84:	b0 0d       	add	r27, r0
    2a86:	a1 1d       	adc	r26, r1
    2a88:	62 1f       	adc	r22, r18
    2a8a:	83 9f       	mul	r24, r19
    2a8c:	a0 0d       	add	r26, r0
    2a8e:	61 1d       	adc	r22, r1
    2a90:	22 1f       	adc	r18, r18
    2a92:	74 9f       	mul	r23, r20
    2a94:	33 27       	eor	r19, r19
    2a96:	a0 0d       	add	r26, r0
    2a98:	61 1d       	adc	r22, r1
    2a9a:	23 1f       	adc	r18, r19
    2a9c:	84 9f       	mul	r24, r20
    2a9e:	60 0d       	add	r22, r0
    2aa0:	21 1d       	adc	r18, r1
    2aa2:	82 2f       	mov	r24, r18
    2aa4:	76 2f       	mov	r23, r22
    2aa6:	6a 2f       	mov	r22, r26
    2aa8:	11 24       	eor	r1, r1
    2aaa:	9f 57       	subi	r25, 0x7F	; 127
    2aac:	50 40       	sbci	r21, 0x00	; 0
    2aae:	9a f0       	brmi	.+38     	; 0x2ad6 <__mulsf3_pse+0x88>
    2ab0:	f1 f0       	breq	.+60     	; 0x2aee <__mulsf3_pse+0xa0>
    2ab2:	88 23       	and	r24, r24
    2ab4:	4a f0       	brmi	.+18     	; 0x2ac8 <__mulsf3_pse+0x7a>
    2ab6:	ee 0f       	add	r30, r30
    2ab8:	ff 1f       	adc	r31, r31
    2aba:	bb 1f       	adc	r27, r27
    2abc:	66 1f       	adc	r22, r22
    2abe:	77 1f       	adc	r23, r23
    2ac0:	88 1f       	adc	r24, r24
    2ac2:	91 50       	subi	r25, 0x01	; 1
    2ac4:	50 40       	sbci	r21, 0x00	; 0
    2ac6:	a9 f7       	brne	.-22     	; 0x2ab2 <__mulsf3_pse+0x64>
    2ac8:	9e 3f       	cpi	r25, 0xFE	; 254
    2aca:	51 05       	cpc	r21, r1
    2acc:	80 f0       	brcs	.+32     	; 0x2aee <__mulsf3_pse+0xa0>
    2ace:	0c 94 70 14 	jmp	0x28e0	; 0x28e0 <__fp_inf>
    2ad2:	0c 94 bb 14 	jmp	0x2976	; 0x2976 <__fp_szero>
    2ad6:	5f 3f       	cpi	r21, 0xFF	; 255
    2ad8:	e4 f3       	brlt	.-8      	; 0x2ad2 <__mulsf3_pse+0x84>
    2ada:	98 3e       	cpi	r25, 0xE8	; 232
    2adc:	d4 f3       	brlt	.-12     	; 0x2ad2 <__mulsf3_pse+0x84>
    2ade:	86 95       	lsr	r24
    2ae0:	77 95       	ror	r23
    2ae2:	67 95       	ror	r22
    2ae4:	b7 95       	ror	r27
    2ae6:	f7 95       	ror	r31
    2ae8:	e7 95       	ror	r30
    2aea:	9f 5f       	subi	r25, 0xFF	; 255
    2aec:	c1 f7       	brne	.-16     	; 0x2ade <__mulsf3_pse+0x90>
    2aee:	fe 2b       	or	r31, r30
    2af0:	88 0f       	add	r24, r24
    2af2:	91 1d       	adc	r25, r1
    2af4:	96 95       	lsr	r25
    2af6:	87 95       	ror	r24
    2af8:	97 f9       	bld	r25, 7
    2afa:	08 95       	ret

00002afc <__fp_mpack>:
    2afc:	9f 3f       	cpi	r25, 0xFF	; 255
    2afe:	31 f0       	breq	.+12     	; 0x2b0c <__fp_mpack_finite+0xc>

00002b00 <__fp_mpack_finite>:
    2b00:	91 50       	subi	r25, 0x01	; 1
    2b02:	20 f4       	brcc	.+8      	; 0x2b0c <__fp_mpack_finite+0xc>
    2b04:	87 95       	ror	r24
    2b06:	77 95       	ror	r23
    2b08:	67 95       	ror	r22
    2b0a:	b7 95       	ror	r27
    2b0c:	88 0f       	add	r24, r24
    2b0e:	91 1d       	adc	r25, r1
    2b10:	96 95       	lsr	r25
    2b12:	87 95       	ror	r24
    2b14:	97 f9       	bld	r25, 7
    2b16:	08 95       	ret

00002b18 <__fp_powser>:
    2b18:	df 93       	push	r29
    2b1a:	cf 93       	push	r28
    2b1c:	1f 93       	push	r17
    2b1e:	0f 93       	push	r16
    2b20:	ff 92       	push	r15
    2b22:	ef 92       	push	r14
    2b24:	df 92       	push	r13
    2b26:	7b 01       	movw	r14, r22
    2b28:	8c 01       	movw	r16, r24
    2b2a:	68 94       	set
    2b2c:	06 c0       	rjmp	.+12     	; 0x2b3a <__fp_powser+0x22>
    2b2e:	da 2e       	mov	r13, r26
    2b30:	ef 01       	movw	r28, r30
    2b32:	0e 94 24 15 	call	0x2a48	; 0x2a48 <__mulsf3x>
    2b36:	fe 01       	movw	r30, r28
    2b38:	e8 94       	clt
    2b3a:	a5 91       	lpm	r26, Z+
    2b3c:	25 91       	lpm	r18, Z+
    2b3e:	35 91       	lpm	r19, Z+
    2b40:	45 91       	lpm	r20, Z+
    2b42:	55 91       	lpm	r21, Z+
    2b44:	a6 f3       	brts	.-24     	; 0x2b2e <__fp_powser+0x16>
    2b46:	ef 01       	movw	r28, r30
    2b48:	0e 94 3d 13 	call	0x267a	; 0x267a <__addsf3x>
    2b4c:	fe 01       	movw	r30, r28
    2b4e:	97 01       	movw	r18, r14
    2b50:	a8 01       	movw	r20, r16
    2b52:	da 94       	dec	r13
    2b54:	69 f7       	brne	.-38     	; 0x2b30 <__fp_powser+0x18>
    2b56:	df 90       	pop	r13
    2b58:	ef 90       	pop	r14
    2b5a:	ff 90       	pop	r15
    2b5c:	0f 91       	pop	r16
    2b5e:	1f 91       	pop	r17
    2b60:	cf 91       	pop	r28
    2b62:	df 91       	pop	r29
    2b64:	08 95       	ret

00002b66 <memcpy>:
    2b66:	fb 01       	movw	r30, r22
    2b68:	dc 01       	movw	r26, r24
    2b6a:	02 c0       	rjmp	.+4      	; 0x2b70 <memcpy+0xa>
    2b6c:	01 90       	ld	r0, Z+
    2b6e:	0d 92       	st	X+, r0
    2b70:	41 50       	subi	r20, 0x01	; 1
    2b72:	50 40       	sbci	r21, 0x00	; 0
    2b74:	d8 f7       	brcc	.-10     	; 0x2b6c <memcpy+0x6>
    2b76:	08 95       	ret

00002b78 <__itoa_ncheck>:
    2b78:	bb 27       	eor	r27, r27
    2b7a:	4a 30       	cpi	r20, 0x0A	; 10
    2b7c:	31 f4       	brne	.+12     	; 0x2b8a <__itoa_ncheck+0x12>
    2b7e:	99 23       	and	r25, r25
    2b80:	22 f4       	brpl	.+8      	; 0x2b8a <__itoa_ncheck+0x12>
    2b82:	bd e2       	ldi	r27, 0x2D	; 45
    2b84:	90 95       	com	r25
    2b86:	81 95       	neg	r24
    2b88:	9f 4f       	sbci	r25, 0xFF	; 255
    2b8a:	0c 94 c8 15 	jmp	0x2b90	; 0x2b90 <__utoa_common>

00002b8e <__utoa_ncheck>:
    2b8e:	bb 27       	eor	r27, r27

00002b90 <__utoa_common>:
    2b90:	fb 01       	movw	r30, r22
    2b92:	55 27       	eor	r21, r21
    2b94:	aa 27       	eor	r26, r26
    2b96:	88 0f       	add	r24, r24
    2b98:	99 1f       	adc	r25, r25
    2b9a:	aa 1f       	adc	r26, r26
    2b9c:	a4 17       	cp	r26, r20
    2b9e:	10 f0       	brcs	.+4      	; 0x2ba4 <__utoa_common+0x14>
    2ba0:	a4 1b       	sub	r26, r20
    2ba2:	83 95       	inc	r24
    2ba4:	50 51       	subi	r21, 0x10	; 16
    2ba6:	b9 f7       	brne	.-18     	; 0x2b96 <__utoa_common+0x6>
    2ba8:	a0 5d       	subi	r26, 0xD0	; 208
    2baa:	aa 33       	cpi	r26, 0x3A	; 58
    2bac:	08 f0       	brcs	.+2      	; 0x2bb0 <__utoa_common+0x20>
    2bae:	a9 5d       	subi	r26, 0xD9	; 217
    2bb0:	a1 93       	st	Z+, r26
    2bb2:	00 97       	sbiw	r24, 0x00	; 0
    2bb4:	79 f7       	brne	.-34     	; 0x2b94 <__utoa_common+0x4>
    2bb6:	b1 11       	cpse	r27, r1
    2bb8:	b1 93       	st	Z+, r27
    2bba:	11 92       	st	Z+, r1
    2bbc:	cb 01       	movw	r24, r22
    2bbe:	0c 94 e1 15 	jmp	0x2bc2	; 0x2bc2 <strrev>

00002bc2 <strrev>:
    2bc2:	dc 01       	movw	r26, r24
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	67 2f       	mov	r22, r23
    2bc8:	71 91       	ld	r23, Z+
    2bca:	77 23       	and	r23, r23
    2bcc:	e1 f7       	brne	.-8      	; 0x2bc6 <strrev+0x4>
    2bce:	32 97       	sbiw	r30, 0x02	; 2
    2bd0:	04 c0       	rjmp	.+8      	; 0x2bda <strrev+0x18>
    2bd2:	7c 91       	ld	r23, X
    2bd4:	6d 93       	st	X+, r22
    2bd6:	70 83       	st	Z, r23
    2bd8:	62 91       	ld	r22, -Z
    2bda:	ae 17       	cp	r26, r30
    2bdc:	bf 07       	cpc	r27, r31
    2bde:	c8 f3       	brcs	.-14     	; 0x2bd2 <strrev+0x10>
    2be0:	08 95       	ret

00002be2 <_exit>:
    2be2:	f8 94       	cli

00002be4 <__stop_program>:
    2be4:	ff cf       	rjmp	.-2      	; 0x2be4 <__stop_program>
